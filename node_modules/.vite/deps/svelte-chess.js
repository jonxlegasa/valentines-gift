import {
  Chess,
  SQUARES
} from "./chunk-MPCFGEMO.js";
import "./chunk-MZVN5SDE.js";
import {
  add_locations,
  append_styles,
  bind_prop,
  bind_this,
  check_target,
  cleanup_styles,
  createEventDispatcher,
  create_ownership_validator,
  each,
  hmr,
  index,
  init,
  legacy_api,
  onMount,
  prop,
  set_attribute,
  set_class,
  set_style
} from "./chunk-FFNYK22D.js";
import "./chunk-U7P2NEEE.js";
import {
  append,
  from_html
} from "./chunk-JSQVNZMN.js";
import {
  FILENAME,
  HMR,
  add_svelte_meta,
  child,
  deep_read_state,
  derived_safe_equal,
  event,
  get,
  legacy_pre_effect,
  legacy_pre_effect_reset,
  mutable_source,
  pop,
  push,
  reset,
  set,
  strict_equals,
  tag,
  template_effect,
  untrack
} from "./chunk-AJNWVN3S.js";
import "./chunk-XWATFG4W.js";
import "./chunk-HNWPC2PS.js";
import "./chunk-Z2FMKYKV.js";
import "./chunk-OHYQYV5R.js";

// node_modules/chessground/types.js
var colors = ["white", "black"];
var files = ["a", "b", "c", "d", "e", "f", "g", "h"];
var ranks = ["1", "2", "3", "4", "5", "6", "7", "8"];

// node_modules/chessground/util.js
var invRanks = [...ranks].reverse();
var allKeys = Array.prototype.concat(...files.map((c) => ranks.map((r) => c + r)));
var pos2key = (pos) => allKeys[8 * pos[0] + pos[1]];
var key2pos = (k) => [k.charCodeAt(0) - 97, k.charCodeAt(1) - 49];
var allPos = allKeys.map(key2pos);
function memo(f) {
  let v;
  const ret = () => {
    if (v === void 0)
      v = f();
    return v;
  };
  ret.clear = () => {
    v = void 0;
  };
  return ret;
}
var timer = () => {
  let startAt;
  return {
    start() {
      startAt = performance.now();
    },
    cancel() {
      startAt = void 0;
    },
    stop() {
      if (!startAt)
        return 0;
      const time = performance.now() - startAt;
      startAt = void 0;
      return time;
    }
  };
};
var opposite = (c) => c === "white" ? "black" : "white";
var distanceSq = (pos1, pos2) => {
  const dx = pos1[0] - pos2[0], dy = pos1[1] - pos2[1];
  return dx * dx + dy * dy;
};
var samePiece = (p1, p2) => p1.role === p2.role && p1.color === p2.color;
var posToTranslate = (bounds) => (pos, asWhite) => [
  (asWhite ? pos[0] : 7 - pos[0]) * bounds.width / 8,
  (asWhite ? 7 - pos[1] : pos[1]) * bounds.height / 8
];
var translate = (el, pos) => {
  el.style.transform = `translate(${pos[0]}px,${pos[1]}px)`;
};
var translateAndScale = (el, pos, scale = 1) => {
  el.style.transform = `translate(${pos[0]}px,${pos[1]}px) scale(${scale})`;
};
var setVisible = (el, v) => {
  el.style.visibility = v ? "visible" : "hidden";
};
var eventPosition = (e) => {
  var _a;
  if (e.clientX || e.clientX === 0)
    return [e.clientX, e.clientY];
  if ((_a = e.targetTouches) === null || _a === void 0 ? void 0 : _a[0])
    return [e.targetTouches[0].clientX, e.targetTouches[0].clientY];
  return;
};
var isRightButton = (e) => e.buttons === 2 || e.button === 2;
var createEl = (tagName, className) => {
  const el = document.createElement(tagName);
  if (className)
    el.className = className;
  return el;
};
function computeSquareCenter(key, asWhite, bounds) {
  const pos = key2pos(key);
  if (!asWhite) {
    pos[0] = 7 - pos[0];
    pos[1] = 7 - pos[1];
  }
  return [
    bounds.left + bounds.width * pos[0] / 8 + bounds.width / 16,
    bounds.top + bounds.height * (7 - pos[1]) / 8 + bounds.height / 16
  ];
}

// node_modules/chessground/premove.js
var diff = (a, b) => Math.abs(a - b);
var pawn = (color) => (x1, y1, x2, y2) => diff(x1, x2) < 2 && (color === "white" ? (
  // allow 2 squares from first two ranks, for horde
  y2 === y1 + 1 || y1 <= 1 && y2 === y1 + 2 && x1 === x2
) : y2 === y1 - 1 || y1 >= 6 && y2 === y1 - 2 && x1 === x2);
var knight = (x1, y1, x2, y2) => {
  const xd = diff(x1, x2);
  const yd = diff(y1, y2);
  return xd === 1 && yd === 2 || xd === 2 && yd === 1;
};
var bishop = (x1, y1, x2, y2) => {
  return diff(x1, x2) === diff(y1, y2);
};
var rook = (x1, y1, x2, y2) => {
  return x1 === x2 || y1 === y2;
};
var queen = (x1, y1, x2, y2) => {
  return bishop(x1, y1, x2, y2) || rook(x1, y1, x2, y2);
};
var king = (color, rookFiles, canCastle) => (x1, y1, x2, y2) => diff(x1, x2) < 2 && diff(y1, y2) < 2 || canCastle && y1 === y2 && y1 === (color === "white" ? 0 : 7) && (x1 === 4 && (x2 === 2 && rookFiles.includes(0) || x2 === 6 && rookFiles.includes(7)) || rookFiles.includes(x2));
function rookFilesOf(pieces, color) {
  const backrank = color === "white" ? "1" : "8";
  const files2 = [];
  for (const [key, piece] of pieces) {
    if (key[1] === backrank && piece.color === color && piece.role === "rook") {
      files2.push(key2pos(key)[0]);
    }
  }
  return files2;
}
function premove(pieces, key, canCastle) {
  const piece = pieces.get(key);
  if (!piece)
    return [];
  const pos = key2pos(key), r = piece.role, mobility = r === "pawn" ? pawn(piece.color) : r === "knight" ? knight : r === "bishop" ? bishop : r === "rook" ? rook : r === "queen" ? queen : king(piece.color, rookFilesOf(pieces, piece.color), canCastle);
  return allPos.filter((pos2) => (pos[0] !== pos2[0] || pos[1] !== pos2[1]) && mobility(pos[0], pos[1], pos2[0], pos2[1])).map(pos2key);
}

// node_modules/chessground/board.js
function callUserFunction(f, ...args) {
  if (f)
    setTimeout(() => f(...args), 1);
}
function toggleOrientation(state) {
  state.orientation = opposite(state.orientation);
  state.animation.current = state.draggable.current = state.selected = void 0;
}
function setPieces(state, pieces) {
  for (const [key, piece] of pieces) {
    if (piece)
      state.pieces.set(key, piece);
    else
      state.pieces.delete(key);
  }
}
function setCheck(state, color) {
  state.check = void 0;
  if (color === true)
    color = state.turnColor;
  if (color)
    for (const [k, p] of state.pieces) {
      if (p.role === "king" && p.color === color) {
        state.check = k;
      }
    }
}
function setPremove(state, orig, dest, meta) {
  unsetPredrop(state);
  state.premovable.current = [orig, dest];
  callUserFunction(state.premovable.events.set, orig, dest, meta);
}
function unsetPremove(state) {
  if (state.premovable.current) {
    state.premovable.current = void 0;
    callUserFunction(state.premovable.events.unset);
  }
}
function setPredrop(state, role, key) {
  unsetPremove(state);
  state.predroppable.current = { role, key };
  callUserFunction(state.predroppable.events.set, role, key);
}
function unsetPredrop(state) {
  const pd = state.predroppable;
  if (pd.current) {
    pd.current = void 0;
    callUserFunction(pd.events.unset);
  }
}
function tryAutoCastle(state, orig, dest) {
  if (!state.autoCastle)
    return false;
  const king2 = state.pieces.get(orig);
  if (!king2 || king2.role !== "king")
    return false;
  const origPos = key2pos(orig);
  const destPos = key2pos(dest);
  if (origPos[1] !== 0 && origPos[1] !== 7 || origPos[1] !== destPos[1])
    return false;
  if (origPos[0] === 4 && !state.pieces.has(dest)) {
    if (destPos[0] === 6)
      dest = pos2key([7, destPos[1]]);
    else if (destPos[0] === 2)
      dest = pos2key([0, destPos[1]]);
  }
  const rook2 = state.pieces.get(dest);
  if (!rook2 || rook2.color !== king2.color || rook2.role !== "rook")
    return false;
  state.pieces.delete(orig);
  state.pieces.delete(dest);
  if (origPos[0] < destPos[0]) {
    state.pieces.set(pos2key([6, destPos[1]]), king2);
    state.pieces.set(pos2key([5, destPos[1]]), rook2);
  } else {
    state.pieces.set(pos2key([2, destPos[1]]), king2);
    state.pieces.set(pos2key([3, destPos[1]]), rook2);
  }
  return true;
}
function baseMove(state, orig, dest) {
  const origPiece = state.pieces.get(orig), destPiece = state.pieces.get(dest);
  if (orig === dest || !origPiece)
    return false;
  const captured = destPiece && destPiece.color !== origPiece.color ? destPiece : void 0;
  if (dest === state.selected)
    unselect(state);
  callUserFunction(state.events.move, orig, dest, captured);
  if (!tryAutoCastle(state, orig, dest)) {
    state.pieces.set(dest, origPiece);
    state.pieces.delete(orig);
  }
  state.lastMove = [orig, dest];
  state.check = void 0;
  callUserFunction(state.events.change);
  return captured || true;
}
function baseNewPiece(state, piece, key, force) {
  if (state.pieces.has(key)) {
    if (force)
      state.pieces.delete(key);
    else
      return false;
  }
  callUserFunction(state.events.dropNewPiece, piece, key);
  state.pieces.set(key, piece);
  state.lastMove = [key];
  state.check = void 0;
  callUserFunction(state.events.change);
  state.movable.dests = void 0;
  state.turnColor = opposite(state.turnColor);
  return true;
}
function baseUserMove(state, orig, dest) {
  const result = baseMove(state, orig, dest);
  if (result) {
    state.movable.dests = void 0;
    state.turnColor = opposite(state.turnColor);
    state.animation.current = void 0;
  }
  return result;
}
function userMove(state, orig, dest) {
  if (canMove(state, orig, dest)) {
    const result = baseUserMove(state, orig, dest);
    if (result) {
      const holdTime = state.hold.stop();
      unselect(state);
      const metadata = {
        premove: false,
        ctrlKey: state.stats.ctrlKey,
        holdTime
      };
      if (result !== true)
        metadata.captured = result;
      callUserFunction(state.movable.events.after, orig, dest, metadata);
      return true;
    }
  } else if (canPremove(state, orig, dest)) {
    setPremove(state, orig, dest, {
      ctrlKey: state.stats.ctrlKey
    });
    unselect(state);
    return true;
  }
  unselect(state);
  return false;
}
function dropNewPiece(state, orig, dest, force) {
  const piece = state.pieces.get(orig);
  if (piece && (canDrop(state, orig, dest) || force)) {
    state.pieces.delete(orig);
    baseNewPiece(state, piece, dest, force);
    callUserFunction(state.movable.events.afterNewPiece, piece.role, dest, {
      premove: false,
      predrop: false
    });
  } else if (piece && canPredrop(state, orig, dest)) {
    setPredrop(state, piece.role, dest);
  } else {
    unsetPremove(state);
    unsetPredrop(state);
  }
  state.pieces.delete(orig);
  unselect(state);
}
function selectSquare(state, key, force) {
  callUserFunction(state.events.select, key);
  if (state.selected) {
    if (state.selected === key && !state.draggable.enabled) {
      unselect(state);
      state.hold.cancel();
      return;
    } else if ((state.selectable.enabled || force) && state.selected !== key) {
      if (userMove(state, state.selected, key)) {
        state.stats.dragged = false;
        return;
      }
    }
  }
  if ((state.selectable.enabled || state.draggable.enabled) && (isMovable(state, key) || isPremovable(state, key))) {
    setSelected(state, key);
    state.hold.start();
  }
}
function setSelected(state, key) {
  state.selected = key;
  if (isPremovable(state, key)) {
    if (!state.premovable.customDests) {
      state.premovable.dests = premove(state.pieces, key, state.premovable.castle);
    }
  } else
    state.premovable.dests = void 0;
}
function unselect(state) {
  state.selected = void 0;
  state.premovable.dests = void 0;
  state.hold.cancel();
}
function isMovable(state, orig) {
  const piece = state.pieces.get(orig);
  return !!piece && (state.movable.color === "both" || state.movable.color === piece.color && state.turnColor === piece.color);
}
var canMove = (state, orig, dest) => {
  var _a, _b;
  return orig !== dest && isMovable(state, orig) && (state.movable.free || !!((_b = (_a = state.movable.dests) === null || _a === void 0 ? void 0 : _a.get(orig)) === null || _b === void 0 ? void 0 : _b.includes(dest)));
};
function canDrop(state, orig, dest) {
  const piece = state.pieces.get(orig);
  return !!piece && (orig === dest || !state.pieces.has(dest)) && (state.movable.color === "both" || state.movable.color === piece.color && state.turnColor === piece.color);
}
function isPremovable(state, orig) {
  const piece = state.pieces.get(orig);
  return !!piece && state.premovable.enabled && state.movable.color === piece.color && state.turnColor !== piece.color;
}
function canPremove(state, orig, dest) {
  var _a, _b;
  const validPremoves = (_b = (_a = state.premovable.customDests) === null || _a === void 0 ? void 0 : _a.get(orig)) !== null && _b !== void 0 ? _b : premove(state.pieces, orig, state.premovable.castle);
  return orig !== dest && isPremovable(state, orig) && validPremoves.includes(dest);
}
function canPredrop(state, orig, dest) {
  const piece = state.pieces.get(orig);
  const destPiece = state.pieces.get(dest);
  return !!piece && (!destPiece || destPiece.color !== state.movable.color) && state.predroppable.enabled && (piece.role !== "pawn" || dest[1] !== "1" && dest[1] !== "8") && state.movable.color === piece.color && state.turnColor !== piece.color;
}
function isDraggable(state, orig) {
  const piece = state.pieces.get(orig);
  return !!piece && state.draggable.enabled && (state.movable.color === "both" || state.movable.color === piece.color && (state.turnColor === piece.color || state.premovable.enabled));
}
function playPremove(state) {
  const move3 = state.premovable.current;
  if (!move3)
    return false;
  const orig = move3[0], dest = move3[1];
  let success = false;
  if (canMove(state, orig, dest)) {
    const result = baseUserMove(state, orig, dest);
    if (result) {
      const metadata = { premove: true };
      if (result !== true)
        metadata.captured = result;
      callUserFunction(state.movable.events.after, orig, dest, metadata);
      success = true;
    }
  }
  unsetPremove(state);
  return success;
}
function playPredrop(state, validate) {
  const drop2 = state.predroppable.current;
  let success = false;
  if (!drop2)
    return false;
  if (validate(drop2)) {
    const piece = {
      role: drop2.role,
      color: state.movable.color
    };
    if (baseNewPiece(state, piece, drop2.key)) {
      callUserFunction(state.movable.events.afterNewPiece, drop2.role, drop2.key, {
        premove: false,
        predrop: true
      });
      success = true;
    }
  }
  unsetPredrop(state);
  return success;
}
function cancelMove(state) {
  unsetPremove(state);
  unsetPredrop(state);
  unselect(state);
}
function stop(state) {
  state.movable.color = state.movable.dests = state.animation.current = void 0;
  cancelMove(state);
}
function getKeyAtDomPos(pos, asWhite, bounds) {
  let file = Math.floor(8 * (pos[0] - bounds.left) / bounds.width);
  if (!asWhite)
    file = 7 - file;
  let rank = 7 - Math.floor(8 * (pos[1] - bounds.top) / bounds.height);
  if (!asWhite)
    rank = 7 - rank;
  return file >= 0 && file < 8 && rank >= 0 && rank < 8 ? pos2key([file, rank]) : void 0;
}
function getSnappedKeyAtDomPos(orig, pos, asWhite, bounds) {
  const origPos = key2pos(orig);
  const validSnapPos = allPos.filter((pos2) => queen(origPos[0], origPos[1], pos2[0], pos2[1]) || knight(origPos[0], origPos[1], pos2[0], pos2[1]));
  const validSnapCenters = validSnapPos.map((pos2) => computeSquareCenter(pos2key(pos2), asWhite, bounds));
  const validSnapDistances = validSnapCenters.map((pos2) => distanceSq(pos, pos2));
  const [, closestSnapIndex] = validSnapDistances.reduce((a, b, index2) => a[0] < b ? a : [b, index2], [validSnapDistances[0], 0]);
  return pos2key(validSnapPos[closestSnapIndex]);
}
var whitePov = (s) => s.orientation === "white";

// node_modules/chessground/fen.js
var initial = "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR";
var roles = {
  p: "pawn",
  r: "rook",
  n: "knight",
  b: "bishop",
  q: "queen",
  k: "king"
};
var letters = {
  pawn: "p",
  rook: "r",
  knight: "n",
  bishop: "b",
  queen: "q",
  king: "k"
};
function read(fen) {
  if (fen === "start")
    fen = initial;
  const pieces = /* @__PURE__ */ new Map();
  let row = 7, col = 0;
  for (const c of fen) {
    switch (c) {
      case " ":
      case "[":
        return pieces;
      case "/":
        --row;
        if (row < 0)
          return pieces;
        col = 0;
        break;
      case "~": {
        const piece = pieces.get(pos2key([col - 1, row]));
        if (piece)
          piece.promoted = true;
        break;
      }
      default: {
        const nb = c.charCodeAt(0);
        if (nb < 57)
          col += nb - 48;
        else {
          const role = c.toLowerCase();
          pieces.set(pos2key([col, row]), {
            role: roles[role],
            color: c === role ? "black" : "white"
          });
          ++col;
        }
      }
    }
  }
  return pieces;
}
function write(pieces) {
  return invRanks.map((y) => files.map((x) => {
    const piece = pieces.get(x + y);
    if (piece) {
      let p = letters[piece.role];
      if (piece.color === "white")
        p = p.toUpperCase();
      if (piece.promoted)
        p += "~";
      return p;
    } else
      return "1";
  }).join("")).join("/").replace(/1{2,}/g, (s) => s.length.toString());
}

// node_modules/chessground/config.js
function applyAnimation(state, config) {
  if (config.animation) {
    deepMerge(state.animation, config.animation);
    if ((state.animation.duration || 0) < 70)
      state.animation.enabled = false;
  }
}
function configure(state, config) {
  var _a, _b, _c;
  if ((_a = config.movable) === null || _a === void 0 ? void 0 : _a.dests)
    state.movable.dests = void 0;
  if ((_b = config.drawable) === null || _b === void 0 ? void 0 : _b.autoShapes)
    state.drawable.autoShapes = [];
  deepMerge(state, config);
  if (config.fen) {
    state.pieces = read(config.fen);
    state.drawable.shapes = ((_c = config.drawable) === null || _c === void 0 ? void 0 : _c.shapes) || [];
  }
  if ("check" in config)
    setCheck(state, config.check || false);
  if ("lastMove" in config && !config.lastMove)
    state.lastMove = void 0;
  else if (config.lastMove)
    state.lastMove = config.lastMove;
  if (state.selected)
    setSelected(state, state.selected);
  applyAnimation(state, config);
  if (!state.movable.rookCastle && state.movable.dests) {
    const rank = state.movable.color === "white" ? "1" : "8", kingStartPos = "e" + rank, dests = state.movable.dests.get(kingStartPos), king2 = state.pieces.get(kingStartPos);
    if (!dests || !king2 || king2.role !== "king")
      return;
    state.movable.dests.set(kingStartPos, dests.filter((d) => !(d === "a" + rank && dests.includes("c" + rank)) && !(d === "h" + rank && dests.includes("g" + rank))));
  }
}
function deepMerge(base, extend) {
  for (const key in extend) {
    if (Object.prototype.hasOwnProperty.call(extend, key)) {
      if (Object.prototype.hasOwnProperty.call(base, key) && isPlainObject(base[key]) && isPlainObject(extend[key]))
        deepMerge(base[key], extend[key]);
      else
        base[key] = extend[key];
    }
  }
}
function isPlainObject(o) {
  if (typeof o !== "object" || o === null)
    return false;
  const proto = Object.getPrototypeOf(o);
  return proto === Object.prototype || proto === null;
}

// node_modules/chessground/anim.js
var anim = (mutation, state) => state.animation.enabled ? animate(mutation, state) : render(mutation, state);
function render(mutation, state) {
  const result = mutation(state);
  state.dom.redraw();
  return result;
}
var makePiece = (key, piece) => ({
  key,
  pos: key2pos(key),
  piece
});
var closer = (piece, pieces) => pieces.sort((p1, p2) => distanceSq(piece.pos, p1.pos) - distanceSq(piece.pos, p2.pos))[0];
function computePlan(prevPieces, current) {
  const anims = /* @__PURE__ */ new Map(), animedOrigs = [], fadings = /* @__PURE__ */ new Map(), missings = [], news = [], prePieces = /* @__PURE__ */ new Map();
  let curP, preP, vector;
  for (const [k, p] of prevPieces) {
    prePieces.set(k, makePiece(k, p));
  }
  for (const key of allKeys) {
    curP = current.pieces.get(key);
    preP = prePieces.get(key);
    if (curP) {
      if (preP) {
        if (!samePiece(curP, preP.piece)) {
          missings.push(preP);
          news.push(makePiece(key, curP));
        }
      } else
        news.push(makePiece(key, curP));
    } else if (preP)
      missings.push(preP);
  }
  for (const newP of news) {
    preP = closer(newP, missings.filter((p) => samePiece(newP.piece, p.piece)));
    if (preP) {
      vector = [preP.pos[0] - newP.pos[0], preP.pos[1] - newP.pos[1]];
      anims.set(newP.key, vector.concat(vector));
      animedOrigs.push(preP.key);
    }
  }
  for (const p of missings) {
    if (!animedOrigs.includes(p.key))
      fadings.set(p.key, p.piece);
  }
  return {
    anims,
    fadings
  };
}
function step(state, now) {
  const cur = state.animation.current;
  if (cur === void 0) {
    if (!state.dom.destroyed)
      state.dom.redrawNow();
    return;
  }
  const rest = 1 - (now - cur.start) * cur.frequency;
  if (rest <= 0) {
    state.animation.current = void 0;
    state.dom.redrawNow();
  } else {
    const ease = easing(rest);
    for (const cfg of cur.plan.anims.values()) {
      cfg[2] = cfg[0] * ease;
      cfg[3] = cfg[1] * ease;
    }
    state.dom.redrawNow(true);
    requestAnimationFrame((now2 = performance.now()) => step(state, now2));
  }
}
function animate(mutation, state) {
  const prevPieces = new Map(state.pieces);
  const result = mutation(state);
  const plan = computePlan(prevPieces, state);
  if (plan.anims.size || plan.fadings.size) {
    const alreadyRunning = state.animation.current && state.animation.current.start;
    state.animation.current = {
      start: performance.now(),
      frequency: 1 / state.animation.duration,
      plan
    };
    if (!alreadyRunning)
      step(state, performance.now());
  } else {
    state.dom.redraw();
  }
  return result;
}
var easing = (t) => t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;

// node_modules/chessground/draw.js
var brushes = ["green", "red", "blue", "yellow"];
function start(state, e) {
  if (e.touches && e.touches.length > 1)
    return;
  e.stopPropagation();
  e.preventDefault();
  e.ctrlKey ? unselect(state) : cancelMove(state);
  const pos = eventPosition(e), orig = getKeyAtDomPos(pos, whitePov(state), state.dom.bounds());
  if (!orig)
    return;
  state.drawable.current = {
    orig,
    pos,
    brush: eventBrush(e),
    snapToValidMove: state.drawable.defaultSnapToValidMove
  };
  processDraw(state);
}
function processDraw(state) {
  requestAnimationFrame(() => {
    const cur = state.drawable.current;
    if (cur) {
      const keyAtDomPos = getKeyAtDomPos(cur.pos, whitePov(state), state.dom.bounds());
      if (!keyAtDomPos) {
        cur.snapToValidMove = false;
      }
      const mouseSq = cur.snapToValidMove ? getSnappedKeyAtDomPos(cur.orig, cur.pos, whitePov(state), state.dom.bounds()) : keyAtDomPos;
      if (mouseSq !== cur.mouseSq) {
        cur.mouseSq = mouseSq;
        cur.dest = mouseSq !== cur.orig ? mouseSq : void 0;
        state.dom.redrawNow();
      }
      processDraw(state);
    }
  });
}
function move(state, e) {
  if (state.drawable.current)
    state.drawable.current.pos = eventPosition(e);
}
function end(state) {
  const cur = state.drawable.current;
  if (cur) {
    if (cur.mouseSq)
      addShape(state.drawable, cur);
    cancel(state);
  }
}
function cancel(state) {
  if (state.drawable.current) {
    state.drawable.current = void 0;
    state.dom.redraw();
  }
}
function clear(state) {
  if (state.drawable.shapes.length) {
    state.drawable.shapes = [];
    state.dom.redraw();
    onChange(state.drawable);
  }
}
function eventBrush(e) {
  var _a;
  const modA = (e.shiftKey || e.ctrlKey) && isRightButton(e);
  const modB = e.altKey || e.metaKey || ((_a = e.getModifierState) === null || _a === void 0 ? void 0 : _a.call(e, "AltGraph"));
  return brushes[(modA ? 1 : 0) + (modB ? 2 : 0)];
}
function addShape(drawable, cur) {
  const sameShape = (s) => s.orig === cur.orig && s.dest === cur.dest;
  const similar = drawable.shapes.find(sameShape);
  if (similar)
    drawable.shapes = drawable.shapes.filter((s) => !sameShape(s));
  if (!similar || similar.brush !== cur.brush)
    drawable.shapes.push({
      orig: cur.orig,
      dest: cur.dest,
      brush: cur.brush
    });
  onChange(drawable);
}
function onChange(drawable) {
  if (drawable.onChange)
    drawable.onChange(drawable.shapes);
}

// node_modules/chessground/drag.js
function start2(s, e) {
  if (!(s.trustAllEvents || e.isTrusted))
    return;
  if (e.button !== void 0 && e.button !== 0)
    return;
  if (e.touches && e.touches.length > 1)
    return;
  const bounds = s.dom.bounds(), position = eventPosition(e), orig = getKeyAtDomPos(position, whitePov(s), bounds);
  if (!orig)
    return;
  const piece = s.pieces.get(orig);
  const previouslySelected = s.selected;
  if (!previouslySelected && s.drawable.enabled && (s.drawable.eraseOnClick || !piece || piece.color !== s.turnColor))
    clear(s);
  if (e.cancelable !== false && (!e.touches || s.blockTouchScroll || piece || previouslySelected || pieceCloseTo(s, position)))
    e.preventDefault();
  else if (e.touches)
    return;
  const hadPremove = !!s.premovable.current;
  const hadPredrop = !!s.predroppable.current;
  s.stats.ctrlKey = e.ctrlKey;
  if (s.selected && canMove(s, s.selected, orig)) {
    anim((state) => selectSquare(state, orig), s);
  } else {
    selectSquare(s, orig);
  }
  const stillSelected = s.selected === orig;
  const element = pieceElementByKey(s, orig);
  if (piece && element && stillSelected && isDraggable(s, orig)) {
    s.draggable.current = {
      orig,
      piece,
      origPos: position,
      pos: position,
      started: s.draggable.autoDistance && s.stats.dragged,
      element,
      previouslySelected,
      originTarget: e.target,
      keyHasChanged: false
    };
    element.cgDragging = true;
    element.classList.add("dragging");
    const ghost = s.dom.elements.ghost;
    if (ghost) {
      ghost.className = `ghost ${piece.color} ${piece.role}`;
      translate(ghost, posToTranslate(bounds)(key2pos(orig), whitePov(s)));
      setVisible(ghost, true);
    }
    processDrag(s);
  } else {
    if (hadPremove)
      unsetPremove(s);
    if (hadPredrop)
      unsetPredrop(s);
  }
  s.dom.redraw();
}
function pieceCloseTo(s, pos) {
  const asWhite = whitePov(s), bounds = s.dom.bounds(), radiusSq = Math.pow(bounds.width / 8, 2);
  for (const key of s.pieces.keys()) {
    const center = computeSquareCenter(key, asWhite, bounds);
    if (distanceSq(center, pos) <= radiusSq)
      return true;
  }
  return false;
}
function dragNewPiece(s, piece, e, force) {
  const key = "a0";
  s.pieces.set(key, piece);
  s.dom.redraw();
  const position = eventPosition(e);
  s.draggable.current = {
    orig: key,
    piece,
    origPos: position,
    pos: position,
    started: true,
    element: () => pieceElementByKey(s, key),
    originTarget: e.target,
    newPiece: true,
    force: !!force,
    keyHasChanged: false
  };
  processDrag(s);
}
function processDrag(s) {
  requestAnimationFrame(() => {
    var _a;
    const cur = s.draggable.current;
    if (!cur)
      return;
    if ((_a = s.animation.current) === null || _a === void 0 ? void 0 : _a.plan.anims.has(cur.orig))
      s.animation.current = void 0;
    const origPiece = s.pieces.get(cur.orig);
    if (!origPiece || !samePiece(origPiece, cur.piece))
      cancel2(s);
    else {
      if (!cur.started && distanceSq(cur.pos, cur.origPos) >= Math.pow(s.draggable.distance, 2))
        cur.started = true;
      if (cur.started) {
        if (typeof cur.element === "function") {
          const found = cur.element();
          if (!found)
            return;
          found.cgDragging = true;
          found.classList.add("dragging");
          cur.element = found;
        }
        const bounds = s.dom.bounds();
        translate(cur.element, [
          cur.pos[0] - bounds.left - bounds.width / 16,
          cur.pos[1] - bounds.top - bounds.height / 16
        ]);
        cur.keyHasChanged || (cur.keyHasChanged = cur.orig !== getKeyAtDomPos(cur.pos, whitePov(s), bounds));
      }
    }
    processDrag(s);
  });
}
function move2(s, e) {
  if (s.draggable.current && (!e.touches || e.touches.length < 2)) {
    s.draggable.current.pos = eventPosition(e);
  }
}
function end2(s, e) {
  const cur = s.draggable.current;
  if (!cur)
    return;
  if (e.type === "touchend" && e.cancelable !== false)
    e.preventDefault();
  if (e.type === "touchend" && cur.originTarget !== e.target && !cur.newPiece) {
    s.draggable.current = void 0;
    return;
  }
  unsetPremove(s);
  unsetPredrop(s);
  const eventPos = eventPosition(e) || cur.pos;
  const dest = getKeyAtDomPos(eventPos, whitePov(s), s.dom.bounds());
  if (dest && cur.started && cur.orig !== dest) {
    if (cur.newPiece)
      dropNewPiece(s, cur.orig, dest, cur.force);
    else {
      s.stats.ctrlKey = e.ctrlKey;
      if (userMove(s, cur.orig, dest))
        s.stats.dragged = true;
    }
  } else if (cur.newPiece) {
    s.pieces.delete(cur.orig);
  } else if (s.draggable.deleteOnDropOff && !dest) {
    s.pieces.delete(cur.orig);
    callUserFunction(s.events.change);
  }
  if ((cur.orig === cur.previouslySelected || cur.keyHasChanged) && (cur.orig === dest || !dest))
    unselect(s);
  else if (!s.selectable.enabled)
    unselect(s);
  removeDragElements(s);
  s.draggable.current = void 0;
  s.dom.redraw();
}
function cancel2(s) {
  const cur = s.draggable.current;
  if (cur) {
    if (cur.newPiece)
      s.pieces.delete(cur.orig);
    s.draggable.current = void 0;
    unselect(s);
    removeDragElements(s);
    s.dom.redraw();
  }
}
function removeDragElements(s) {
  const e = s.dom.elements;
  if (e.ghost)
    setVisible(e.ghost, false);
}
function pieceElementByKey(s, key) {
  let el = s.dom.elements.board.firstChild;
  while (el) {
    if (el.cgKey === key && el.tagName === "PIECE")
      return el;
    el = el.nextSibling;
  }
  return;
}

// node_modules/chessground/explosion.js
function explosion(state, keys) {
  state.exploding = { stage: 1, keys };
  state.dom.redraw();
  setTimeout(() => {
    setStage(state, 2);
    setTimeout(() => setStage(state, void 0), 120);
  }, 120);
}
function setStage(state, stage) {
  if (state.exploding) {
    if (stage)
      state.exploding.stage = stage;
    else
      state.exploding = void 0;
    state.dom.redraw();
  }
}

// node_modules/chessground/api.js
function start3(state, redrawAll) {
  function toggleOrientation2() {
    toggleOrientation(state);
    redrawAll();
  }
  return {
    set(config) {
      if (config.orientation && config.orientation !== state.orientation)
        toggleOrientation2();
      applyAnimation(state, config);
      (config.fen ? anim : render)((state2) => configure(state2, config), state);
    },
    state,
    getFen: () => write(state.pieces),
    toggleOrientation: toggleOrientation2,
    setPieces(pieces) {
      anim((state2) => setPieces(state2, pieces), state);
    },
    selectSquare(key, force) {
      if (key)
        anim((state2) => selectSquare(state2, key, force), state);
      else if (state.selected) {
        unselect(state);
        state.dom.redraw();
      }
    },
    move(orig, dest) {
      anim((state2) => baseMove(state2, orig, dest), state);
    },
    newPiece(piece, key) {
      anim((state2) => baseNewPiece(state2, piece, key), state);
    },
    playPremove() {
      if (state.premovable.current) {
        if (anim(playPremove, state))
          return true;
        state.dom.redraw();
      }
      return false;
    },
    playPredrop(validate) {
      if (state.predroppable.current) {
        const result = playPredrop(state, validate);
        state.dom.redraw();
        return result;
      }
      return false;
    },
    cancelPremove() {
      render(unsetPremove, state);
    },
    cancelPredrop() {
      render(unsetPredrop, state);
    },
    cancelMove() {
      render((state2) => {
        cancelMove(state2);
        cancel2(state2);
      }, state);
    },
    stop() {
      render((state2) => {
        stop(state2);
        cancel2(state2);
      }, state);
    },
    explode(keys) {
      explosion(state, keys);
    },
    setAutoShapes(shapes) {
      render((state2) => state2.drawable.autoShapes = shapes, state);
    },
    setShapes(shapes) {
      render((state2) => state2.drawable.shapes = shapes, state);
    },
    getKeyAtDomPos(pos) {
      return getKeyAtDomPos(pos, whitePov(state), state.dom.bounds());
    },
    redrawAll,
    dragNewPiece(piece, event2, force) {
      dragNewPiece(state, piece, event2, force);
    },
    destroy() {
      stop(state);
      state.dom.unbind && state.dom.unbind();
      state.dom.destroyed = true;
    }
  };
}

// node_modules/chessground/state.js
function defaults() {
  return {
    pieces: read(initial),
    orientation: "white",
    turnColor: "white",
    coordinates: true,
    ranksPosition: "right",
    autoCastle: true,
    viewOnly: false,
    disableContextMenu: false,
    addPieceZIndex: false,
    blockTouchScroll: false,
    pieceKey: false,
    trustAllEvents: false,
    highlight: {
      lastMove: true,
      check: true
    },
    animation: {
      enabled: true,
      duration: 200
    },
    movable: {
      free: true,
      color: "both",
      showDests: true,
      events: {},
      rookCastle: true
    },
    premovable: {
      enabled: true,
      showDests: true,
      castle: true,
      events: {}
    },
    predroppable: {
      enabled: false,
      events: {}
    },
    draggable: {
      enabled: true,
      distance: 3,
      autoDistance: true,
      showGhost: true,
      deleteOnDropOff: false
    },
    dropmode: {
      active: false
    },
    selectable: {
      enabled: true
    },
    stats: {
      // on touchscreen, default to "tap-tap" moves
      // instead of drag
      dragged: !("ontouchstart" in window)
    },
    events: {},
    drawable: {
      enabled: true,
      visible: true,
      defaultSnapToValidMove: true,
      eraseOnClick: true,
      shapes: [],
      autoShapes: [],
      brushes: {
        green: { key: "g", color: "#15781B", opacity: 1, lineWidth: 10 },
        red: { key: "r", color: "#882020", opacity: 1, lineWidth: 10 },
        blue: { key: "b", color: "#003088", opacity: 1, lineWidth: 10 },
        yellow: { key: "y", color: "#e68f00", opacity: 1, lineWidth: 10 },
        paleBlue: { key: "pb", color: "#003088", opacity: 0.4, lineWidth: 15 },
        paleGreen: { key: "pg", color: "#15781B", opacity: 0.4, lineWidth: 15 },
        paleRed: { key: "pr", color: "#882020", opacity: 0.4, lineWidth: 15 },
        paleGrey: {
          key: "pgr",
          color: "#4a4a4a",
          opacity: 0.35,
          lineWidth: 15
        },
        purple: { key: "purp", color: "#68217a", opacity: 0.65, lineWidth: 10 },
        pink: { key: "pink", color: "#ee2080", opacity: 0.5, lineWidth: 10 },
        hilite: { key: "hilite", color: "#fff", opacity: 1, lineWidth: 1 }
      },
      prevSvgHash: ""
    },
    hold: timer()
  };
}

// node_modules/chessground/svg.js
function createDefs() {
  const defs = createElement("defs");
  const filter = setAttributes(createElement("filter"), { id: "cg-filter-blur" });
  filter.appendChild(setAttributes(createElement("feGaussianBlur"), { stdDeviation: "0.022" }));
  defs.appendChild(filter);
  return defs;
}
function renderSvg(state, shapesEl, customsEl) {
  var _a;
  const d = state.drawable, curD = d.current, cur = curD && curD.mouseSq ? curD : void 0, dests = /* @__PURE__ */ new Map(), bounds = state.dom.bounds(), nonPieceAutoShapes = d.autoShapes.filter((autoShape) => !autoShape.piece);
  for (const s of d.shapes.concat(nonPieceAutoShapes).concat(cur ? [cur] : [])) {
    if (!s.dest)
      continue;
    const sources = (_a = dests.get(s.dest)) !== null && _a !== void 0 ? _a : /* @__PURE__ */ new Set(), from = pos2user(orient(key2pos(s.orig), state.orientation), bounds), to = pos2user(orient(key2pos(s.dest), state.orientation), bounds);
    sources.add(moveAngle(from, to));
    dests.set(s.dest, sources);
  }
  const shapes = d.shapes.concat(nonPieceAutoShapes).map((s) => {
    return {
      shape: s,
      current: false,
      hash: shapeHash(s, isShort(s.dest, dests), false, bounds)
    };
  });
  if (cur)
    shapes.push({
      shape: cur,
      current: true,
      hash: shapeHash(cur, isShort(cur.dest, dests), true, bounds)
    });
  const fullHash = shapes.map((sc) => sc.hash).join(";");
  if (fullHash === state.drawable.prevSvgHash)
    return;
  state.drawable.prevSvgHash = fullHash;
  const defsEl = shapesEl.querySelector("defs");
  syncDefs(d, shapes, defsEl);
  syncShapes(shapes, shapesEl.querySelector("g"), customsEl.querySelector("g"), (s) => renderShape(state, s, d.brushes, dests, bounds));
}
function syncDefs(d, shapes, defsEl) {
  var _a;
  const brushes2 = /* @__PURE__ */ new Map();
  let brush;
  for (const s of shapes) {
    if (s.shape.dest) {
      brush = makeCustomBrush(d.brushes[s.shape.brush], s.shape.modifiers);
      if ((_a = s.shape.modifiers) === null || _a === void 0 ? void 0 : _a.hilite)
        brushes2.set("hilite", d.brushes["hilite"]);
      brushes2.set(brush.key, brush);
    }
  }
  const keysInDom = /* @__PURE__ */ new Set();
  let el = defsEl.firstElementChild;
  while (el) {
    keysInDom.add(el.getAttribute("cgKey"));
    el = el.nextElementSibling;
  }
  for (const [key, brush2] of brushes2.entries()) {
    if (!keysInDom.has(key))
      defsEl.appendChild(renderMarker(brush2));
  }
}
function syncShapes(syncables, shapes, customs, renderShape3) {
  const hashesInDom = /* @__PURE__ */ new Map();
  for (const sc of syncables)
    hashesInDom.set(sc.hash, false);
  for (const root5 of [shapes, customs]) {
    const toRemove = [];
    let el = root5.firstElementChild, elHash;
    while (el) {
      elHash = el.getAttribute("cgHash");
      if (hashesInDom.has(elHash))
        hashesInDom.set(elHash, true);
      else
        toRemove.push(el);
      el = el.nextElementSibling;
    }
    for (const el2 of toRemove)
      root5.removeChild(el2);
  }
  for (const sc of syncables.filter((s) => !hashesInDom.get(s.hash))) {
    for (const svg of renderShape3(sc)) {
      if (svg.isCustom)
        customs.appendChild(svg.el);
      else
        shapes.appendChild(svg.el);
    }
  }
}
function shapeHash({ orig, dest, brush, piece, modifiers, customSvg, label }, shorten, current, bounds) {
  return [
    bounds.width,
    bounds.height,
    current,
    orig,
    dest,
    brush,
    shorten && "-",
    piece && pieceHash(piece),
    modifiers && modifiersHash(modifiers),
    customSvg && `custom-${textHash(customSvg)}`,
    label && `label-${textHash(label.text)}`
  ].filter((x) => x).join(",");
}
function pieceHash(piece) {
  return [piece.color, piece.role, piece.scale].filter((x) => x).join(",");
}
function modifiersHash(m) {
  var _a;
  return [m.lineWidth, m.hilite && "*", (_a = m.overlayCustomSvg) === null || _a === void 0 ? void 0 : _a[0]].filter((x) => x).join(",");
}
function textHash(s) {
  let h = 0;
  for (let i = 0; i < s.length; i++) {
    h = (h << 5) - h + s.charCodeAt(i) >>> 0;
  }
  return h.toString();
}
function renderShape(state, { shape, current, hash: hash2 }, brushes2, dests, bounds) {
  var _a, _b, _c;
  const from = pos2user(orient(key2pos(shape.orig), state.orientation), bounds), to = shape.dest ? pos2user(orient(key2pos(shape.dest), state.orientation), bounds) : from, brush = makeCustomBrush(brushes2[shape.brush], shape.modifiers), slots = dests.get(shape.dest), svgs = [];
  if (!shape.customSvg || ((_a = shape.modifiers) === null || _a === void 0 ? void 0 : _a.overlayCustomSvg)) {
    const el = setAttributes(createElement("g"), { cgHash: hash2 });
    svgs.push({ el });
    if (from[0] !== to[0] || from[1] !== to[1])
      el.appendChild(renderArrow(shape, brush, from, to, current, isShort(shape.dest, dests)));
    else
      el.appendChild(renderCircle(brushes2[shape.brush], from, current, bounds));
    if (shape.label)
      svgs.push({ el: renderLabel(shape.label.text, brush.color, hash2, from, to, slots), isCustom: true });
  }
  if (shape.customSvg) {
    const on = (_c = (_b = shape.modifiers) === null || _b === void 0 ? void 0 : _b.overlayCustomSvg) !== null && _c !== void 0 ? _c : "orig";
    const [x, y] = on === "label" ? labelCoords(from, to, slots) : on === "dest" ? to : from;
    const el = setAttributes(createElement("g"), { transform: `translate(${x},${y})`, cgHash: hash2 });
    el.innerHTML = `<svg width="1" height="1" viewBox="0 0 100 100">${shape.customSvg}</svg>`;
    svgs.push({ el, isCustom: true });
  }
  return svgs;
}
function renderCircle(brush, at, current, bounds) {
  const widths = circleWidth(), radius = (bounds.width + bounds.height) / (4 * Math.max(bounds.width, bounds.height));
  return setAttributes(createElement("circle"), {
    stroke: brush.color,
    "stroke-width": widths[current ? 0 : 1],
    fill: "none",
    opacity: opacity(brush, current),
    cx: at[0],
    cy: at[1],
    r: radius - widths[1] / 2
  });
}
function renderArrow(s, brush, from, to, current, shorten) {
  var _a;
  function renderLine(isHilite) {
    var _a2;
    const m = arrowMargin(shorten && !current), dx = to[0] - from[0], dy = to[1] - from[1], angle = Math.atan2(dy, dx), xo = Math.cos(angle) * m, yo = Math.sin(angle) * m;
    return setAttributes(createElement("line"), {
      stroke: isHilite ? "white" : brush.color,
      "stroke-width": lineWidth(brush, current) + (isHilite ? 0.04 : 0),
      "stroke-linecap": "round",
      "marker-end": `url(#arrowhead-${isHilite ? "hilite" : brush.key})`,
      opacity: ((_a2 = s.modifiers) === null || _a2 === void 0 ? void 0 : _a2.hilite) ? 1 : opacity(brush, current),
      x1: from[0],
      y1: from[1],
      x2: to[0] - xo,
      y2: to[1] - yo
    });
  }
  if (!((_a = s.modifiers) === null || _a === void 0 ? void 0 : _a.hilite))
    return renderLine(false);
  const g = createElement("g");
  const blurred = setAttributes(createElement("g"), { filter: "url(#cg-filter-blur)" });
  blurred.appendChild(filterBox(from, to));
  blurred.appendChild(renderLine(true));
  g.appendChild(blurred);
  g.appendChild(renderLine(false));
  return g;
}
function renderMarker(brush) {
  const marker = setAttributes(createElement("marker"), {
    id: "arrowhead-" + brush.key,
    orient: "auto",
    overflow: "visible",
    markerWidth: 4,
    markerHeight: 4,
    refX: brush.key === "hilite" ? 1.86 : 2.05,
    refY: 2
  });
  marker.appendChild(setAttributes(createElement("path"), {
    d: "M0,0 V4 L3,2 Z",
    fill: brush.color
  }));
  marker.setAttribute("cgKey", brush.key);
  return marker;
}
function renderLabel(text, color, hash2, from, to, slots) {
  const labelSize = 0.4;
  const fontSize = labelSize * 0.8 ** text.length;
  const [x, y] = labelCoords(from, to, slots);
  const g = setAttributes(createElement("g"), {
    transform: `translate(${x + 0.5},${y + 0.5})`,
    cgHash: hash2
  });
  g.appendChild(setAttributes(createElement("circle"), {
    r: labelSize / 2,
    "fill-opacity": 0.8,
    "stroke-opacity": 0.7,
    "stroke-width": 0.03,
    fill: color,
    stroke: "white"
  }));
  const label = setAttributes(createElement("text"), {
    "font-size": fontSize,
    "font-family": "Noto Sans",
    "text-anchor": "middle",
    fill: "white",
    y: fontSize * 0.34,
    innerHTML: text
  });
  label.innerHTML = text;
  g.appendChild(label);
  return g;
}
function orient(pos, color) {
  return color === "white" ? pos : [7 - pos[0], 7 - pos[1]];
}
function isShort(dest, dests) {
  return true === (dest && dests.has(dest) && dests.get(dest).size > 1);
}
function createElement(tagName) {
  return document.createElementNS("http://www.w3.org/2000/svg", tagName);
}
function setAttributes(el, attrs) {
  for (const key in attrs) {
    if (Object.prototype.hasOwnProperty.call(attrs, key))
      el.setAttribute(key, attrs[key]);
  }
  return el;
}
function makeCustomBrush(base, modifiers) {
  return !modifiers ? base : {
    color: base.color,
    opacity: Math.round(base.opacity * 10) / 10,
    lineWidth: Math.round(modifiers.lineWidth || base.lineWidth),
    key: [base.key, modifiers.lineWidth].filter((x) => x).join("")
  };
}
function circleWidth() {
  return [3 / 64, 4 / 64];
}
function lineWidth(brush, current) {
  return (brush.lineWidth || 10) * (current ? 0.85 : 1) / 64;
}
function opacity(brush, current) {
  return (brush.opacity || 1) * (current ? 0.9 : 1);
}
function arrowMargin(shorten) {
  return (shorten ? 20 : 10) / 64;
}
function pos2user(pos, bounds) {
  const xScale = Math.min(1, bounds.width / bounds.height);
  const yScale = Math.min(1, bounds.height / bounds.width);
  return [(pos[0] - 3.5) * xScale, (3.5 - pos[1]) * yScale];
}
function filterBox(from, to) {
  const box = {
    from: [Math.floor(Math.min(from[0], to[0])), Math.floor(Math.min(from[1], to[1]))],
    to: [Math.ceil(Math.max(from[0], to[0])), Math.ceil(Math.max(from[1], to[1]))]
  };
  return setAttributes(createElement("rect"), {
    x: box.from[0],
    y: box.from[1],
    width: box.to[0] - box.from[0],
    height: box.to[1] - box.from[1],
    fill: "none",
    stroke: "none"
  });
}
function moveAngle(from, to, asSlot = true) {
  const angle = Math.atan2(to[1] - from[1], to[0] - from[0]) + Math.PI;
  return asSlot ? (Math.round(angle * 8 / Math.PI) + 16) % 16 : angle;
}
function dist(from, to) {
  return Math.sqrt([from[0] - to[0], from[1] - to[1]].reduce((acc, x) => acc + x * x, 0));
}
function labelCoords(from, to, slots) {
  let mag = dist(from, to);
  if (mag === 0)
    return [0.5 + from[0], 0.5 + from[1]];
  const angle = moveAngle(from, to, false);
  if (slots) {
    mag -= 33 / 64;
    if (slots.size > 1) {
      mag -= 10 / 64;
      const slot = moveAngle(from, to);
      if (slots.has((slot + 1) % 16) || slots.has((slot + 15) % 16)) {
        if (slot & 1)
          mag -= 0.4;
      }
    }
  }
  return [from[0] - Math.cos(angle) * mag, from[1] - Math.sin(angle) * mag];
}

// node_modules/chessground/wrap.js
function renderWrap(element, s) {
  element.innerHTML = "";
  element.classList.add("cg-wrap");
  for (const c of colors)
    element.classList.toggle("orientation-" + c, s.orientation === c);
  element.classList.toggle("manipulable", !s.viewOnly);
  const container = createEl("cg-container");
  element.appendChild(container);
  const board = createEl("cg-board");
  container.appendChild(board);
  let svg;
  let customSvg;
  let autoPieces;
  if (s.drawable.visible) {
    svg = setAttributes(createElement("svg"), {
      class: "cg-shapes",
      viewBox: "-4 -4 8 8",
      preserveAspectRatio: "xMidYMid slice"
    });
    svg.appendChild(createDefs());
    svg.appendChild(createElement("g"));
    customSvg = setAttributes(createElement("svg"), {
      class: "cg-custom-svgs",
      viewBox: "-3.5 -3.5 8 8",
      preserveAspectRatio: "xMidYMid slice"
    });
    customSvg.appendChild(createElement("g"));
    autoPieces = createEl("cg-auto-pieces");
    container.appendChild(svg);
    container.appendChild(customSvg);
    container.appendChild(autoPieces);
  }
  if (s.coordinates) {
    const orientClass = s.orientation === "black" ? " black" : "";
    const ranksPositionClass = s.ranksPosition === "left" ? " left" : "";
    container.appendChild(renderCoords(ranks, "ranks" + orientClass + ranksPositionClass));
    container.appendChild(renderCoords(files, "files" + orientClass));
  }
  let ghost;
  if (s.draggable.enabled && s.draggable.showGhost) {
    ghost = createEl("piece", "ghost");
    setVisible(ghost, false);
    container.appendChild(ghost);
  }
  return {
    board,
    container,
    wrap: element,
    ghost,
    svg,
    customSvg,
    autoPieces
  };
}
function renderCoords(elems, className) {
  const el = createEl("coords", className);
  let f;
  for (const elem of elems) {
    f = createEl("coord");
    f.textContent = elem;
    el.appendChild(f);
  }
  return el;
}

// node_modules/chessground/drop.js
function drop(s, e) {
  if (!s.dropmode.active)
    return;
  unsetPremove(s);
  unsetPredrop(s);
  const piece = s.dropmode.piece;
  if (piece) {
    s.pieces.set("a0", piece);
    const position = eventPosition(e);
    const dest = position && getKeyAtDomPos(position, whitePov(s), s.dom.bounds());
    if (dest)
      dropNewPiece(s, "a0", dest);
  }
  s.dom.redraw();
}

// node_modules/chessground/events.js
function bindBoard(s, onResize) {
  const boardEl = s.dom.elements.board;
  if ("ResizeObserver" in window)
    new ResizeObserver(onResize).observe(s.dom.elements.wrap);
  if (s.disableContextMenu || s.drawable.enabled) {
    boardEl.addEventListener("contextmenu", (e) => e.preventDefault());
  }
  if (s.viewOnly)
    return;
  const onStart = startDragOrDraw(s);
  boardEl.addEventListener("touchstart", onStart, {
    passive: false
  });
  boardEl.addEventListener("mousedown", onStart, {
    passive: false
  });
}
function bindDocument(s, onResize) {
  const unbinds = [];
  if (!("ResizeObserver" in window))
    unbinds.push(unbindable(document.body, "chessground.resize", onResize));
  if (!s.viewOnly) {
    const onmove = dragOrDraw(s, move2, move);
    const onend = dragOrDraw(s, end2, end);
    for (const ev of ["touchmove", "mousemove"])
      unbinds.push(unbindable(document, ev, onmove));
    for (const ev of ["touchend", "mouseup"])
      unbinds.push(unbindable(document, ev, onend));
    const onScroll = () => s.dom.bounds.clear();
    unbinds.push(unbindable(document, "scroll", onScroll, { capture: true, passive: true }));
    unbinds.push(unbindable(window, "resize", onScroll, { passive: true }));
  }
  return () => unbinds.forEach((f) => f());
}
function unbindable(el, eventName, callback, options) {
  el.addEventListener(eventName, callback, options);
  return () => el.removeEventListener(eventName, callback, options);
}
var startDragOrDraw = (s) => (e) => {
  if (s.draggable.current)
    cancel2(s);
  else if (s.drawable.current)
    cancel(s);
  else if (e.shiftKey || isRightButton(e)) {
    if (s.drawable.enabled)
      start(s, e);
  } else if (!s.viewOnly) {
    if (s.dropmode.active)
      drop(s, e);
    else
      start2(s, e);
  }
};
var dragOrDraw = (s, withDrag, withDraw) => (e) => {
  if (s.drawable.current) {
    if (s.drawable.enabled)
      withDraw(s, e);
  } else if (!s.viewOnly)
    withDrag(s, e);
};

// node_modules/chessground/render.js
function render2(s) {
  const asWhite = whitePov(s), posToTranslate2 = posToTranslate(s.dom.bounds()), boardEl = s.dom.elements.board, pieces = s.pieces, curAnim = s.animation.current, anims = curAnim ? curAnim.plan.anims : /* @__PURE__ */ new Map(), fadings = curAnim ? curAnim.plan.fadings : /* @__PURE__ */ new Map(), curDrag = s.draggable.current, squares = computeSquareClasses(s), samePieces = /* @__PURE__ */ new Set(), sameSquares = /* @__PURE__ */ new Set(), movedPieces = /* @__PURE__ */ new Map(), movedSquares = /* @__PURE__ */ new Map();
  let k, el, pieceAtKey, elPieceName, anim2, fading, pMvdset, pMvd, sMvdset, sMvd;
  el = boardEl.firstChild;
  while (el) {
    k = el.cgKey;
    if (isPieceNode(el)) {
      pieceAtKey = pieces.get(k);
      anim2 = anims.get(k);
      fading = fadings.get(k);
      elPieceName = el.cgPiece;
      if (el.cgDragging && (!curDrag || curDrag.orig !== k)) {
        el.classList.remove("dragging");
        translate(el, posToTranslate2(key2pos(k), asWhite));
        el.cgDragging = false;
      }
      if (!fading && el.cgFading) {
        el.cgFading = false;
        el.classList.remove("fading");
      }
      if (pieceAtKey) {
        if (anim2 && el.cgAnimating && elPieceName === pieceNameOf(pieceAtKey)) {
          const pos = key2pos(k);
          pos[0] += anim2[2];
          pos[1] += anim2[3];
          el.classList.add("anim");
          translate(el, posToTranslate2(pos, asWhite));
        } else if (el.cgAnimating) {
          el.cgAnimating = false;
          el.classList.remove("anim");
          translate(el, posToTranslate2(key2pos(k), asWhite));
          if (s.addPieceZIndex)
            el.style.zIndex = posZIndex(key2pos(k), asWhite);
        }
        if (elPieceName === pieceNameOf(pieceAtKey) && (!fading || !el.cgFading)) {
          samePieces.add(k);
        } else {
          if (fading && elPieceName === pieceNameOf(fading)) {
            el.classList.add("fading");
            el.cgFading = true;
          } else {
            appendValue(movedPieces, elPieceName, el);
          }
        }
      } else {
        appendValue(movedPieces, elPieceName, el);
      }
    } else if (isSquareNode(el)) {
      const cn = el.className;
      if (squares.get(k) === cn)
        sameSquares.add(k);
      else
        appendValue(movedSquares, cn, el);
    }
    el = el.nextSibling;
  }
  for (const [sk, className] of squares) {
    if (!sameSquares.has(sk)) {
      sMvdset = movedSquares.get(className);
      sMvd = sMvdset && sMvdset.pop();
      const translation = posToTranslate2(key2pos(sk), asWhite);
      if (sMvd) {
        sMvd.cgKey = sk;
        translate(sMvd, translation);
      } else {
        const squareNode = createEl("square", className);
        squareNode.cgKey = sk;
        translate(squareNode, translation);
        boardEl.insertBefore(squareNode, boardEl.firstChild);
      }
    }
  }
  for (const [k2, p] of pieces) {
    anim2 = anims.get(k2);
    if (!samePieces.has(k2)) {
      pMvdset = movedPieces.get(pieceNameOf(p));
      pMvd = pMvdset && pMvdset.pop();
      if (pMvd) {
        pMvd.cgKey = k2;
        if (pMvd.cgFading) {
          pMvd.classList.remove("fading");
          pMvd.cgFading = false;
        }
        const pos = key2pos(k2);
        if (s.addPieceZIndex)
          pMvd.style.zIndex = posZIndex(pos, asWhite);
        if (anim2) {
          pMvd.cgAnimating = true;
          pMvd.classList.add("anim");
          pos[0] += anim2[2];
          pos[1] += anim2[3];
        }
        translate(pMvd, posToTranslate2(pos, asWhite));
      } else {
        const pieceName = pieceNameOf(p), pieceNode = createEl("piece", pieceName), pos = key2pos(k2);
        pieceNode.cgPiece = pieceName;
        pieceNode.cgKey = k2;
        if (anim2) {
          pieceNode.cgAnimating = true;
          pos[0] += anim2[2];
          pos[1] += anim2[3];
        }
        translate(pieceNode, posToTranslate2(pos, asWhite));
        if (s.addPieceZIndex)
          pieceNode.style.zIndex = posZIndex(pos, asWhite);
        boardEl.appendChild(pieceNode);
      }
    }
  }
  for (const nodes of movedPieces.values())
    removeNodes(s, nodes);
  for (const nodes of movedSquares.values())
    removeNodes(s, nodes);
}
function renderResized(s) {
  const asWhite = whitePov(s), posToTranslate2 = posToTranslate(s.dom.bounds());
  let el = s.dom.elements.board.firstChild;
  while (el) {
    if (isPieceNode(el) && !el.cgAnimating || isSquareNode(el)) {
      translate(el, posToTranslate2(key2pos(el.cgKey), asWhite));
    }
    el = el.nextSibling;
  }
}
function updateBounds(s) {
  var _a, _b;
  const bounds = s.dom.elements.wrap.getBoundingClientRect();
  const container = s.dom.elements.container;
  const ratio = bounds.height / bounds.width;
  const width = Math.floor(bounds.width * window.devicePixelRatio / 8) * 8 / window.devicePixelRatio;
  const height = width * ratio;
  container.style.width = width + "px";
  container.style.height = height + "px";
  s.dom.bounds.clear();
  (_a = s.addDimensionsCssVarsTo) === null || _a === void 0 ? void 0 : _a.style.setProperty("--cg-width", width + "px");
  (_b = s.addDimensionsCssVarsTo) === null || _b === void 0 ? void 0 : _b.style.setProperty("--cg-height", height + "px");
}
var isPieceNode = (el) => el.tagName === "PIECE";
var isSquareNode = (el) => el.tagName === "SQUARE";
function removeNodes(s, nodes) {
  for (const node of nodes)
    s.dom.elements.board.removeChild(node);
}
function posZIndex(pos, asWhite) {
  const minZ = 3;
  const rank = pos[1];
  const z = asWhite ? minZ + 7 - rank : minZ + rank;
  return `${z}`;
}
var pieceNameOf = (piece) => `${piece.color} ${piece.role}`;
function computeSquareClasses(s) {
  var _a, _b, _c;
  const squares = /* @__PURE__ */ new Map();
  if (s.lastMove && s.highlight.lastMove)
    for (const k of s.lastMove) {
      addSquare(squares, k, "last-move");
    }
  if (s.check && s.highlight.check)
    addSquare(squares, s.check, "check");
  if (s.selected) {
    addSquare(squares, s.selected, "selected");
    if (s.movable.showDests) {
      const dests = (_a = s.movable.dests) === null || _a === void 0 ? void 0 : _a.get(s.selected);
      if (dests)
        for (const k of dests) {
          addSquare(squares, k, "move-dest" + (s.pieces.has(k) ? " oc" : ""));
        }
      const pDests = (_c = (_b = s.premovable.customDests) === null || _b === void 0 ? void 0 : _b.get(s.selected)) !== null && _c !== void 0 ? _c : s.premovable.dests;
      if (pDests)
        for (const k of pDests) {
          addSquare(squares, k, "premove-dest" + (s.pieces.has(k) ? " oc" : ""));
        }
    }
  }
  const premove2 = s.premovable.current;
  if (premove2)
    for (const k of premove2)
      addSquare(squares, k, "current-premove");
  else if (s.predroppable.current)
    addSquare(squares, s.predroppable.current.key, "current-premove");
  const o = s.exploding;
  if (o)
    for (const k of o.keys)
      addSquare(squares, k, "exploding" + o.stage);
  if (s.highlight.custom) {
    s.highlight.custom.forEach((v, k) => {
      addSquare(squares, k, v);
    });
  }
  return squares;
}
function addSquare(squares, key, klass) {
  const classes = squares.get(key);
  if (classes)
    squares.set(key, `${classes} ${klass}`);
  else
    squares.set(key, klass);
}
function appendValue(map, key, value) {
  const arr = map.get(key);
  if (arr)
    arr.push(value);
  else
    map.set(key, [value]);
}

// node_modules/chessground/sync.js
function syncShapes2(shapes, root5, renderShape3) {
  const hashesInDom = /* @__PURE__ */ new Map(), toRemove = [];
  for (const sc of shapes)
    hashesInDom.set(sc.hash, false);
  let el = root5.firstElementChild, elHash;
  while (el) {
    elHash = el.getAttribute("cgHash");
    if (hashesInDom.has(elHash))
      hashesInDom.set(elHash, true);
    else
      toRemove.push(el);
    el = el.nextElementSibling;
  }
  for (const el2 of toRemove)
    root5.removeChild(el2);
  for (const sc of shapes) {
    if (!hashesInDom.get(sc.hash))
      root5.appendChild(renderShape3(sc));
  }
}

// node_modules/chessground/autoPieces.js
function render3(state, autoPieceEl) {
  const autoPieces = state.drawable.autoShapes.filter((autoShape) => autoShape.piece);
  const autoPieceShapes = autoPieces.map((s) => {
    return {
      shape: s,
      hash: hash(s),
      current: false
    };
  });
  syncShapes2(autoPieceShapes, autoPieceEl, (shape) => renderShape2(state, shape, state.dom.bounds()));
}
function renderResized2(state) {
  var _a;
  const asWhite = whitePov(state), posToTranslate2 = posToTranslate(state.dom.bounds());
  let el = (_a = state.dom.elements.autoPieces) === null || _a === void 0 ? void 0 : _a.firstChild;
  while (el) {
    translateAndScale(el, posToTranslate2(key2pos(el.cgKey), asWhite), el.cgScale);
    el = el.nextSibling;
  }
}
function renderShape2(state, { shape, hash: hash2 }, bounds) {
  var _a, _b, _c;
  const orig = shape.orig;
  const role = (_a = shape.piece) === null || _a === void 0 ? void 0 : _a.role;
  const color = (_b = shape.piece) === null || _b === void 0 ? void 0 : _b.color;
  const scale = (_c = shape.piece) === null || _c === void 0 ? void 0 : _c.scale;
  const pieceEl = createEl("piece", `${role} ${color}`);
  pieceEl.setAttribute("cgHash", hash2);
  pieceEl.cgKey = orig;
  pieceEl.cgScale = scale;
  translateAndScale(pieceEl, posToTranslate(bounds)(key2pos(orig), whitePov(state)), scale);
  return pieceEl;
}
var hash = (autoPiece) => {
  var _a, _b, _c;
  return [autoPiece.orig, (_a = autoPiece.piece) === null || _a === void 0 ? void 0 : _a.role, (_b = autoPiece.piece) === null || _b === void 0 ? void 0 : _b.color, (_c = autoPiece.piece) === null || _c === void 0 ? void 0 : _c.scale].join(",");
};

// node_modules/chessground/chessground.js
function Chessground(element, config) {
  const maybeState = defaults();
  configure(maybeState, config || {});
  function redrawAll() {
    const prevUnbind = "dom" in maybeState ? maybeState.dom.unbind : void 0;
    const elements = renderWrap(element, maybeState), bounds = memo(() => elements.board.getBoundingClientRect()), redrawNow = (skipSvg) => {
      render2(state);
      if (elements.autoPieces)
        render3(state, elements.autoPieces);
      if (!skipSvg && elements.svg)
        renderSvg(state, elements.svg, elements.customSvg);
    }, onResize = () => {
      updateBounds(state);
      renderResized(state);
      if (elements.autoPieces)
        renderResized2(state);
    };
    const state = maybeState;
    state.dom = {
      elements,
      bounds,
      redraw: debounceRedraw(redrawNow),
      redrawNow,
      unbind: prevUnbind
    };
    state.drawable.prevSvgHash = "";
    updateBounds(state);
    redrawNow(false);
    bindBoard(state, onResize);
    if (!prevUnbind)
      state.dom.unbind = bindDocument(state, onResize);
    state.events.insert && state.events.insert(elements);
    return state;
  }
  return start3(redrawAll(), redrawAll);
}
function debounceRedraw(redrawNow) {
  let redrawing = false;
  return () => {
    if (redrawing)
      return;
    redrawing = true;
    requestAnimationFrame(() => {
      redrawNow();
      redrawing = false;
    });
  };
}

// node_modules/svelte-chessground/dist/Chessground.svelte
Chessground_1[FILENAME] = "node_modules/svelte-chessground/dist/Chessground.svelte";
var root = add_locations(from_html(`<div></div>`), Chessground_1[FILENAME], [[354, 0]]);
var $$css = {
  hash: "s-SUgnUE_f2Lao",
  code: "\n\n .cg-wrap.s-SUgnUE_f2Lao {\n    width: 100%;\n    aspect-ratio: 1;\n  }\n\n  @supports not (aspect-ratio: 1) {\n    .cg-wrap.s-SUgnUE_f2Lao {\n      padding-top: 100%;\n    }\n  }\n\n  /*\n	 * Board styling.\n	 *\n	 * As there is no bundler-agnostic way of including CSS files (please\n	 * correct me if I'm wrong), the default Chessground styles are\n	 * included here.\n	 */\n\n	/*\n	 * chessground.base.css \n	 */\n\n\n	.cg-default-style.cg-wrap.s-SUgnUE_f2Lao {\n	  box-sizing: content-box;\n	  position: relative;\n	  display: block;\n	}\n\n	.cg-default-style.s-SUgnUE_f2Lao cg-container {\n	  position: absolute;\n	  width: 100%;\n	  height: 100%;\n	  display: block;\n	  top: 0;\n	}\n\n	.cg-default-style.s-SUgnUE_f2Lao cg-board {\n	  position: absolute;\n	  top: 0;\n	  left: 0;\n	  width: 100%;\n	  height: 100%;\n	  -webkit-user-select: none;\n	  -moz-user-select: none;\n	  -ms-user-select: none;\n	  user-select: none;\n	  line-height: 0;\n	  background-size: cover;\n	}\n\n	.cg-default-style.cg-wrap.manipulable.s-SUgnUE_f2Lao cg-board {\n	  cursor: pointer;\n	}\n\n	.cg-default-style.s-SUgnUE_f2Lao cg-board square {\n	  position: absolute;\n	  top: 0;\n	  left: 0;\n	  width: 12.5%;\n	  height: 12.5%;\n	  pointer-events: none;\n	}\n\n	.cg-default-style.s-SUgnUE_f2Lao cg-board square.move-dest {\n	  pointer-events: auto;\n	}\n\n	.cg-default-style.s-SUgnUE_f2Lao cg-board square.last-move {\n	  will-change: transform;\n	}\n\n	.cg-default-style.cg-wrap.s-SUgnUE_f2Lao piece {\n	  position: absolute;\n	  top: 0;\n	  left: 0;\n	  width: 12.5%;\n	  height: 12.5%;\n	  background-size: cover;\n	  z-index: 2;\n	  will-change: transform;\n	  pointer-events: none;\n	}\n\n	.cg-default-style.s-SUgnUE_f2Lao cg-board piece.dragging {\n	  cursor: move;\n	  /* !important to override z-index from 3D piece inline style */\n	  z-index: 11 !important;\n	}\n\n	.cg-default-style.s-SUgnUE_f2Lao piece.anim {\n	  z-index: 8;\n	}\n\n	.cg-default-style.s-SUgnUE_f2Lao piece.fading {\n	  z-index: 1;\n	  opacity: 0.5;\n	}\n\n	.cg-default-style.cg-wrap.s-SUgnUE_f2Lao piece.ghost {\n	  opacity: 0.3;\n	}\n\n	.cg-default-style.cg-wrap.s-SUgnUE_f2Lao piece svg {\n	  overflow: hidden;\n	  position: relative;\n	  top: 0px;\n	  left: 0px;\n	  width: 100%;\n	  height: 100%;\n	  pointer-events: none;\n	  z-index: 2;\n	  opacity: 0.6;\n	}\n\n	.cg-default-style.cg-wrap.s-SUgnUE_f2Lao cg-auto-pieces,\n	.cg-default-style.cg-wrap.s-SUgnUE_f2Lao .cg-shapes,\n	.cg-default-style.cg-wrap.s-SUgnUE_f2Lao .cg-custom-svgs {\n	  overflow: visible;\n	  position: absolute;\n	  top: 0px;\n	  left: 0px;\n	  width: 100%;\n	  height: 100%;\n	  pointer-events: none;\n	}\n\n	.cg-default-style.cg-wrap.s-SUgnUE_f2Lao cg-auto-pieces {\n	  z-index: 2;\n	}\n\n	.cg-default-style.cg-wrap.s-SUgnUE_f2Lao cg-auto-pieces piece {\n	  opacity: 0.3;\n	}\n\n	.cg-default-style.cg-wrap.s-SUgnUE_f2Lao .cg-shapes {\n	  overflow: hidden;\n	  opacity: 0.6;\n	  z-index: 2;\n	}\n\n	.cg-default-style.cg-wrap.s-SUgnUE_f2Lao .cg-custom-svgs {\n	  /* over piece.anim = 8, but under piece.dragging = 11 */\n	  z-index: 9;\n	}\n\n	.cg-default-style.cg-wrap.s-SUgnUE_f2Lao .cg-custom-svgs svg {\n	  overflow: visible;\n	}\n\n	.cg-default-style.cg-wrap.s-SUgnUE_f2Lao coords {\n	  position: absolute;\n	  display: flex;\n	  pointer-events: none;\n	  opacity: 0.8;\n	  font-family: sans-serif;\n	  font-size: 9px;\n	}\n\n	.cg-default-style.cg-wrap.s-SUgnUE_f2Lao coords.ranks {\n	  left: 4px;\n	  top: -20px;\n	  flex-flow: column-reverse;\n	  height: 100%;\n	  width: 12px;\n	}\n\n	.cg-default-style.cg-wrap.s-SUgnUE_f2Lao coords.ranks.black {\n	  flex-flow: column;\n	}\n\n	.cg-default-style.cg-wrap.s-SUgnUE_f2Lao coords.ranks.left {\n	  left: -15px;\n	  align-items: flex-end;\n	}\n\n	.cg-default-style.cg-wrap.s-SUgnUE_f2Lao coords.files {\n	  bottom: -4px;\n	  left: 24px;\n	  flex-flow: row;\n	  width: 100%;\n	  height: 16px;\n	  text-transform: uppercase;\n	  text-align: center;\n	}\n\n	.cg-default-style.cg-wrap.s-SUgnUE_f2Lao coords.files.black {\n	  flex-flow: row-reverse;\n	}\n\n	.cg-default-style.cg-wrap.s-SUgnUE_f2Lao coords coord {\n	  flex: 1 1 auto;\n	}\n\n	.cg-default-style.cg-wrap.s-SUgnUE_f2Lao coords.ranks coord {\n	  transform: translateY(39%);\n	}\n\n\n	/*\n	 * chessground.cbrown.css - board appearence\n	 */\n\n	/** Colored board squares as an embedded SVG */\n	.cg-default-style.s-SUgnUE_f2Lao cg-board {\n	  background-color: #f0d9b5;\n	  background-image: url('data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4PSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIgogICAgIHZpZXdCb3g9IjAgMCA4IDgiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyI+CjxnIGlkPSJhIj4KICA8ZyBpZD0iYiI+CiAgICA8ZyBpZD0iYyI+CiAgICAgIDxnIGlkPSJkIj4KICAgICAgICA8cmVjdCB3aWR0aD0iMSIgaGVpZ2h0PSIxIiBpZD0iZSIgb3BhY2l0eT0iMCIvPgogICAgICAgIDx1c2UgeD0iMSIgeT0iMSIgaHJlZj0iI2UiIHg6aHJlZj0iI2UiLz4KICAgICAgICA8cmVjdCB5PSIxIiB3aWR0aD0iMSIgaGVpZ2h0PSIxIiBpZD0iZiIgb3BhY2l0eT0iMC4yIi8+CiAgICAgICAgPHVzZSB4PSIxIiB5PSItMSIgaHJlZj0iI2YiIHg6aHJlZj0iI2YiLz4KICAgICAgPC9nPgogICAgICA8dXNlIHg9IjIiIGhyZWY9IiNkIiB4OmhyZWY9IiNkIi8+CiAgICA8L2c+CiAgICA8dXNlIHg9IjQiIGhyZWY9IiNjIiB4OmhyZWY9IiNjIi8+CiAgPC9nPgogIDx1c2UgeT0iMiIgaHJlZj0iI2IiIHg6aHJlZj0iI2IiLz4KPC9nPgo8dXNlIHk9IjQiIGhyZWY9IiNhIiB4OmhyZWY9IiNhIi8+Cjwvc3ZnPg==');\n	}\n\n	/** Interactive board square colors */\n	.cg-default-style.s-SUgnUE_f2Lao square.move-dest {\n	  background: radial-gradient(rgba(20, 85, 30, 0.5) 22%, #208530 0, rgba(0, 0, 0, 0.3) 0, rgba(0, 0, 0, 0) 0);\n	}\n	.cg-default-style.s-SUgnUE_f2Lao square.premove-dest {\n	  background: radial-gradient(rgba(20, 30, 85, 0.5) 22%, #203085 0, rgba(0, 0, 0, 0.3) 0, rgba(0, 0, 0, 0) 0);\n	}\n	.cg-default-style.s-SUgnUE_f2Lao square.oc.move-dest {\n	  background: radial-gradient(transparent 0%, transparent 80%, rgba(20, 85, 0, 0.3) 80%);\n	}\n	.cg-default-style.s-SUgnUE_f2Lao square.oc.premove-dest {\n	  background: radial-gradient(transparent 0%, transparent 80%, rgba(20, 30, 85, 0.2) 80%);\n	}\n	.cg-default-style.s-SUgnUE_f2Lao square.move-dest:hover {\n	  background: rgba(20, 85, 30, 0.3);\n	}\n	.cg-default-style.s-SUgnUE_f2Lao square.premove-dest:hover {\n	  background: rgba(20, 30, 85, 0.2);\n	}\n	.cg-default-style.s-SUgnUE_f2Lao square.last-move {\n	  background-color: rgba(155, 199, 0, 0.41);\n	}\n	.cg-default-style.s-SUgnUE_f2Lao square.selected {\n	  background-color: rgba(20, 85, 30, 0.5);\n	}\n	.cg-default-style.s-SUgnUE_f2Lao square.check {\n	  background: radial-gradient(\n	    ellipse at center,\n	    rgba(255, 0, 0, 1) 0%,\n	    rgba(231, 0, 0, 1) 25%,\n	    rgba(169, 0, 0, 0) 89%,\n	    rgba(158, 0, 0, 0) 100%\n	  );\n	}\n	.cg-default-style.s-SUgnUE_f2Lao square.current-premove {\n	  background-color: rgba(20, 30, 85, 0.5);\n	}\n\n	/** Alternating colors in rank/file labels */\n	.cg-default-style.cg-wrap.orientation-white.s-SUgnUE_f2Lao coords.ranks coord:nth-child(2n),\n	.cg-default-style.cg-wrap.orientation-white.s-SUgnUE_f2Lao coords.files coord:nth-child(2n),\n	.cg-default-style.cg-wrap.orientation-black.s-SUgnUE_f2Lao coords.ranks coord:nth-child(2n + 1),\n	.cg-default-style.cg-wrap.orientation-black.s-SUgnUE_f2Lao coords.files coord:nth-child(2n + 1) {\n	  color: rgba(72, 72, 72, 0.8);\n	}\n\n	.cg-default-style.cg-wrap.orientation-black.s-SUgnUE_f2Lao coords.ranks coord:nth-child(2n),\n	.cg-default-style.cg-wrap.orientation-black.s-SUgnUE_f2Lao coords.files coord:nth-child(2n),\n	.cg-default-style.cg-wrap.orientation-white.s-SUgnUE_f2Lao coords.ranks coord:nth-child(2n + 1),\n	.cg-default-style.cg-wrap.orientation-white.s-SUgnUE_f2Lao coords.files coord:nth-child(2n + 1) {\n	  color: rgba(255, 255, 255, 0.8);\n	}\n\n\n	/*\n	 * chessground.cburnett.css - embedded SVGs for all chess pieces\n	 */\n\n	.cg-default-style.cg-wrap.s-SUgnUE_f2Lao piece.pawn.white {\n	  background-image: url('data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0NSIgaGVpZ2h0PSI0NSI+PHBhdGggZD0iTTIyLjUgOWMtMi4yMSAwLTQgMS43OS00IDQgMCAuODkuMjkgMS43MS43OCAyLjM4QzE3LjMzIDE2LjUgMTYgMTguNTkgMTYgMjFjMCAyLjAzLjk0IDMuODQgMi40MSA1LjAzLTMgMS4wNi03LjQxIDUuNTUtNy40MSAxMy40N2gyM2MwLTcuOTItNC40MS0xMi40MS03LjQxLTEzLjQ3IDEuNDctMS4xOSAyLjQxLTMgMi40MS01LjAzIDAtMi40MS0xLjMzLTQuNS0zLjI4LTUuNjIuNDktLjY3Ljc4LTEuNDkuNzgtMi4zOCAwLTIuMjEtMS43OS00LTQtNHoiIGZpbGw9IiNmZmYiIHN0cm9rZT0iIzAwMCIgc3Ryb2tlLXdpZHRoPSIxLjUiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIvPjwvc3ZnPg==');\n	}\n	.cg-default-style.cg-wrap.s-SUgnUE_f2Lao piece.bishop.white {\n	  background-image: url('data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0NSIgaGVpZ2h0PSI0NSI+PGcgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIiBzdHJva2U9IiMwMDAiIHN0cm9rZS13aWR0aD0iMS41IiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiPjxnIGZpbGw9IiNmZmYiIHN0cm9rZS1saW5lY2FwPSJidXR0Ij48cGF0aCBkPSJNOSAzNmMzLjM5LS45NyAxMC4xMS40MyAxMy41LTIgMy4zOSAyLjQzIDEwLjExIDEuMDMgMTMuNSAyIDAgMCAxLjY1LjU0IDMgMi0uNjguOTctMS42NS45OS0zIC41LTMuMzktLjk3LTEwLjExLjQ2LTEzLjUtMS0zLjM5IDEuNDYtMTAuMTEuMDMtMTMuNSAxLTEuMzU0LjQ5LTIuMzIzLjQ3LTMtLjUgMS4zNTQtMS45NCAzLTIgMy0yeiIvPjxwYXRoIGQ9Ik0xNSAzMmMyLjUgMi41IDEyLjUgMi41IDE1IDAgLjUtMS41IDAtMiAwLTIgMC0yLjUtMi41LTQtMi41LTQgNS41LTEuNSA2LTExLjUtNS0xNS41LTExIDQtMTAuNSAxNC01IDE1LjUgMCAwLTIuNSAxLjUtMi41IDQgMCAwLS41LjUgMCAyeiIvPjxwYXRoIGQ9Ik0yNSA4YTIuNSAyLjUgMCAxIDEtNSAwIDIuNSAyLjUgMCAxIDEgNSAweiIvPjwvZz48cGF0aCBkPSJNMTcuNSAyNmgxME0xNSAzMGgxNW0tNy41LTE0LjV2NU0yMCAxOGg1IiBzdHJva2UtbGluZWpvaW49Im1pdGVyIi8+PC9nPjwvc3ZnPg==');\n	}\n	.cg-default-style.cg-wrap.s-SUgnUE_f2Lao piece.knight.white {\n	  background-image: url('data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0NSIgaGVpZ2h0PSI0NSI+PGcgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIiBzdHJva2U9IiMwMDAiIHN0cm9rZS13aWR0aD0iMS41IiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiPjxwYXRoIGQ9Ik0yMiAxMGMxMC41IDEgMTYuNSA4IDE2IDI5SDE1YzAtOSAxMC02LjUgOC0yMSIgZmlsbD0iI2ZmZiIvPjxwYXRoIGQ9Ik0yNCAxOGMuMzggMi45MS01LjU1IDcuMzctOCA5LTMgMi0yLjgyIDQuMzQtNSA0LTEuMDQyLS45NCAxLjQxLTMuMDQgMC0zLTEgMCAuMTkgMS4yMy0xIDItMSAwLTQuMDAzIDEtNC00IDAtMiA2LTEyIDYtMTJzMS44OS0xLjkgMi0zLjVjLS43My0uOTk0LS41LTItLjUtMyAxLTEgMyAyLjUgMyAyLjVoMnMuNzgtMS45OTIgMi41LTNjMSAwIDEgMyAxIDMiIGZpbGw9IiNmZmYiLz48cGF0aCBkPSJNOS41IDI1LjVhLjUuNSAwIDEgMS0xIDAgLjUuNSAwIDEgMSAxIDB6bTUuNDMzLTkuNzVhLjUgMS41IDMwIDEgMS0uODY2LS41LjUgMS41IDMwIDEgMSAuODY2LjV6IiBmaWxsPSIjMDAwIi8+PC9nPjwvc3ZnPg==');\n	}\n	.cg-default-style.cg-wrap.s-SUgnUE_f2Lao piece.rook.white {\n	  background-image: url('data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0NSIgaGVpZ2h0PSI0NSI+PGcgZmlsbD0iI2ZmZiIgZmlsbC1ydWxlPSJldmVub2RkIiBzdHJva2U9IiMwMDAiIHN0cm9rZS13aWR0aD0iMS41IiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiPjxwYXRoIGQ9Ik05IDM5aDI3di0zSDl2M3ptMy0zdi00aDIxdjRIMTJ6bS0xLTIyVjloNHYyaDVWOWg1djJoNVY5aDR2NSIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiLz48cGF0aCBkPSJNMzQgMTRsLTMgM0gxNGwtMy0zIi8+PHBhdGggZD0iTTMxIDE3djEyLjVIMTRWMTciIHN0cm9rZS1saW5lY2FwPSJidXR0IiBzdHJva2UtbGluZWpvaW49Im1pdGVyIi8+PHBhdGggZD0iTTMxIDI5LjVsMS41IDIuNWgtMjBsMS41LTIuNSIvPjxwYXRoIGQ9Ik0xMSAxNGgyMyIgZmlsbD0ibm9uZSIgc3Ryb2tlLWxpbmVqb2luPSJtaXRlciIvPjwvZz48L3N2Zz4=');\n	}\n	.cg-default-style.cg-wrap.s-SUgnUE_f2Lao piece.queen.white {\n	  background-image: url('data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0NSIgaGVpZ2h0PSI0NSI+PGcgZmlsbD0iI2ZmZiIgZmlsbC1ydWxlPSJldmVub2RkIiBzdHJva2U9IiMwMDAiIHN0cm9rZS13aWR0aD0iMS41IiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiPjxwYXRoIGQ9Ik04IDEyYTIgMiAwIDEgMS00IDAgMiAyIDAgMSAxIDQgMHptMTYuNS00LjVhMiAyIDAgMSAxLTQgMCAyIDIgMCAxIDEgNCAwek00MSAxMmEyIDIgMCAxIDEtNCAwIDIgMiAwIDEgMSA0IDB6TTE2IDguNWEyIDIgMCAxIDEtNCAwIDIgMiAwIDEgMSA0IDB6TTMzIDlhMiAyIDAgMSAxLTQgMCAyIDIgMCAxIDEgNCAweiIvPjxwYXRoIGQ9Ik05IDI2YzguNS0xLjUgMjEtMS41IDI3IDBsMi0xMi03IDExVjExbC01LjUgMTMuNS0zLTE1LTMgMTUtNS41LTE0VjI1TDcgMTRsMiAxMnoiIHN0cm9rZS1saW5lY2FwPSJidXR0Ii8+PHBhdGggZD0iTTkgMjZjMCAyIDEuNSAyIDIuNSA0IDEgMS41IDEgMSAuNSAzLjUtMS41IDEtMS41IDIuNS0xLjUgMi41LTEuNSAxLjUuNSAyLjUuNSAyLjUgNi41IDEgMTYuNSAxIDIzIDAgMCAwIDEuNS0xIDAtMi41IDAgMCAuNS0xLjUtMS0yLjUtLjUtMi41LS41LTIgLjUtMy41IDEtMiAyLjUtMiAyLjUtNC04LjUtMS41LTE4LjUtMS41LTI3IDB6IiBzdHJva2UtbGluZWNhcD0iYnV0dCIvPjxwYXRoIGQ9Ik0xMS41IDMwYzMuNS0xIDE4LjUtMSAyMiAwTTEyIDMzLjVjNi0xIDE1LTEgMjEgMCIgZmlsbD0ibm9uZSIvPjwvZz48L3N2Zz4=');\n	}\n	.cg-default-style.cg-wrap.s-SUgnUE_f2Lao piece.king.white {\n	  background-image: url('data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0NSIgaGVpZ2h0PSI0NSI+PGcgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIiBzdHJva2U9IiMwMDAiIHN0cm9rZS13aWR0aD0iMS41IiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiPjxwYXRoIGQ9Ik0yMi41IDExLjYzVjZNMjAgOGg1IiBzdHJva2UtbGluZWpvaW49Im1pdGVyIi8+PHBhdGggZD0iTTIyLjUgMjVzNC41LTcuNSAzLTEwLjVjMCAwLTEtMi41LTMtMi41cy0zIDIuNS0zIDIuNWMtMS41IDMgMyAxMC41IDMgMTAuNSIgZmlsbD0iI2ZmZiIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiIHN0cm9rZS1saW5lam9pbj0ibWl0ZXIiLz48cGF0aCBkPSJNMTEuNSAzN2M1LjUgMy41IDE1LjUgMy41IDIxIDB2LTdzOS00LjUgNi0xMC41Yy00LTYuNS0xMy41LTMuNS0xNiA0VjI3di0zLjVjLTMuNS03LjUtMTMtMTAuNS0xNi00LTMgNiA1IDEwIDUgMTBWMzd6IiBmaWxsPSIjZmZmIi8+PHBhdGggZD0iTTExLjUgMzBjNS41LTMgMTUuNS0zIDIxIDBtLTIxIDMuNWM1LjUtMyAxNS41LTMgMjEgMG0tMjEgMy41YzUuNS0zIDE1LjUtMyAyMSAwIi8+PC9nPjwvc3ZnPg==');\n	}\n	.cg-default-style.cg-wrap.s-SUgnUE_f2Lao piece.pawn.black {\n	  background-image: url('data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0NSIgaGVpZ2h0PSI0NSI+PHBhdGggZD0iTTIyLjUgOWMtMi4yMSAwLTQgMS43OS00IDQgMCAuODkuMjkgMS43MS43OCAyLjM4QzE3LjMzIDE2LjUgMTYgMTguNTkgMTYgMjFjMCAyLjAzLjk0IDMuODQgMi40MSA1LjAzLTMgMS4wNi03LjQxIDUuNTUtNy40MSAxMy40N2gyM2MwLTcuOTItNC40MS0xMi40MS03LjQxLTEzLjQ3IDEuNDctMS4xOSAyLjQxLTMgMi40MS01LjAzIDAtMi40MS0xLjMzLTQuNS0zLjI4LTUuNjIuNDktLjY3Ljc4LTEuNDkuNzgtMi4zOCAwLTIuMjEtMS43OS00LTQtNHoiIHN0cm9rZT0iIzAwMCIgc3Ryb2tlLXdpZHRoPSIxLjUiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIvPjwvc3ZnPg==');\n	}\n	.cg-default-style.cg-wrap.s-SUgnUE_f2Lao piece.bishop.black {\n	  background-image: url('data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0NSIgaGVpZ2h0PSI0NSI+PGcgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIiBzdHJva2U9IiMwMDAiIHN0cm9rZS13aWR0aD0iMS41IiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiPjxnIGZpbGw9IiMwMDAiIHN0cm9rZS1saW5lY2FwPSJidXR0Ij48cGF0aCBkPSJNOSAzNmMzLjM5LS45NyAxMC4xMS40MyAxMy41LTIgMy4zOSAyLjQzIDEwLjExIDEuMDMgMTMuNSAyIDAgMCAxLjY1LjU0IDMgMi0uNjguOTctMS42NS45OS0zIC41LTMuMzktLjk3LTEwLjExLjQ2LTEzLjUtMS0zLjM5IDEuNDYtMTAuMTEuMDMtMTMuNSAxLTEuMzU0LjQ5LTIuMzIzLjQ3LTMtLjUgMS4zNTQtMS45NCAzLTIgMy0yeiIvPjxwYXRoIGQ9Ik0xNSAzMmMyLjUgMi41IDEyLjUgMi41IDE1IDAgLjUtMS41IDAtMiAwLTIgMC0yLjUtMi41LTQtMi41LTQgNS41LTEuNSA2LTExLjUtNS0xNS41LTExIDQtMTAuNSAxNC01IDE1LjUgMCAwLTIuNSAxLjUtMi41IDQgMCAwLS41LjUgMCAyeiIvPjxwYXRoIGQ9Ik0yNSA4YTIuNSAyLjUgMCAxIDEtNSAwIDIuNSAyLjUgMCAxIDEgNSAweiIvPjwvZz48cGF0aCBkPSJNMTcuNSAyNmgxME0xNSAzMGgxNW0tNy41LTE0LjV2NU0yMCAxOGg1IiBzdHJva2U9IiNlY2VjZWMiIHN0cm9rZS1saW5lam9pbj0ibWl0ZXIiLz48L2c+PC9zdmc+');\n	}\n	.cg-default-style.cg-wrap.s-SUgnUE_f2Lao piece.knight.black {\n	  background-image: url('data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0NSIgaGVpZ2h0PSI0NSI+PGcgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIiBzdHJva2U9IiMwMDAiIHN0cm9rZS13aWR0aD0iMS41IiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiPjxwYXRoIGQ9Ik0yMiAxMGMxMC41IDEgMTYuNSA4IDE2IDI5SDE1YzAtOSAxMC02LjUgOC0yMSIgZmlsbD0iIzAwMCIvPjxwYXRoIGQ9Ik0yNCAxOGMuMzggMi45MS01LjU1IDcuMzctOCA5LTMgMi0yLjgyIDQuMzQtNSA0LTEuMDQyLS45NCAxLjQxLTMuMDQgMC0zLTEgMCAuMTkgMS4yMy0xIDItMSAwLTQuMDAzIDEtNC00IDAtMiA2LTEyIDYtMTJzMS44OS0xLjkgMi0zLjVjLS43My0uOTk0LS41LTItLjUtMyAxLTEgMyAyLjUgMyAyLjVoMnMuNzgtMS45OTIgMi41LTNjMSAwIDEgMyAxIDMiIGZpbGw9IiMwMDAiLz48cGF0aCBkPSJNOS41IDI1LjVhLjUuNSAwIDEgMS0xIDAgLjUuNSAwIDEgMSAxIDB6bTUuNDMzLTkuNzVhLjUgMS41IDMwIDEgMS0uODY2LS41LjUgMS41IDMwIDEgMSAuODY2LjV6IiBmaWxsPSIjZWNlY2VjIiBzdHJva2U9IiNlY2VjZWMiLz48cGF0aCBkPSJNMjQuNTUgMTAuNGwtLjQ1IDEuNDUuNS4xNWMzLjE1IDEgNS42NSAyLjQ5IDcuOSA2Ljc1UzM1Ljc1IDI5LjA2IDM1LjI1IDM5bC0uMDUuNWgyLjI1bC4wNS0uNWMuNS0xMC4wNi0uODgtMTYuODUtMy4yNS0yMS4zNC0yLjM3LTQuNDktNS43OS02LjY0LTkuMTktNy4xNmwtLjUxLS4xeiIgZmlsbD0iI2VjZWNlYyIgc3Ryb2tlPSJub25lIi8+PC9nPjwvc3ZnPg==');\n	}\n	.cg-default-style.cg-wrap.s-SUgnUE_f2Lao piece.rook.black {\n	  background-image: url('data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0NSIgaGVpZ2h0PSI0NSI+PGcgZmlsbC1ydWxlPSJldmVub2RkIiBzdHJva2U9IiMwMDAiIHN0cm9rZS13aWR0aD0iMS41IiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiPjxwYXRoIGQ9Ik05IDM5aDI3di0zSDl2M3ptMy41LTdsMS41LTIuNWgxN2wxLjUgMi41aC0yMHptLS41IDR2LTRoMjF2NEgxMnoiIHN0cm9rZS1saW5lY2FwPSJidXR0Ii8+PHBhdGggZD0iTTE0IDI5LjV2LTEzaDE3djEzSDE0eiIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiIHN0cm9rZS1saW5lam9pbj0ibWl0ZXIiLz48cGF0aCBkPSJNMTQgMTYuNUwxMSAxNGgyM2wtMyAyLjVIMTR6TTExIDE0VjloNHYyaDVWOWg1djJoNVY5aDR2NUgxMXoiIHN0cm9rZS1saW5lY2FwPSJidXR0Ii8+PHBhdGggZD0iTTEyIDM1LjVoMjFtLTIwLTRoMTltLTE4LTJoMTdtLTE3LTEzaDE3TTExIDE0aDIzIiBmaWxsPSJub25lIiBzdHJva2U9IiNlY2VjZWMiIHN0cm9rZS13aWR0aD0iMSIgc3Ryb2tlLWxpbmVqb2luPSJtaXRlciIvPjwvZz48L3N2Zz4=');\n	}\n	.cg-default-style.cg-wrap.s-SUgnUE_f2Lao piece.queen.black {\n	  background-image: url('data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0NSIgaGVpZ2h0PSI0NSI+PGcgZmlsbC1ydWxlPSJldmVub2RkIiBzdHJva2U9IiMwMDAiIHN0cm9rZS13aWR0aD0iMS41IiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiPjxnIHN0cm9rZT0ibm9uZSI+PGNpcmNsZSBjeD0iNiIgY3k9IjEyIiByPSIyLjc1Ii8+PGNpcmNsZSBjeD0iMTQiIGN5PSI5IiByPSIyLjc1Ii8+PGNpcmNsZSBjeD0iMjIuNSIgY3k9IjgiIHI9IjIuNzUiLz48Y2lyY2xlIGN4PSIzMSIgY3k9IjkiIHI9IjIuNzUiLz48Y2lyY2xlIGN4PSIzOSIgY3k9IjEyIiByPSIyLjc1Ii8+PC9nPjxwYXRoIGQ9Ik05IDI2YzguNS0xLjUgMjEtMS41IDI3IDBsMi41LTEyLjVMMzEgMjVsLS4zLTE0LjEtNS4yIDEzLjYtMy0xNC41LTMgMTQuNS01LjItMTMuNkwxNCAyNSA2LjUgMTMuNSA5IDI2eiIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiLz48cGF0aCBkPSJNOSAyNmMwIDIgMS41IDIgMi41IDQgMSAxLjUgMSAxIC41IDMuNS0xLjUgMS0xLjUgMi41LTEuNSAyLjUtMS41IDEuNS41IDIuNS41IDIuNSA2LjUgMSAxNi41IDEgMjMgMCAwIDAgMS41LTEgMC0yLjUgMCAwIC41LTEuNS0xLTIuNS0uNS0yLjUtLjUtMiAuNS0zLjUgMS0yIDIuNS0yIDIuNS00LTguNS0xLjUtMTguNS0xLjUtMjcgMHoiIHN0cm9rZS1saW5lY2FwPSJidXR0Ii8+PHBhdGggZD0iTTExIDM4LjVhMzUgMzUgMSAwIDAgMjMgMCIgZmlsbD0ibm9uZSIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiLz48cGF0aCBkPSJNMTEgMjlhMzUgMzUgMSAwIDEgMjMgMG0tMjEuNSAyLjVoMjBtLTIxIDNhMzUgMzUgMSAwIDAgMjIgMG0tMjMgM2EzNSAzNSAxIDAgMCAyNCAwIiBmaWxsPSJub25lIiBzdHJva2U9IiNlY2VjZWMiLz48L2c+PC9zdmc+');\n	}\n	.cg-default-style.cg-wrap.s-SUgnUE_f2Lao piece.king.black {\n	  background-image: url('data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0NSIgaGVpZ2h0PSI0NSI+PGcgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIiBzdHJva2U9IiMwMDAiIHN0cm9rZS13aWR0aD0iMS41IiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiPjxwYXRoIGQ9Ik0yMi41IDExLjYzVjYiIHN0cm9rZS1saW5lam9pbj0ibWl0ZXIiLz48cGF0aCBkPSJNMjIuNSAyNXM0LjUtNy41IDMtMTAuNWMwIDAtMS0yLjUtMy0yLjVzLTMgMi41LTMgMi41Yy0xLjUgMyAzIDEwLjUgMyAxMC41IiBmaWxsPSIjMDAwIiBzdHJva2UtbGluZWNhcD0iYnV0dCIgc3Ryb2tlLWxpbmVqb2luPSJtaXRlciIvPjxwYXRoIGQ9Ik0xMS41IDM3YzUuNSAzLjUgMTUuNSAzLjUgMjEgMHYtN3M5LTQuNSA2LTEwLjVjLTQtNi41LTEzLjUtMy41LTE2IDRWMjd2LTMuNWMtMy41LTcuNS0xMy0xMC41LTE2LTQtMyA2IDUgMTAgNSAxMFYzN3oiIGZpbGw9IiMwMDAiLz48cGF0aCBkPSJNMjAgOGg1IiBzdHJva2UtbGluZWpvaW49Im1pdGVyIi8+PHBhdGggZD0iTTMyIDI5LjVzOC41LTQgNi4wMy05LjY1QzM0LjE1IDE0IDI1IDE4IDIyLjUgMjQuNWwuMDEgMi4xLS4wMS0yLjFDMjAgMTggOS45MDYgMTQgNi45OTcgMTkuODVjLTIuNDk3IDUuNjUgNC44NTMgOSA0Ljg1MyA5IiBzdHJva2U9IiNlY2VjZWMiLz48cGF0aCBkPSJNMTEuNSAzMGM1LjUtMyAxNS41LTMgMjEgMG0tMjEgMy41YzUuNS0zIDE1LjUtMyAyMSAwbS0yMSAzLjVjNS41LTMgMTUuNS0zIDIxIDAiIHN0cm9rZT0iI2VjZWNlYyIvPjwvZz48L3N2Zz4=');\n	}\n\n\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ2hlc3Nncm91bmQuc3ZlbHRlIiwic291cmNlcyI6WyJDaGVzc2dyb3VuZC5zdmVsdGUiXSwic291cmNlc0NvbnRlbnQiOlsiPHNjcmlwdD5cblx0aW1wb3J0IHsgQ2hlc3Nncm91bmQgfSBmcm9tICdjaGVzc2dyb3VuZCc7XG5cblx0aW1wb3J0IHsgb25Nb3VudCB9IGZyb20gJ3N2ZWx0ZSc7XG5cblxuXHQvKipcblx0ICpcblx0ICogRXhwb3J0ZWQgcHJvcHMuXG5cdCAqIEFsbCBleHBvcnRlZCBwcm9wcyBhcmUgcmVhY3RpdmUgYW5kIGNhbiBiZSBzZXQgZGlyZWN0bHkgb3IgdmlhIHRoZSBjb25maWcgb2JqZWN0LlxuXHQgKiBDYW5ub3QgYmUgYm91bmQsIHVzZSBjYWxsYmFjayBmdW5jdGlvbnMgdmlhIHRoZSBcImV2ZW50c1wiIG9iamVjdHMgdG8gbW9uaXRvciBzdGF0ZS5cblx0ICpcblx0ICogQWxsIHNpbXBsZS12YWx1ZWQgQ2hlc3Nncm91bmQgcGFyYW1ldGVycyBoYXZlIHRoZWlyIG93biBwcm9wcy4gVGhlIG90aGVycyBtdXN0IGJlIHNldCB2aWEgdGhlIGNvbmZpZyBwcm9wIGFuZCBhcmU6XG5cdCAqICAgICBoaWdobGlnaHQsIGFuaW1hdGlvbiwgbW92YWJsZSwgcHJlbW92YWJsZSwgcHJlZHJvcHBhYmxlLCBkcmFnZ2FibGUsIHNlbGVjdGFibGUsIGV2ZW50cywgZHJhd2FibGVcblx0ICogXG5cdCAqIERldiBub3RlOiBUaGVzZSBwcm9wcyB3b3VsZCBwcmVmZXJyYWJseSBoYXZlIGJlZW4gaW1wbGVtZW50ZWQgd2l0aCAkJHByb3BzIG9yIGEgcHJlcHJvY2Vzc29yLCBidXQgZG9pbmcgc28gd291bGQgbG9zZSBUeXBlc2NyaXB0IGNvbXBpbGUtdGltZSBjaGVja3MuXG5cdCAqL1xuXG5cdC8qKlxuXHQgKiBDU1MgY2xhc3MgbmFtZSBhcHBsaWVkIHRvIHdyYXBwaW5nIGRpdi4gU2V0IHRoaXMgdG8gYXBwbHkgYW5vdGhlclxuXHQgKiBzdHlsZXNoZWV0IHRoYW4gdGhlIGRlZmF1bHQuXG5cdCAqIEB0eXBlIHtzdHJpbmd9XG5cdCAqL1xuXHRsZXQgY2xhc3NOYW1lID0gJ2NnLWRlZmF1bHQtc3R5bGUnO1xuXHRleHBvcnQgeyBjbGFzc05hbWUgYXMgY2xhc3MgfTtcblxuXHQvKiogXG5cdCAqIENoZXNzIHBvc2l0aW9uIGluIEZvcnN5dGgtRWR3YXJkcyBub3RhdGlvbi5cblx0ICogQHR5cGUge2ltcG9ydCgnY2hlc3Nncm91bmQvdHlwZXMnKS5GRU4gfCB1bmRlZmluZWR9XG5cdCAqL1xuXHRleHBvcnQgbGV0IGZlbiA9IHVuZGVmaW5lZDtcblx0JDogc2V0Q29uZmlnKCB7IGZlbjogZmVuIH0gKTtcblxuXHQvKipcblx0ICogQm9hcmQgb3JpZW50YXRpb246IHdoaXRlIG9yIGJsYWNrLlxuXHQgKiBAdHlwZSB7aW1wb3J0KCdjaGVzc2dyb3VuZC90eXBlcycpLkNvbG9yIHwgdW5kZWZpbmVkfVxuXHQgKi9cblx0ZXhwb3J0IGxldCBvcmllbnRhdGlvbiA9IHVuZGVmaW5lZDtcblx0JDogc2V0Q29uZmlnKCB7IG9yaWVudGF0aW9uOiBvcmllbnRhdGlvbiB9ICk7XG5cblx0LyoqXG5cdCAqIFNpZGUgdG8gcGxheTogd2hpdGUgb3IgYmxhY2suXG5cdCAqIEB0eXBlIHtpbXBvcnQoJ2NoZXNzZ3JvdW5kL3R5cGVzJykuQ29sb3IgfCB1bmRlZmluZWR9XG5cdCAqL1xuXHRleHBvcnQgbGV0IHR1cm5Db2xvciA9IHVuZGVmaW5lZDtcblx0JDogc2V0Q29uZmlnKCB7IHR1cm5Db2xvcjogdHVybkNvbG9yIH0gKTtcblxuXHQvKipcblx0ICogQ29sb3IgaW4gY2hlY2ssIGZvciBoaWdobGlnaHRpbmcgdGhlIHNxdWFyZS4gVHJ1ZSBmb3IgdGhlIGN1cnJlbnRcblx0ICogY29sb3IsIG9yIGZhbHNlIHRvIHVuc2V0LlxuXHQgKiBAdHlwZSB7aW1wb3J0KCdjaGVzc2dyb3VuZC90eXBlcycpLkNvbG9yIHwgYm9vbGVhbiB8IHVuZGVmaW5lZH1cblx0ICovXG5cdGV4cG9ydCBsZXQgY2hlY2sgPSB1bmRlZmluZWQ7XG5cdCQ6IHNldENvbmZpZyggeyBjaGVjazogY2hlY2sgfSApO1xuXG5cdC8qKlxuXHQgKiBTcXVhcmVzIG9mIHRoZSBsYXN0IG1vdmUsIGZvciBoaWdobGlnaHRpbmcuXG5cdCAqIEB0eXBlIHtpbXBvcnQoJ2NoZXNzZ3JvdW5kL3R5cGVzJykuS2V5W10gfCB1bmRlZmluZWR9XG5cdCAqL1xuXHRleHBvcnQgbGV0IGxhc3RNb3ZlID0gdW5kZWZpbmVkO1xuXHQkOiBzZXRDb25maWcoIHsgbGFzdE1vdmU6IGxhc3RNb3ZlIH0gKTtcblxuXHQvKipcblx0ICogU3F1YXJlIGN1cnJlbnRseSBzZWxlY3RlZC5cblx0ICogQHR5cGUge2ltcG9ydCgnY2hlc3Nncm91bmQvdHlwZXMnKS5LZXkgfCB1bmRlZmluZWR9XG5cdCAqL1xuXHRleHBvcnQgbGV0IHNlbGVjdGVkID0gdW5kZWZpbmVkO1xuXHQkOiBzZXRDb25maWcoIHsgc2VsZWN0ZWQ6IHNlbGVjdGVkIH0gKTtcblxuXHQvKipcblx0ICogRHJhdyBib2FyZCBjb29yZGluYXRlcyAoYS1oLCAxLTgpLlxuXHQgKiBAdHlwZSB7Ym9vbGVhbiB8IHVuZGVmaW5lZH1cblx0ICovXG5cdGV4cG9ydCBsZXQgY29vcmRpbmF0ZXMgPSB1bmRlZmluZWQ7XG5cdCQ6IHNldENvbmZpZyggeyBjb29yZGluYXRlczogY29vcmRpbmF0ZXMgfSApO1xuXG5cdC8qKlxuXHQgKiBJbW1lZGlhdGVseSBjb21wbGV0ZSBjYXN0bGluZyBieSBtb3ZpbmcgdGhlIHJvb2sgYWZ0ZXIgdGhlIGtpbmcgbW92ZS5cblx0ICogQHR5cGUge2Jvb2xlYW4gfCB1bmRlZmluZWR9XG5cdCAqL1xuXHRleHBvcnQgbGV0IGF1dG9DYXN0bGUgPSB1bmRlZmluZWQ7XG5cdCQ6IHNldENvbmZpZyggeyBhdXRvQ2FzdGxlOiBhdXRvQ2FzdGxlIH0gKTtcblxuXHQvKipcblx0ICogRG9uJ3QgYmluZCBldmVudHM6IHRoZSB1c2VyIHdpbGwgbmV2ZXIgYmUgYWJsZSB0byBtb3ZlIHBpZWNlcyBhcm91bmQuXG5cdCAqIEB0eXBlIHtib29sZWFuIHwgdW5kZWZpbmVkfVxuXHQgKi9cblx0ZXhwb3J0IGxldCB2aWV3T25seSA9IHVuZGVmaW5lZDtcblx0JDogc2V0Q29uZmlnKCB7IHZpZXdPbmx5OiB2aWV3T25seSB9ICk7XG5cblx0LyoqXG5cdCAqIERpc2FibGUgdGhlIHJpZ2h0LWNsaWNrIGNvbnRleHQgbWVudS5cblx0ICogQHR5cGUge2Jvb2xlYW4gfCB1bmRlZmluZWR9XG5cdCAqL1xuXHRleHBvcnQgbGV0IGRpc2FibGVDb250ZXh0TWVudSA9IHVuZGVmaW5lZDtcblx0JDogc2V0Q29uZmlnKCB7IGRpc2FibGVDb250ZXh0TWVudTogZGlzYWJsZUNvbnRleHRNZW51IH0gKTtcblxuXHQvKipcblx0ICogQWRkIHotaW5kZXggdG8gcGllY2VzIChmb3IgM0QpLlxuXHQgKiBAdHlwZSB7Ym9vbGVhbiB8IHVuZGVmaW5lZH1cblx0ICovXG5cdGV4cG9ydCBsZXQgYWRkUGllY2VaSW5kZXggPSB1bmRlZmluZWQ7XG5cdCQ6IHNldENvbmZpZyggeyBhZGRQaWVjZVpJbmRleDogYWRkUGllY2VaSW5kZXggfSApO1xuXG5cdC8qKlxuXHQgKiBBZGQgLS1jZy13aWR0aCBhbmQgLS1jZy1oZWlnaHQgQ1NTIHZhcnMgY29udGFpbmluZyB0aGUgYm9hcmQncyBkaW1lbnNpb25zIHRvIHRoaXMgZWxlbWVudC5cblx0ICogQHR5cGUge0hUTUxFbGVtZW50IHwgdW5kZWZpbmVkfVxuXHQgKi9cblx0ZXhwb3J0IGxldCBhZGREaW1lbnNpb25zQ3NzVmFyc1RvID0gdW5kZWZpbmVkO1xuXHQkOiBzZXRDb25maWcoIHsgYWRkRGltZW5zaW9uc0Nzc1ZhcnNUbzogYWRkRGltZW5zaW9uc0Nzc1ZhcnNUbyB9ICk7XG5cblx0LyoqXG5cdCAqIEJsb2NrIHNjcm9sbGluZyB2aWEgdG91Y2ggZHJhZ2dpbmcgb24gdGhlIGJvYXJkLCBlLmcuIGZvciBjb29yZGluYXRlIHRyYWluaW5nXG5cdCAqIEB0eXBlIHtib29sZWFuIHwgdW5kZWZpbmVkfVxuXHQgKi9cblx0ZXhwb3J0IGxldCBibG9ja1RvdWNoU2Nyb2xsID0gdW5kZWZpbmVkO1xuXHQkOiBzZXRDb25maWcoIHsgYmxvY2tUb3VjaFNjcm9sbDogYmxvY2tUb3VjaFNjcm9sbCB9ICk7XG5cblx0LyoqXG5cdCAqIENoZXNzZ3JvdW5kIGNvbmZpZ3VyYXRpb24uIFRoZSBjb25maWcgcHJvcCBjYW4gYmUgdXNlZCB0byBzZXQgYW55IFxuXHQgKiBjb25maWcga2V5cywgYW5kIGlzIG5lZWRlZCB0byBzZXQgY29uZmlnIGtleXMgdGhhdCBsYWNrIG93blxuXHQgKiBwcm9wczogaGlnaGxpZ2h0LCBhbmltYXRpb24sIG1vdmFibGUsIHByZW1vdmFibGUsIHByZWRyb3BwYWJsZSxcblx0ICogZHJhZ2dhYmxlLCBzZWxlY3RhYmxlLCBldmVudHMgYW5kIGRyYXdhYmxlLlxuXHQgKiBodHRwczovL2dpdGh1Yi5jb20vbGljaGVzcy1vcmcvY2hlc3Nncm91bmQvYmxvYi9tYXN0ZXIvc3JjL2FwaS50c1xuXHQgKiBAdHlwZSB7aW1wb3J0KCdjaGVzc2dyb3VuZC9jb25maWcnKS5Db25maWd9XG5cdCAqL1xuXHRleHBvcnQgbGV0IGNvbmZpZyA9IHt9O1xuXHQkOiBzZXRDb25maWcoIGNvbmZpZyApO1xuXG5cblx0LyoqXG5cdCAqXG5cdCAqIFxuXHQgKiBcblx0ICovXG5cblx0LyoqIEB0eXBlIHtIVE1MRGl2RWxlbWVudH0gKi9cblx0bGV0IGNvbnRhaW5lcjtcblxuXHQvKiogQHR5cGUge2ltcG9ydCgnY2hlc3Nncm91bmQvYXBpJykuQXBpfSAqL1xuXHRsZXQgY2hlc3Nncm91bmQ7XG5cblx0b25Nb3VudChhc3luYyAoKSA9PiB7XG5cdFx0aWYgKCBvcmllbnRhdGlvbiAgICAgICAgICAgICE9PSB1bmRlZmluZWQgKSBjb25maWcub3JpZW50YXRpb24gPSBvcmllbnRhdGlvbjtcblx0XHRpZiAoIGZlbiAgICAgICAgICAgICAgICAgICAgIT09IHVuZGVmaW5lZCApIGNvbmZpZy5mZW4gPSBmZW47XG5cdFx0aWYgKCB0dXJuQ29sb3IgICAgICAgICAgICAgICE9PSB1bmRlZmluZWQgKSBjb25maWcudHVybkNvbG9yID0gdHVybkNvbG9yO1xuXHRcdGlmICggY2hlY2sgICAgICAgICAgICAgICAgICAhPT0gdW5kZWZpbmVkICkgY29uZmlnLmNoZWNrID0gY2hlY2s7XG5cdFx0aWYgKCBsYXN0TW92ZSAgICAgICAgICAgICAgICE9PSB1bmRlZmluZWQgKSBjb25maWcubGFzdE1vdmUgPSBsYXN0TW92ZTtcblx0XHRpZiAoIHNlbGVjdGVkICAgICAgICAgICAgICAgIT09IHVuZGVmaW5lZCApIGNvbmZpZy5zZWxlY3RlZCA9IHNlbGVjdGVkO1xuXHRcdGlmICggY29vcmRpbmF0ZXMgICAgICAgICAgICAhPT0gdW5kZWZpbmVkICkgY29uZmlnLmNvb3JkaW5hdGVzID0gY29vcmRpbmF0ZXMgO1xuXHRcdGlmICggYXV0b0Nhc3RsZSAgICAgICAgICAgICAhPT0gdW5kZWZpbmVkICkgY29uZmlnLmF1dG9DYXN0bGUgPSBhdXRvQ2FzdGxlO1xuXHRcdGlmICggdmlld09ubHkgICAgICAgICAgICAgICAhPT0gdW5kZWZpbmVkICkgY29uZmlnLnZpZXdPbmx5ID0gdmlld09ubHk7XG5cdFx0aWYgKCBkaXNhYmxlQ29udGV4dE1lbnUgICAgICE9PSB1bmRlZmluZWQgKSBjb25maWcuZGlzYWJsZUNvbnRleHRNZW51ID0gZGlzYWJsZUNvbnRleHRNZW51O1xuXHRcdGlmICggYWRkUGllY2VaSW5kZXggICAgICAgICAhPT0gdW5kZWZpbmVkICkgY29uZmlnLmFkZFBpZWNlWkluZGV4ID0gYWRkUGllY2VaSW5kZXg7XG5cdFx0aWYgKCBhZGREaW1lbnNpb25zQ3NzVmFyc1RvICE9PSB1bmRlZmluZWQgKSBjb25maWcuYWRkRGltZW5zaW9uc0Nzc1ZhcnNUbyA9IGFkZERpbWVuc2lvbnNDc3NWYXJzVG87XG5cdFx0aWYgKCBibG9ja1RvdWNoU2Nyb2xsICAgICAgICE9PSB1bmRlZmluZWQgKSBjb25maWcuYmxvY2tUb3VjaFNjcm9sbCA9IGJsb2NrVG91Y2hTY3JvbGw7XG5cdFx0Y2hlc3Nncm91bmQgPSBDaGVzc2dyb3VuZCggY29udGFpbmVyLCBjb25maWcgKTtcblx0fSk7XG5cblx0LyoqXG5cdCAqIFNldCBjb25maWcgdmFsdWVzIGlmIGNvbXBvbmVudCBpcyBtb3VudGVkLiBVc2VkIGZvciByZWFjdGl2ZSBwcm9wcy5cblx0ICogQHBhcmFtIHtpbXBvcnQoJ2NoZXNzZ3JvdW5kL2NvbmZpZycpLkNvbmZpZ30gY29uZmlnIC0gb2JqZWN0IG9mIGtleShzKSBhbmQgdmFsdWUocykgdG8gc2V0LlxuXHQgKiBAcmV0dXJucyB7dm9pZH1cblx0ICovXG5cdGZ1bmN0aW9uIHNldENvbmZpZyggY29uZmlnICkge1xuXHRcdGlmICggY2hlc3Nncm91bmQgKSB7XG5cdFx0XHRjaGVzc2dyb3VuZC5zZXQoIGNvbmZpZyApO1xuXHRcdH1cblx0fVxuXG5cdC8qXG5cdCAqXG5cdCAqIE1ldGhvZHMgcGFzc2VkIHRocm91Z2ggdG8gQ2hlc3Nncm91bmRcblx0ICpcblx0ICovXG5cblx0LyoqXG5cdCAqIFNldCBjb25maWcgdmFsdWVzLiBBbHRlcm5hdGl2ZSB0byB1c2luZyB0aGUgY29uZmlnIHByb3AuXG5cdCAqIEBwYXJhbSB7aW1wb3J0KCdjaGVzc2dyb3VuZC9jb25maWcnKS5Db25maWd9IGNvbmZpZyAtIG9iamVjdCBvZiBrZXkocykgYW5kIHZhbHVlKHMpIHRvIHNldC5cblx0ICogQHJldHVybnMge3ZvaWR9XG5cdCAqL1xuXHRleHBvcnQgZnVuY3Rpb24gc2V0KGNvbmZpZykge1xuXHRcdGNoZXNzZ3JvdW5kLnNldChjb25maWcpO1xuXHR9XG5cblx0LyoqIFxuXHQgKiBJbnRlcm5hbCBDaGVzc2dyb3VuZCBzdGF0ZSwgZGVzY3JpYmVkIGF0XG5cdCAqIGh0dHBzOi8vZ2l0aHViLmNvbS9saWNoZXNzLW9yZy9jaGVzc2dyb3VuZC9ibG9iL21hc3Rlci9zcmMvc3RhdGUudHNcblx0ICogQHJldHVybnMge2ltcG9ydCgnY2hlc3Nncm91bmQvc3RhdGUnKS5TdGF0ZX0gLSBDaGVzc2dyb3VuZCBzdGF0ZVxuXHQgKi9cblx0ZXhwb3J0IGZ1bmN0aW9uIGdldFN0YXRlKCkge1xuXHRcdHJldHVybiBjaGVzc2dyb3VuZC5zdGF0ZTtcblx0fVxuXG5cdC8qKiBcblx0ICogQ3VycmVudCBwb3NpdGlvbiBhcyBhIEZFTiBzdHJpbmcuIENvbnRhaW5zIG9ubHkgcGllY2VzLCBubyBmbGFncy5cblx0ICogZS5nLiBcInJuYnFrYm5yL3BwcHBwcHBwLzgvOC84LzgvUFBQUFBQUFAvUk5CUUtCTlJcIlxuXHQgKiBAcmV0dXJucyB7aW1wb3J0KCdjaGVzc2dyb3VuZC90eXBlcycpLkZFTn0gLSBGRU4gc3RyaW5nXG5cdCAqL1xuXHRleHBvcnQgZnVuY3Rpb24gZ2V0RmVuKCkge1xuXHRcdHJldHVybiBjaGVzc2dyb3VuZC5nZXRGZW4oKTtcblx0fVxuXG5cdC8qKiBcblx0ICogVG9nZ2xlIGNoZXNzYm9hcmQgb3JpZW50YXRpb24gYmV0d2VlbiB3aGl0ZSBhbmQgYmxhY2suIENhbiBhbHNvIGJlXG5cdCAqIGhhbmRsZWQgdmlhIHRoZSBvcmllbnRhdGlvbiBwcm9wLlxuXHQgKiBAcmV0dXJucyB7dm9pZH1cblx0ICovXG5cdGV4cG9ydCBmdW5jdGlvbiB0b2dnbGVPcmllbnRhdGlvbigpIHtcblx0XHRyZXR1cm4gY2hlc3Nncm91bmQudG9nZ2xlT3JpZW50YXRpb24oKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBQZXJmb3JtIGEgbW92ZSBwcm9ncmFtbWF0aWNhbGx5LlxuXHQgKiBAcGFyYW0ge2ltcG9ydCgnY2hlc3Nncm91bmQvdHlwZXMnKS5LZXl9IG9yaWcgLSBPcmlnaW4gc3F1YXJlLlxuXHQgKiBAcGFyYW0ge2ltcG9ydCgnY2hlc3Nncm91bmQvdHlwZXMnKS5LZXl9IGRlc3QgLSBEZXN0aW5hdGlvbiBzcXVhcmUuXG5cdCAqIEByZXR1cm5zIHt2b2lkfVxuXHQgKi9cblx0ZXhwb3J0IGZ1bmN0aW9uIG1vdmUoIG9yaWcsIGRlc3QgKSB7XG5cdFx0cmV0dXJuIGNoZXNzZ3JvdW5kLm1vdmUoIG9yaWcsIGRlc3QgKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBZGQgYW5kL29yIHJlbW92ZSBhcmJpdHJhcnkgcGllY2VzIG9uIHRoZSBib2FyZC5cblx0ICogQHBhcmFtIHtpbXBvcnQoJ2NoZXNzZ3JvdW5kL3R5cGVzJykuUGllY2VzRGlmZn0gcGllY2VzIC0gUGllY2VzIHRvIGFkZC9yZW1vdmUuXG5cdCAqIEByZXR1cm5zIHt2b2lkfVxuXHQgKi9cblx0ZXhwb3J0IGZ1bmN0aW9uIHNldFBpZWNlcyggcGllY2VzICkge1xuXHRcdHJldHVybiBjaGVzc2dyb3VuZC5zZXRQaWVjZXMoIHBpZWNlcyApO1xuXHR9XG5cblx0LyoqXG5cdCAqIENsaWNrIGEgc3F1YXJlIHByb2dyYW1tYXRpY2FsbHkuIFxuXHQgKiBAcGFyYW0ge2ltcG9ydCgnY2hlc3Nncm91bmQvdHlwZXMnKS5LZXkgfCBudWxsIH0ga2V5IC0gU3F1YXJlIHRvIGNsaWNrLlxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IFtmb3JjZV0gLSBDbGljayBldmVuIGlmIHRoZSBzcXVhcmVzIGFyZSBub3Qgc2VsZWN0YWJsZSAoY29uZmlnLnNlbGVjdGFibGUpLlxuXHQgKiBAcmV0dXJucyB7dm9pZH1cblx0ICovXG5cdGV4cG9ydCBmdW5jdGlvbiBzZWxlY3RTcXVhcmUoIGtleSwgZm9yY2UgKSB7XG5cdFx0cmV0dXJuIGNoZXNzZ3JvdW5kLnNlbGVjdFNxdWFyZSgga2V5LCBmb3JjZSApO1xuXHR9XG5cblx0LyoqXG5cdCAqIFB1dCBhIG5ldyBwaWVjZSBvbiB0aGUgYm9hcmQuXG5cdCAqIEBwYXJhbSB7aW1wb3J0KCdjaGVzc2dyb3VuZC90eXBlcycpLlBpZWNlIH0gcGllY2UgLSBQaWVjZSB0byBwbGFjZS5cblx0ICogQHBhcmFtIHtpbXBvcnQoJ2NoZXNzZ3JvdW5kL3R5cGVzJykuS2V5IH0ga2V5IC0gU3F1YXJlIHRvIHBsYWNlIHRoZSBwaWVjZS5cblx0ICogQHJldHVybnMge3ZvaWR9XG5cdCAqL1xuXHRleHBvcnQgZnVuY3Rpb24gbmV3UGllY2UoIHBpZWNlLCBrZXkgKSB7XG5cdFx0cmV0dXJuIGNoZXNzZ3JvdW5kLm5ld1BpZWNlKCBwaWVjZSwga2V5ICk7XG5cdH1cblxuXHQvKipcblx0ICogUGxheSB0aGUgY3VycmVudCBwcmVtb3ZlLCBpZiBhbnkuXG5cdCAqIEByZXR1cm5zIHtib29sZWFufSAtIFRydWUgaWYgYSBwcmVtb3ZlIHdhcyBwbGF5ZWQuXG5cdCAqL1xuXHRleHBvcnQgZnVuY3Rpb24gcGxheVByZW1vdmUoKSB7XG5cdFx0cmV0dXJuIGNoZXNzZ3JvdW5kLnBsYXlQcmVtb3ZlKCk7XG5cdH1cblxuXHQvKipcblx0ICogQ2FuY2VsIHRoZSBjdXJyZW50IHByZW1vdmUsIGlmIGFueS5cblx0ICogQHJldHVybnMge3ZvaWR9XG5cdCAqL1xuXHRleHBvcnQgZnVuY3Rpb24gY2FuY2VsUHJlbW92ZSgpIHtcblx0XHRjaGVzc2dyb3VuZC5jYW5jZWxQcmVtb3ZlKCk7XG5cdH1cblxuXHQvKipcblx0ICogUGxheSB0aGUgY3VycmVudCBwcmVkcm9wLCBpZiBhbnkuXG5cdCAqIEBwYXJhbSB7KGRyb3A6IGltcG9ydCgnY2hlc3Nncm91bmQvdHlwZXMnKS5Ecm9wKSA9PiBib29sZWFuIH0gdmFsaWRhdGUgLSBQcmVkaWNhdGUgdG8gZGVjaWRlIHdoZXRoZXIgYSBkcm9wIGlzIHZhbGlkLlxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gLSBUcnVlIGlmIGEgcHJlZHJvcCB3YXMgcGxheWVkLlxuXHQgKi9cblx0ZXhwb3J0IGZ1bmN0aW9uIHBsYXlQcmVkcm9wKCB2YWxpZGF0ZSApIHtcblx0XHRyZXR1cm4gY2hlc3Nncm91bmQucGxheVByZWRyb3AoIHZhbGlkYXRlICk7XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBDYW5jZWwgdGhlIGN1cnJlbnQgcHJlZHJvcCwgaWYgYW55LlxuXHQgKiBAcmV0dXJucyB7dm9pZH1cblx0ICovXG5cdGV4cG9ydCBmdW5jdGlvbiBjYW5jZWxQcmVkcm9wKCkge1xuXHRcdGNoZXNzZ3JvdW5kLmNhbmNlbFByZWRyb3AoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDYW5jZWwgdGhlIGN1cnJlbnQgbW92ZSBiZWluZyBtYWRlLlxuXHQgKiBAcmV0dXJucyB7dm9pZH1cblx0ICovXG5cdGV4cG9ydCBmdW5jdGlvbiBjYW5jZWxNb3ZlKCkge1xuXHRcdGNoZXNzZ3JvdW5kLmNhbmNlbE1vdmUoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDYW5jZWwgdGhlIGN1cnJlbnQgbW92ZSBhbmQgcHJldmVudCBmdXJ0aGVyIG9uZXMuXG5cdCAqIEByZXR1cm5zIHt2b2lkfVxuXHQgKi9cblx0ZXhwb3J0IGZ1bmN0aW9uIHN0b3AoKSB7XG5cdFx0Y2hlc3Nncm91bmQuc3RvcCgpO1xuXHR9XG5cblx0LyoqXG5cdCAqIE1ha2Ugc3F1YXJlcyBleHBsb2RlIChmb3IgYXRvbWljIGNoZXNzKS5cblx0ICogQHBhcmFtIHtpbXBvcnQoJ2NoZXNzZ3JvdW5kL3R5cGVzJykuS2V5W10gfSBrZXlzIC0gU3F1YXJlcyB0byBleHBsb2RlLlxuXHQgKiBAcmV0dXJucyB7dm9pZH1cblx0ICovXG5cdGV4cG9ydCBmdW5jdGlvbiBleHBsb2RlKCBrZXlzICkge1xuXHRcdGNoZXNzZ3JvdW5kLmV4cGxvZGUoIGtleXMgKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBQcm9ncmFtbWF0aWNhbGx5IGRyYXcgdXNlciBzaGFwZXMuXG5cdCAqIEBwYXJhbSB7aW1wb3J0KCdjaGVzc2dyb3VuZC9kcmF3JykuRHJhd1NoYXBlW10gfSBzaGFwZXMgLSBTaGFwZXMgdG8gZHJhdy5cblx0ICogQHJldHVybnMge3ZvaWR9XG5cdCAqL1xuXHRleHBvcnQgZnVuY3Rpb24gc2V0U2hhcGVzKCBzaGFwZXMgKSB7XG5cdFx0Y2hlc3Nncm91bmQuc2V0U2hhcGVzKCBzaGFwZXMgKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBQcm9ncmFtbWF0aWNhbGx5IGRyYXcgYXV0byBzaGFwZXMuXG5cdCAqIEBwYXJhbSB7aW1wb3J0KCdjaGVzc2dyb3VuZC9kcmF3JykuRHJhd1NoYXBlW10gfSBzaGFwZXMgLSBTaGFwZXMgdG8gZHJhdy5cblx0ICogQHJldHVybnMge3ZvaWR9XG5cdCAqL1xuXHRleHBvcnQgZnVuY3Rpb24gc2V0QXV0b1NoYXBlcyggc2hhcGVzICkge1xuXHRcdGNoZXNzZ3JvdW5kLnNldEF1dG9TaGFwZXMoIHNoYXBlcyApO1xuXHR9XG5cblx0LyoqIFxuXHQgKiBSZWRyYXcuIFVzZWZ1bCB3aGVuIENTUyBjaGFuZ2VzIHRoZSBib2FyZCB3aWR0aCBvciBoZWlnaHQuXG5cdCAqIEByZXR1cm5zIHt2b2lkfVxuXHQgKi9cblx0ZXhwb3J0IGZ1bmN0aW9uIHJlZHJhd0FsbCgpIHtcblx0XHRyZXR1cm4gY2hlc3Nncm91bmQucmVkcmF3QWxsKCk7XG5cdH1cblxuXHQvKipcblx0ICogRHJhZyBuZXcgcGllY2UsIGZvciBjcmF6eWhvdXNlIGFuZCBib2FyZCBlZGl0b3JzLlxuXHQgKiBAcGFyYW0ge2ltcG9ydCgnY2hlc3Nncm91bmQvdHlwZXMnKS5QaWVjZSB9IHBpZWNlIC0gUGllY2UgdG8gZHJvcFxuXHQgKiBAcGFyYW0ge2ltcG9ydCgnY2hlc3Nncm91bmQvdHlwZXMnKS5Nb3VjaEV2ZW50IH0gZXZlbnQgLSBUaGUgbW91c2UvdG91Y2ggZXZlbnQgaWRlbnRpZnlpbmcgYSB0YXJnZXQuXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW2ZvcmNlXSAtIFRydWUgaWYgdGhlIG5ldyBwaWVjZSBjYW4gcmVwbGFjZSBhbiBleGlzdGluZyBvbmUuXG5cdCAqIEByZXR1cm5zIHt2b2lkfVxuXHQgKi9cblx0ZXhwb3J0IGZ1bmN0aW9uIGRyYWdOZXdQaWVjZSggcGllY2UsIGV2ZW50LCBmb3JjZSApIHtcblx0XHRjaGVzc2dyb3VuZC5kcmFnTmV3UGllY2UoIHBpZWNlLCBldmVudCwgZm9yY2UgKTtcblx0fVxuXG5cdC8qKiBAcmV0dXJucyB7dm9pZH0gKi9cblx0ZXhwb3J0IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG5cdFx0cmV0dXJuIGNoZXNzZ3JvdW5kLmRlc3Ryb3koKTtcblx0fVxuXG48L3NjcmlwdD5cblxuPGRpdiBjbGFzcz1cImNnLXdyYXAge2NsYXNzTmFtZX1cIiBiaW5kOnRoaXM9e2NvbnRhaW5lcn0+PC9kaXY+XG5cbjxzdHlsZT5cblxuIC5jZy13cmFwIHtcbiAgICB3aWR0aDogMTAwJTtcbiAgICBhc3BlY3QtcmF0aW86IDE7XG4gIH1cblxuICBAc3VwcG9ydHMgbm90IChhc3BlY3QtcmF0aW86IDEpIHtcbiAgICAuY2ctd3JhcCB7XG4gICAgICBwYWRkaW5nLXRvcDogMTAwJTtcbiAgICB9XG4gIH1cblxuICAvKlxuXHQgKiBCb2FyZCBzdHlsaW5nLlxuXHQgKlxuXHQgKiBBcyB0aGVyZSBpcyBubyBidW5kbGVyLWFnbm9zdGljIHdheSBvZiBpbmNsdWRpbmcgQ1NTIGZpbGVzIChwbGVhc2Vcblx0ICogY29ycmVjdCBtZSBpZiBJJ20gd3JvbmcpLCB0aGUgZGVmYXVsdCBDaGVzc2dyb3VuZCBzdHlsZXMgYXJlXG5cdCAqIGluY2x1ZGVkIGhlcmUuXG5cdCAqL1xuXG5cdC8qXG5cdCAqIGNoZXNzZ3JvdW5kLmJhc2UuY3NzIFxuXHQgKi9cblxuXG5cdC5jZy1kZWZhdWx0LXN0eWxlLmNnLXdyYXAge1xuXHQgIGJveC1zaXppbmc6IGNvbnRlbnQtYm94O1xuXHQgIHBvc2l0aW9uOiByZWxhdGl2ZTtcblx0ICBkaXNwbGF5OiBibG9jaztcblx0fVxuXG5cdC5jZy1kZWZhdWx0LXN0eWxlIDpnbG9iYWwoY2ctY29udGFpbmVyKSB7XG5cdCAgcG9zaXRpb246IGFic29sdXRlO1xuXHQgIHdpZHRoOiAxMDAlO1xuXHQgIGhlaWdodDogMTAwJTtcblx0ICBkaXNwbGF5OiBibG9jaztcblx0ICB0b3A6IDA7XG5cdH1cblxuXHQuY2ctZGVmYXVsdC1zdHlsZSA6Z2xvYmFsKGNnLWJvYXJkKSB7XG5cdCAgcG9zaXRpb246IGFic29sdXRlO1xuXHQgIHRvcDogMDtcblx0ICBsZWZ0OiAwO1xuXHQgIHdpZHRoOiAxMDAlO1xuXHQgIGhlaWdodDogMTAwJTtcblx0ICAtd2Via2l0LXVzZXItc2VsZWN0OiBub25lO1xuXHQgIC1tb3otdXNlci1zZWxlY3Q6IG5vbmU7XG5cdCAgLW1zLXVzZXItc2VsZWN0OiBub25lO1xuXHQgIHVzZXItc2VsZWN0OiBub25lO1xuXHQgIGxpbmUtaGVpZ2h0OiAwO1xuXHQgIGJhY2tncm91bmQtc2l6ZTogY292ZXI7XG5cdH1cblxuXHQuY2ctZGVmYXVsdC1zdHlsZS5jZy13cmFwLm1hbmlwdWxhYmxlIDpnbG9iYWwoY2ctYm9hcmQpIHtcblx0ICBjdXJzb3I6IHBvaW50ZXI7XG5cdH1cblxuXHQuY2ctZGVmYXVsdC1zdHlsZSA6Z2xvYmFsKGNnLWJvYXJkIHNxdWFyZSkge1xuXHQgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcblx0ICB0b3A6IDA7XG5cdCAgbGVmdDogMDtcblx0ICB3aWR0aDogMTIuNSU7XG5cdCAgaGVpZ2h0OiAxMi41JTtcblx0ICBwb2ludGVyLWV2ZW50czogbm9uZTtcblx0fVxuXG5cdC5jZy1kZWZhdWx0LXN0eWxlIDpnbG9iYWwoY2ctYm9hcmQgc3F1YXJlLm1vdmUtZGVzdCkge1xuXHQgIHBvaW50ZXItZXZlbnRzOiBhdXRvO1xuXHR9XG5cblx0LmNnLWRlZmF1bHQtc3R5bGUgOmdsb2JhbChjZy1ib2FyZCBzcXVhcmUubGFzdC1tb3ZlKSB7XG5cdCAgd2lsbC1jaGFuZ2U6IHRyYW5zZm9ybTtcblx0fVxuXG5cdC5jZy1kZWZhdWx0LXN0eWxlLmNnLXdyYXAgOmdsb2JhbChwaWVjZSkge1xuXHQgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcblx0ICB0b3A6IDA7XG5cdCAgbGVmdDogMDtcblx0ICB3aWR0aDogMTIuNSU7XG5cdCAgaGVpZ2h0OiAxMi41JTtcblx0ICBiYWNrZ3JvdW5kLXNpemU6IGNvdmVyO1xuXHQgIHotaW5kZXg6IDI7XG5cdCAgd2lsbC1jaGFuZ2U6IHRyYW5zZm9ybTtcblx0ICBwb2ludGVyLWV2ZW50czogbm9uZTtcblx0fVxuXG5cdC5jZy1kZWZhdWx0LXN0eWxlIDpnbG9iYWwoY2ctYm9hcmQgcGllY2UuZHJhZ2dpbmcpIHtcblx0ICBjdXJzb3I6IG1vdmU7XG5cdCAgLyogIWltcG9ydGFudCB0byBvdmVycmlkZSB6LWluZGV4IGZyb20gM0QgcGllY2UgaW5saW5lIHN0eWxlICovXG5cdCAgei1pbmRleDogMTEgIWltcG9ydGFudDtcblx0fVxuXG5cdC5jZy1kZWZhdWx0LXN0eWxlIDpnbG9iYWwocGllY2UuYW5pbSkge1xuXHQgIHotaW5kZXg6IDg7XG5cdH1cblxuXHQuY2ctZGVmYXVsdC1zdHlsZSA6Z2xvYmFsKHBpZWNlLmZhZGluZykge1xuXHQgIHotaW5kZXg6IDE7XG5cdCAgb3BhY2l0eTogMC41O1xuXHR9XG5cblx0LmNnLWRlZmF1bHQtc3R5bGUuY2ctd3JhcCA6Z2xvYmFsKHBpZWNlLmdob3N0KSB7XG5cdCAgb3BhY2l0eTogMC4zO1xuXHR9XG5cblx0LmNnLWRlZmF1bHQtc3R5bGUuY2ctd3JhcCA6Z2xvYmFsKHBpZWNlIHN2Zykge1xuXHQgIG92ZXJmbG93OiBoaWRkZW47XG5cdCAgcG9zaXRpb246IHJlbGF0aXZlO1xuXHQgIHRvcDogMHB4O1xuXHQgIGxlZnQ6IDBweDtcblx0ICB3aWR0aDogMTAwJTtcblx0ICBoZWlnaHQ6IDEwMCU7XG5cdCAgcG9pbnRlci1ldmVudHM6IG5vbmU7XG5cdCAgei1pbmRleDogMjtcblx0ICBvcGFjaXR5OiAwLjY7XG5cdH1cblxuXHQuY2ctZGVmYXVsdC1zdHlsZS5jZy13cmFwIDpnbG9iYWwoY2ctYXV0by1waWVjZXMpLFxuXHQuY2ctZGVmYXVsdC1zdHlsZS5jZy13cmFwIDpnbG9iYWwoLmNnLXNoYXBlcyksXG5cdC5jZy1kZWZhdWx0LXN0eWxlLmNnLXdyYXAgOmdsb2JhbCguY2ctY3VzdG9tLXN2Z3MpIHtcblx0ICBvdmVyZmxvdzogdmlzaWJsZTtcblx0ICBwb3NpdGlvbjogYWJzb2x1dGU7XG5cdCAgdG9wOiAwcHg7XG5cdCAgbGVmdDogMHB4O1xuXHQgIHdpZHRoOiAxMDAlO1xuXHQgIGhlaWdodDogMTAwJTtcblx0ICBwb2ludGVyLWV2ZW50czogbm9uZTtcblx0fVxuXG5cdC5jZy1kZWZhdWx0LXN0eWxlLmNnLXdyYXAgOmdsb2JhbChjZy1hdXRvLXBpZWNlcykge1xuXHQgIHotaW5kZXg6IDI7XG5cdH1cblxuXHQuY2ctZGVmYXVsdC1zdHlsZS5jZy13cmFwIDpnbG9iYWwoY2ctYXV0by1waWVjZXMgcGllY2UpIHtcblx0ICBvcGFjaXR5OiAwLjM7XG5cdH1cblxuXHQuY2ctZGVmYXVsdC1zdHlsZS5jZy13cmFwIDpnbG9iYWwoLmNnLXNoYXBlcykge1xuXHQgIG92ZXJmbG93OiBoaWRkZW47XG5cdCAgb3BhY2l0eTogMC42O1xuXHQgIHotaW5kZXg6IDI7XG5cdH1cblxuXHQuY2ctZGVmYXVsdC1zdHlsZS5jZy13cmFwIDpnbG9iYWwoLmNnLWN1c3RvbS1zdmdzKSB7XG5cdCAgLyogb3ZlciBwaWVjZS5hbmltID0gOCwgYnV0IHVuZGVyIHBpZWNlLmRyYWdnaW5nID0gMTEgKi9cblx0ICB6LWluZGV4OiA5O1xuXHR9XG5cblx0LmNnLWRlZmF1bHQtc3R5bGUuY2ctd3JhcCA6Z2xvYmFsKC5jZy1jdXN0b20tc3ZncyBzdmcpIHtcblx0ICBvdmVyZmxvdzogdmlzaWJsZTtcblx0fVxuXG5cdC5jZy1kZWZhdWx0LXN0eWxlLmNnLXdyYXAgOmdsb2JhbChjb29yZHMpIHtcblx0ICBwb3NpdGlvbjogYWJzb2x1dGU7XG5cdCAgZGlzcGxheTogZmxleDtcblx0ICBwb2ludGVyLWV2ZW50czogbm9uZTtcblx0ICBvcGFjaXR5OiAwLjg7XG5cdCAgZm9udC1mYW1pbHk6IHNhbnMtc2VyaWY7XG5cdCAgZm9udC1zaXplOiA5cHg7XG5cdH1cblxuXHQuY2ctZGVmYXVsdC1zdHlsZS5jZy13cmFwIDpnbG9iYWwoY29vcmRzLnJhbmtzKSB7XG5cdCAgbGVmdDogNHB4O1xuXHQgIHRvcDogLTIwcHg7XG5cdCAgZmxleC1mbG93OiBjb2x1bW4tcmV2ZXJzZTtcblx0ICBoZWlnaHQ6IDEwMCU7XG5cdCAgd2lkdGg6IDEycHg7XG5cdH1cblxuXHQuY2ctZGVmYXVsdC1zdHlsZS5jZy13cmFwIDpnbG9iYWwoY29vcmRzLnJhbmtzLmJsYWNrKSB7XG5cdCAgZmxleC1mbG93OiBjb2x1bW47XG5cdH1cblxuXHQuY2ctZGVmYXVsdC1zdHlsZS5jZy13cmFwIDpnbG9iYWwoY29vcmRzLnJhbmtzLmxlZnQpIHtcblx0ICBsZWZ0OiAtMTVweDtcblx0ICBhbGlnbi1pdGVtczogZmxleC1lbmQ7XG5cdH1cblxuXHQuY2ctZGVmYXVsdC1zdHlsZS5jZy13cmFwIDpnbG9iYWwoY29vcmRzLmZpbGVzKSB7XG5cdCAgYm90dG9tOiAtNHB4O1xuXHQgIGxlZnQ6IDI0cHg7XG5cdCAgZmxleC1mbG93OiByb3c7XG5cdCAgd2lkdGg6IDEwMCU7XG5cdCAgaGVpZ2h0OiAxNnB4O1xuXHQgIHRleHQtdHJhbnNmb3JtOiB1cHBlcmNhc2U7XG5cdCAgdGV4dC1hbGlnbjogY2VudGVyO1xuXHR9XG5cblx0LmNnLWRlZmF1bHQtc3R5bGUuY2ctd3JhcCA6Z2xvYmFsKGNvb3Jkcy5maWxlcy5ibGFjaykge1xuXHQgIGZsZXgtZmxvdzogcm93LXJldmVyc2U7XG5cdH1cblxuXHQuY2ctZGVmYXVsdC1zdHlsZS5jZy13cmFwIDpnbG9iYWwoY29vcmRzIGNvb3JkKSB7XG5cdCAgZmxleDogMSAxIGF1dG87XG5cdH1cblxuXHQuY2ctZGVmYXVsdC1zdHlsZS5jZy13cmFwIDpnbG9iYWwoY29vcmRzLnJhbmtzIGNvb3JkKSB7XG5cdCAgdHJhbnNmb3JtOiB0cmFuc2xhdGVZKDM5JSk7XG5cdH1cblxuXG5cdC8qXG5cdCAqIGNoZXNzZ3JvdW5kLmNicm93bi5jc3MgLSBib2FyZCBhcHBlYXJlbmNlXG5cdCAqL1xuXG5cdC8qKiBDb2xvcmVkIGJvYXJkIHNxdWFyZXMgYXMgYW4gZW1iZWRkZWQgU1ZHICovXG5cdC5jZy1kZWZhdWx0LXN0eWxlIDpnbG9iYWwoY2ctYm9hcmQpIHtcblx0ICBiYWNrZ3JvdW5kLWNvbG9yOiAjZjBkOWI1O1xuXHQgIGJhY2tncm91bmQtaW1hZ2U6IHVybCgnZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQRDk0Yld3Z2RtVnljMmx2YmowaU1TNHdJaUJsYm1OdlpHbHVaejBpVlZSR0xUZ2lJSE4wWVc1a1lXeHZibVU5SW01dklqOCtDanh6ZG1jZ2VHMXNibk05SW1oMGRIQTZMeTkzZDNjdWR6TXViM0puTHpJd01EQXZjM1puSWlCNGJXeHVjenA0UFNKb2RIUndPaTh2ZDNkM0xuY3pMbTl5Wnk4eE9UazVMM2hzYVc1cklnb2dJQ0FnSUhacFpYZENiM2c5SWpBZ01DQTRJRGdpSUhOb1lYQmxMWEpsYm1SbGNtbHVaejBpWTNKcGMzQkZaR2RsY3lJK0NqeG5JR2xrUFNKaElqNEtJQ0E4WnlCcFpEMGlZaUkrQ2lBZ0lDQThaeUJwWkQwaVl5SStDaUFnSUNBZ0lEeG5JR2xrUFNKa0lqNEtJQ0FnSUNBZ0lDQThjbVZqZENCM2FXUjBhRDBpTVNJZ2FHVnBaMmgwUFNJeElpQnBaRDBpWlNJZ2IzQmhZMmwwZVQwaU1DSXZQZ29nSUNBZ0lDQWdJRHgxYzJVZ2VEMGlNU0lnZVQwaU1TSWdhSEpsWmowaUkyVWlJSGc2YUhKbFpqMGlJMlVpTHo0S0lDQWdJQ0FnSUNBOGNtVmpkQ0I1UFNJeElpQjNhV1IwYUQwaU1TSWdhR1ZwWjJoMFBTSXhJaUJwWkQwaVppSWdiM0JoWTJsMGVUMGlNQzR5SWk4K0NpQWdJQ0FnSUNBZ1BIVnpaU0I0UFNJeElpQjVQU0l0TVNJZ2FISmxaajBpSTJZaUlIZzZhSEpsWmowaUkyWWlMejRLSUNBZ0lDQWdQQzluUGdvZ0lDQWdJQ0E4ZFhObElIZzlJaklpSUdoeVpXWTlJaU5rSWlCNE9taHlaV1k5SWlOa0lpOCtDaUFnSUNBOEwyYytDaUFnSUNBOGRYTmxJSGc5SWpRaUlHaHlaV1k5SWlOaklpQjRPbWh5WldZOUlpTmpJaTgrQ2lBZ1BDOW5QZ29nSUR4MWMyVWdlVDBpTWlJZ2FISmxaajBpSTJJaUlIZzZhSEpsWmowaUkySWlMejRLUEM5blBnbzhkWE5sSUhrOUlqUWlJR2h5WldZOUlpTmhJaUI0T21oeVpXWTlJaU5oSWk4K0Nqd3ZjM1puUGc9PScpO1xuXHR9XG5cblx0LyoqIEludGVyYWN0aXZlIGJvYXJkIHNxdWFyZSBjb2xvcnMgKi9cblx0LmNnLWRlZmF1bHQtc3R5bGUgOmdsb2JhbChzcXVhcmUubW92ZS1kZXN0KSB7XG5cdCAgYmFja2dyb3VuZDogcmFkaWFsLWdyYWRpZW50KHJnYmEoMjAsIDg1LCAzMCwgMC41KSAyMiUsICMyMDg1MzAgMCwgcmdiYSgwLCAwLCAwLCAwLjMpIDAsIHJnYmEoMCwgMCwgMCwgMCkgMCk7XG5cdH1cblx0LmNnLWRlZmF1bHQtc3R5bGUgOmdsb2JhbChzcXVhcmUucHJlbW92ZS1kZXN0KSB7XG5cdCAgYmFja2dyb3VuZDogcmFkaWFsLWdyYWRpZW50KHJnYmEoMjAsIDMwLCA4NSwgMC41KSAyMiUsICMyMDMwODUgMCwgcmdiYSgwLCAwLCAwLCAwLjMpIDAsIHJnYmEoMCwgMCwgMCwgMCkgMCk7XG5cdH1cblx0LmNnLWRlZmF1bHQtc3R5bGUgOmdsb2JhbChzcXVhcmUub2MubW92ZS1kZXN0KSB7XG5cdCAgYmFja2dyb3VuZDogcmFkaWFsLWdyYWRpZW50KHRyYW5zcGFyZW50IDAlLCB0cmFuc3BhcmVudCA4MCUsIHJnYmEoMjAsIDg1LCAwLCAwLjMpIDgwJSk7XG5cdH1cblx0LmNnLWRlZmF1bHQtc3R5bGUgOmdsb2JhbChzcXVhcmUub2MucHJlbW92ZS1kZXN0KSB7XG5cdCAgYmFja2dyb3VuZDogcmFkaWFsLWdyYWRpZW50KHRyYW5zcGFyZW50IDAlLCB0cmFuc3BhcmVudCA4MCUsIHJnYmEoMjAsIDMwLCA4NSwgMC4yKSA4MCUpO1xuXHR9XG5cdC5jZy1kZWZhdWx0LXN0eWxlIDpnbG9iYWwoc3F1YXJlLm1vdmUtZGVzdDpob3Zlcikge1xuXHQgIGJhY2tncm91bmQ6IHJnYmEoMjAsIDg1LCAzMCwgMC4zKTtcblx0fVxuXHQuY2ctZGVmYXVsdC1zdHlsZSA6Z2xvYmFsKHNxdWFyZS5wcmVtb3ZlLWRlc3Q6aG92ZXIpIHtcblx0ICBiYWNrZ3JvdW5kOiByZ2JhKDIwLCAzMCwgODUsIDAuMik7XG5cdH1cblx0LmNnLWRlZmF1bHQtc3R5bGUgOmdsb2JhbChzcXVhcmUubGFzdC1tb3ZlKSB7XG5cdCAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgxNTUsIDE5OSwgMCwgMC40MSk7XG5cdH1cblx0LmNnLWRlZmF1bHQtc3R5bGUgOmdsb2JhbChzcXVhcmUuc2VsZWN0ZWQpIHtcblx0ICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDIwLCA4NSwgMzAsIDAuNSk7XG5cdH1cblx0LmNnLWRlZmF1bHQtc3R5bGUgOmdsb2JhbChzcXVhcmUuY2hlY2spIHtcblx0ICBiYWNrZ3JvdW5kOiByYWRpYWwtZ3JhZGllbnQoXG5cdCAgICBlbGxpcHNlIGF0IGNlbnRlcixcblx0ICAgIHJnYmEoMjU1LCAwLCAwLCAxKSAwJSxcblx0ICAgIHJnYmEoMjMxLCAwLCAwLCAxKSAyNSUsXG5cdCAgICByZ2JhKDE2OSwgMCwgMCwgMCkgODklLFxuXHQgICAgcmdiYSgxNTgsIDAsIDAsIDApIDEwMCVcblx0ICApO1xuXHR9XG5cdC5jZy1kZWZhdWx0LXN0eWxlIDpnbG9iYWwoc3F1YXJlLmN1cnJlbnQtcHJlbW92ZSkge1xuXHQgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjAsIDMwLCA4NSwgMC41KTtcblx0fVxuXG5cdC8qKiBBbHRlcm5hdGluZyBjb2xvcnMgaW4gcmFuay9maWxlIGxhYmVscyAqL1xuXHQuY2ctZGVmYXVsdC1zdHlsZS5jZy13cmFwLm9yaWVudGF0aW9uLXdoaXRlIDpnbG9iYWwoY29vcmRzLnJhbmtzIGNvb3JkOm50aC1jaGlsZCgybikpLFxuXHQuY2ctZGVmYXVsdC1zdHlsZS5jZy13cmFwLm9yaWVudGF0aW9uLXdoaXRlIDpnbG9iYWwoY29vcmRzLmZpbGVzIGNvb3JkOm50aC1jaGlsZCgybikpLFxuXHQuY2ctZGVmYXVsdC1zdHlsZS5jZy13cmFwLm9yaWVudGF0aW9uLWJsYWNrIDpnbG9iYWwoY29vcmRzLnJhbmtzIGNvb3JkOm50aC1jaGlsZCgybiArIDEpKSxcblx0LmNnLWRlZmF1bHQtc3R5bGUuY2ctd3JhcC5vcmllbnRhdGlvbi1ibGFjayA6Z2xvYmFsKGNvb3Jkcy5maWxlcyBjb29yZDpudGgtY2hpbGQoMm4gKyAxKSkge1xuXHQgIGNvbG9yOiByZ2JhKDcyLCA3MiwgNzIsIDAuOCk7XG5cdH1cblxuXHQuY2ctZGVmYXVsdC1zdHlsZS5jZy13cmFwLm9yaWVudGF0aW9uLWJsYWNrIDpnbG9iYWwoY29vcmRzLnJhbmtzIGNvb3JkOm50aC1jaGlsZCgybikpLFxuXHQuY2ctZGVmYXVsdC1zdHlsZS5jZy13cmFwLm9yaWVudGF0aW9uLWJsYWNrIDpnbG9iYWwoY29vcmRzLmZpbGVzIGNvb3JkOm50aC1jaGlsZCgybikpLFxuXHQuY2ctZGVmYXVsdC1zdHlsZS5jZy13cmFwLm9yaWVudGF0aW9uLXdoaXRlIDpnbG9iYWwoY29vcmRzLnJhbmtzIGNvb3JkOm50aC1jaGlsZCgybiArIDEpKSxcblx0LmNnLWRlZmF1bHQtc3R5bGUuY2ctd3JhcC5vcmllbnRhdGlvbi13aGl0ZSA6Z2xvYmFsKGNvb3Jkcy5maWxlcyBjb29yZDpudGgtY2hpbGQoMm4gKyAxKSkge1xuXHQgIGNvbG9yOiByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuOCk7XG5cdH1cblxuXG5cdC8qXG5cdCAqIGNoZXNzZ3JvdW5kLmNidXJuZXR0LmNzcyAtIGVtYmVkZGVkIFNWR3MgZm9yIGFsbCBjaGVzcyBwaWVjZXNcblx0ICovXG5cblx0LmNnLWRlZmF1bHQtc3R5bGUuY2ctd3JhcCA6Z2xvYmFsKHBpZWNlLnBhd24ud2hpdGUpIHtcblx0ICBiYWNrZ3JvdW5kLWltYWdlOiB1cmwoJ2RhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaUlIZHBaSFJvUFNJME5TSWdhR1ZwWjJoMFBTSTBOU0krUEhCaGRHZ2daRDBpVFRJeUxqVWdPV010TWk0eU1TQXdMVFFnTVM0M09TMDBJRFFnTUNBdU9Ea3VNamtnTVM0M01TNDNPQ0F5TGpNNFF6RTNMak16SURFMkxqVWdNVFlnTVRndU5Ua2dNVFlnTWpGak1DQXlMakF6TGprMElETXVPRFFnTWk0ME1TQTFMakF6TFRNZ01TNHdOaTAzTGpReElEVXVOVFV0Tnk0ME1TQXhNeTQwTjJneU0yTXdMVGN1T1RJdE5DNDBNUzB4TWk0ME1TMDNMalF4TFRFekxqUTNJREV1TkRjdE1TNHhPU0F5TGpReExUTWdNaTQwTVMwMUxqQXpJREF0TWk0ME1TMHhMak16TFRRdU5TMHpMakk0TFRVdU5qSXVORGt0TGpZM0xqYzRMVEV1TkRrdU56Z3RNaTR6T0NBd0xUSXVNakV0TVM0M09TMDBMVFF0TkhvaUlHWnBiR3c5SWlObVptWWlJSE4wY205clpUMGlJekF3TUNJZ2MzUnliMnRsTFhkcFpIUm9QU0l4TGpVaUlITjBjbTlyWlMxc2FXNWxZMkZ3UFNKeWIzVnVaQ0l2UGp3dmMzWm5QZz09Jyk7XG5cdH1cblx0LmNnLWRlZmF1bHQtc3R5bGUuY2ctd3JhcCA6Z2xvYmFsKHBpZWNlLmJpc2hvcC53aGl0ZSkge1xuXHQgIGJhY2tncm91bmQtaW1hZ2U6IHVybCgnZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUhkcFpIUm9QU0kwTlNJZ2FHVnBaMmgwUFNJME5TSStQR2NnWm1sc2JEMGlibTl1WlNJZ1ptbHNiQzF5ZFd4bFBTSmxkbVZ1YjJSa0lpQnpkSEp2YTJVOUlpTXdNREFpSUhOMGNtOXJaUzEzYVdSMGFEMGlNUzQxSWlCemRISnZhMlV0YkdsdVpXTmhjRDBpY205MWJtUWlJSE4wY205clpTMXNhVzVsYW05cGJqMGljbTkxYm1RaVBqeG5JR1pwYkd3OUlpTm1abVlpSUhOMGNtOXJaUzFzYVc1bFkyRndQU0ppZFhSMElqNDhjR0YwYUNCa1BTSk5PU0F6Tm1NekxqTTVMUzQ1TnlBeE1DNHhNUzQwTXlBeE15NDFMVElnTXk0ek9TQXlMalF6SURFd0xqRXhJREV1TURNZ01UTXVOU0F5SURBZ01DQXhMalkxTGpVMElETWdNaTB1TmpndU9UY3RNUzQyTlM0NU9TMHpJQzQxTFRNdU16a3RMamszTFRFd0xqRXhMalEyTFRFekxqVXRNUzB6TGpNNUlERXVORFl0TVRBdU1URXVNRE10TVRNdU5TQXhMVEV1TXpVMExqUTVMVEl1TXpJekxqUTNMVE10TGpVZ01TNHpOVFF0TVM0NU5DQXpMVElnTXkweWVpSXZQanh3WVhSb0lHUTlJazB4TlNBek1tTXlMalVnTWk0MUlERXlMalVnTWk0MUlERTFJREFnTGpVdE1TNDFJREF0TWlBd0xUSWdNQzB5TGpVdE1pNDFMVFF0TWk0MUxUUWdOUzQxTFRFdU5TQTJMVEV4TGpVdE5TMHhOUzQxTFRFeElEUXRNVEF1TlNBeE5DMDFJREUxTGpVZ01DQXdMVEl1TlNBeExqVXRNaTQxSURRZ01DQXdMUzQxTGpVZ01DQXllaUl2UGp4d1lYUm9JR1E5SWsweU5TQTRZVEl1TlNBeUxqVWdNQ0F4SURFdE5TQXdJREl1TlNBeUxqVWdNQ0F4SURFZ05TQXdlaUl2UGp3dlp6NDhjR0YwYUNCa1BTSk5NVGN1TlNBeU5tZ3hNRTB4TlNBek1HZ3hOVzB0Tnk0MUxURTBMalYyTlUweU1DQXhPR2cxSWlCemRISnZhMlV0YkdsdVpXcHZhVzQ5SW0xcGRHVnlJaTgrUEM5blBqd3ZjM1puUGc9PScpO1xuXHR9XG5cdC5jZy1kZWZhdWx0LXN0eWxlLmNnLXdyYXAgOmdsb2JhbChwaWVjZS5rbmlnaHQud2hpdGUpIHtcblx0ICBiYWNrZ3JvdW5kLWltYWdlOiB1cmwoJ2RhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaUlIZHBaSFJvUFNJME5TSWdhR1ZwWjJoMFBTSTBOU0krUEdjZ1ptbHNiRDBpYm05dVpTSWdabWxzYkMxeWRXeGxQU0psZG1WdWIyUmtJaUJ6ZEhKdmEyVTlJaU13TURBaUlITjBjbTlyWlMxM2FXUjBhRDBpTVM0MUlpQnpkSEp2YTJVdGJHbHVaV05oY0QwaWNtOTFibVFpSUhOMGNtOXJaUzFzYVc1bGFtOXBiajBpY205MWJtUWlQanh3WVhSb0lHUTlJazB5TWlBeE1HTXhNQzQxSURFZ01UWXVOU0E0SURFMklESTVTREUxWXpBdE9TQXhNQzAyTGpVZ09DMHlNU0lnWm1sc2JEMGlJMlptWmlJdlBqeHdZWFJvSUdROUlrMHlOQ0F4T0dNdU16Z2dNaTQ1TVMwMUxqVTFJRGN1TXpjdE9DQTVMVE1nTWkweUxqZ3lJRFF1TXpRdE5TQTBMVEV1TURReUxTNDVOQ0F4TGpReExUTXVNRFFnTUMwekxURWdNQ0F1TVRrZ01TNHlNeTB4SURJdE1TQXdMVFF1TURBeklERXROQzAwSURBdE1pQTJMVEV5SURZdE1USnpNUzQ0T1MweExqa2dNaTB6TGpWakxTNDNNeTB1T1RrMExTNDFMVEl0TGpVdE15QXhMVEVnTXlBeUxqVWdNeUF5TGpWb01uTXVOemd0TVM0NU9USWdNaTQxTFROak1TQXdJREVnTXlBeElETWlJR1pwYkd3OUlpTm1abVlpTHo0OGNHRjBhQ0JrUFNKTk9TNDFJREkxTGpWaExqVXVOU0F3SURFZ01TMHhJREFnTGpVdU5TQXdJREVnTVNBeElEQjZiVFV1TkRNekxUa3VOelZoTGpVZ01TNDFJRE13SURFZ01TMHVPRFkyTFM0MUxqVWdNUzQxSURNd0lERWdNU0F1T0RZMkxqVjZJaUJtYVd4c1BTSWpNREF3SWk4K1BDOW5Qand2YzNablBnPT0nKTtcblx0fVxuXHQuY2ctZGVmYXVsdC1zdHlsZS5jZy13cmFwIDpnbG9iYWwocGllY2Uucm9vay53aGl0ZSkge1xuXHQgIGJhY2tncm91bmQtaW1hZ2U6IHVybCgnZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUhkcFpIUm9QU0kwTlNJZ2FHVnBaMmgwUFNJME5TSStQR2NnWm1sc2JEMGlJMlptWmlJZ1ptbHNiQzF5ZFd4bFBTSmxkbVZ1YjJSa0lpQnpkSEp2YTJVOUlpTXdNREFpSUhOMGNtOXJaUzEzYVdSMGFEMGlNUzQxSWlCemRISnZhMlV0YkdsdVpXTmhjRDBpY205MWJtUWlJSE4wY205clpTMXNhVzVsYW05cGJqMGljbTkxYm1RaVBqeHdZWFJvSUdROUlrMDVJRE01YURJM2RpMHpTRGwyTTNwdE15MHpkaTAwYURJeGRqUklNVEo2YlMweExUSXlWamxvTkhZeWFEVldPV2cxZGpKb05WWTVhRFIyTlNJZ2MzUnliMnRsTFd4cGJtVmpZWEE5SW1KMWRIUWlMejQ4Y0dGMGFDQmtQU0pOTXpRZ01UUnNMVE1nTTBneE5Hd3RNeTB6SWk4K1BIQmhkR2dnWkQwaVRUTXhJREUzZGpFeUxqVklNVFJXTVRjaUlITjBjbTlyWlMxc2FXNWxZMkZ3UFNKaWRYUjBJaUJ6ZEhKdmEyVXRiR2x1WldwdmFXNDlJbTFwZEdWeUlpOCtQSEJoZEdnZ1pEMGlUVE14SURJNUxqVnNNUzQxSURJdU5XZ3RNakJzTVM0MUxUSXVOU0l2UGp4d1lYUm9JR1E5SWsweE1TQXhOR2d5TXlJZ1ptbHNiRDBpYm05dVpTSWdjM1J5YjJ0bExXeHBibVZxYjJsdVBTSnRhWFJsY2lJdlBqd3ZaejQ4TDNOMlp6ND0nKTtcblx0fVxuXHQuY2ctZGVmYXVsdC1zdHlsZS5jZy13cmFwIDpnbG9iYWwocGllY2UucXVlZW4ud2hpdGUpIHtcblx0ICBiYWNrZ3JvdW5kLWltYWdlOiB1cmwoJ2RhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaUlIZHBaSFJvUFNJME5TSWdhR1ZwWjJoMFBTSTBOU0krUEdjZ1ptbHNiRDBpSTJabVppSWdabWxzYkMxeWRXeGxQU0psZG1WdWIyUmtJaUJ6ZEhKdmEyVTlJaU13TURBaUlITjBjbTlyWlMxM2FXUjBhRDBpTVM0MUlpQnpkSEp2YTJVdGJHbHVaV05oY0QwaWNtOTFibVFpSUhOMGNtOXJaUzFzYVc1bGFtOXBiajBpY205MWJtUWlQanh3WVhSb0lHUTlJazA0SURFeVlUSWdNaUF3SURFZ01TMDBJREFnTWlBeUlEQWdNU0F4SURRZ01IcHRNVFl1TlMwMExqVmhNaUF5SURBZ01TQXhMVFFnTUNBeUlESWdNQ0F4SURFZ05DQXdlazAwTVNBeE1tRXlJRElnTUNBeElERXROQ0F3SURJZ01pQXdJREVnTVNBMElEQjZUVEUySURndU5XRXlJRElnTUNBeElERXROQ0F3SURJZ01pQXdJREVnTVNBMElEQjZUVE16SURsaE1pQXlJREFnTVNBeExUUWdNQ0F5SURJZ01DQXhJREVnTkNBd2VpSXZQanh3WVhSb0lHUTlJazA1SURJMll6Z3VOUzB4TGpVZ01qRXRNUzQxSURJM0lEQnNNaTB4TWkwM0lERXhWakV4YkMwMUxqVWdNVE11TlMwekxURTFMVE1nTVRVdE5TNDFMVEUwVmpJMVREY2dNVFJzTWlBeE1ub2lJSE4wY205clpTMXNhVzVsWTJGd1BTSmlkWFIwSWk4K1BIQmhkR2dnWkQwaVRUa2dNalpqTUNBeUlERXVOU0F5SURJdU5TQTBJREVnTVM0MUlERWdNU0F1TlNBekxqVXRNUzQxSURFdE1TNDFJREl1TlMweExqVWdNaTQxTFRFdU5TQXhMalV1TlNBeUxqVXVOU0F5TGpVZ05pNDFJREVnTVRZdU5TQXhJREl6SURBZ01DQXdJREV1TlMweElEQXRNaTQxSURBZ01DQXVOUzB4TGpVdE1TMHlMalV0TGpVdE1pNDFMUzQxTFRJZ0xqVXRNeTQxSURFdE1pQXlMalV0TWlBeUxqVXROQzA0TGpVdE1TNDFMVEU0TGpVdE1TNDFMVEkzSURCNklpQnpkSEp2YTJVdGJHbHVaV05oY0QwaVluVjBkQ0l2UGp4d1lYUm9JR1E5SWsweE1TNDFJRE13WXpNdU5TMHhJREU0TGpVdE1TQXlNaUF3VFRFeUlETXpMalZqTmkweElERTFMVEVnTWpFZ01DSWdabWxzYkQwaWJtOXVaU0l2UGp3dlp6NDhMM04yWno0PScpO1xuXHR9XG5cdC5jZy1kZWZhdWx0LXN0eWxlLmNnLXdyYXAgOmdsb2JhbChwaWVjZS5raW5nLndoaXRlKSB7XG5cdCAgYmFja2dyb3VuZC1pbWFnZTogdXJsKCdkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUI0Yld4dWN6MGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNakF3TUM5emRtY2lJSGRwWkhSb1BTSTBOU0lnYUdWcFoyaDBQU0kwTlNJK1BHY2dabWxzYkQwaWJtOXVaU0lnWm1sc2JDMXlkV3hsUFNKbGRtVnViMlJrSWlCemRISnZhMlU5SWlNd01EQWlJSE4wY205clpTMTNhV1IwYUQwaU1TNDFJaUJ6ZEhKdmEyVXRiR2x1WldOaGNEMGljbTkxYm1RaUlITjBjbTlyWlMxc2FXNWxhbTlwYmowaWNtOTFibVFpUGp4d1lYUm9JR1E5SWsweU1pNDFJREV4TGpZelZqWk5NakFnT0dnMUlpQnpkSEp2YTJVdGJHbHVaV3B2YVc0OUltMXBkR1Z5SWk4K1BIQmhkR2dnWkQwaVRUSXlMalVnTWpWek5DNDFMVGN1TlNBekxURXdMalZqTUNBd0xURXRNaTQxTFRNdE1pNDFjeTB6SURJdU5TMHpJREl1TldNdE1TNDFJRE1nTXlBeE1DNDFJRE1nTVRBdU5TSWdabWxzYkQwaUkyWm1aaUlnYzNSeWIydGxMV3hwYm1WallYQTlJbUoxZEhRaUlITjBjbTlyWlMxc2FXNWxhbTlwYmowaWJXbDBaWElpTHo0OGNHRjBhQ0JrUFNKTk1URXVOU0F6TjJNMUxqVWdNeTQxSURFMUxqVWdNeTQxSURJeElEQjJMVGR6T1MwMExqVWdOaTB4TUM0MVl5MDBMVFl1TlMweE15NDFMVE11TlMweE5pQTBWakkzZGkwekxqVmpMVE11TlMwM0xqVXRNVE10TVRBdU5TMHhOaTAwTFRNZ05pQTFJREV3SURVZ01UQldNemQ2SWlCbWFXeHNQU0lqWm1abUlpOCtQSEJoZEdnZ1pEMGlUVEV4TGpVZ016QmpOUzQxTFRNZ01UVXVOUzB6SURJeElEQnRMVEl4SURNdU5XTTFMalV0TXlBeE5TNDFMVE1nTWpFZ01HMHRNakVnTXk0MVl6VXVOUzB6SURFMUxqVXRNeUF5TVNBd0lpOCtQQzluUGp3dmMzWm5QZz09Jyk7XG5cdH1cblx0LmNnLWRlZmF1bHQtc3R5bGUuY2ctd3JhcCA6Z2xvYmFsKHBpZWNlLnBhd24uYmxhY2spIHtcblx0ICBiYWNrZ3JvdW5kLWltYWdlOiB1cmwoJ2RhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaUlIZHBaSFJvUFNJME5TSWdhR1ZwWjJoMFBTSTBOU0krUEhCaGRHZ2daRDBpVFRJeUxqVWdPV010TWk0eU1TQXdMVFFnTVM0M09TMDBJRFFnTUNBdU9Ea3VNamtnTVM0M01TNDNPQ0F5TGpNNFF6RTNMak16SURFMkxqVWdNVFlnTVRndU5Ua2dNVFlnTWpGak1DQXlMakF6TGprMElETXVPRFFnTWk0ME1TQTFMakF6TFRNZ01TNHdOaTAzTGpReElEVXVOVFV0Tnk0ME1TQXhNeTQwTjJneU0yTXdMVGN1T1RJdE5DNDBNUzB4TWk0ME1TMDNMalF4TFRFekxqUTNJREV1TkRjdE1TNHhPU0F5TGpReExUTWdNaTQwTVMwMUxqQXpJREF0TWk0ME1TMHhMak16TFRRdU5TMHpMakk0TFRVdU5qSXVORGt0TGpZM0xqYzRMVEV1TkRrdU56Z3RNaTR6T0NBd0xUSXVNakV0TVM0M09TMDBMVFF0TkhvaUlITjBjbTlyWlQwaUl6QXdNQ0lnYzNSeWIydGxMWGRwWkhSb1BTSXhMalVpSUhOMGNtOXJaUzFzYVc1bFkyRndQU0p5YjNWdVpDSXZQand2YzNablBnPT0nKTtcblx0fVxuXHQuY2ctZGVmYXVsdC1zdHlsZS5jZy13cmFwIDpnbG9iYWwocGllY2UuYmlzaG9wLmJsYWNrKSB7XG5cdCAgYmFja2dyb3VuZC1pbWFnZTogdXJsKCdkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUI0Yld4dWN6MGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNakF3TUM5emRtY2lJSGRwWkhSb1BTSTBOU0lnYUdWcFoyaDBQU0kwTlNJK1BHY2dabWxzYkQwaWJtOXVaU0lnWm1sc2JDMXlkV3hsUFNKbGRtVnViMlJrSWlCemRISnZhMlU5SWlNd01EQWlJSE4wY205clpTMTNhV1IwYUQwaU1TNDFJaUJ6ZEhKdmEyVXRiR2x1WldOaGNEMGljbTkxYm1RaUlITjBjbTlyWlMxc2FXNWxhbTlwYmowaWNtOTFibVFpUGp4bklHWnBiR3c5SWlNd01EQWlJSE4wY205clpTMXNhVzVsWTJGd1BTSmlkWFIwSWo0OGNHRjBhQ0JrUFNKTk9TQXpObU16TGpNNUxTNDVOeUF4TUM0eE1TNDBNeUF4TXk0MUxUSWdNeTR6T1NBeUxqUXpJREV3TGpFeElERXVNRE1nTVRNdU5TQXlJREFnTUNBeExqWTFMalUwSURNZ01pMHVOamd1T1RjdE1TNDJOUzQ1T1MweklDNDFMVE11TXprdExqazNMVEV3TGpFeExqUTJMVEV6TGpVdE1TMHpMak01SURFdU5EWXRNVEF1TVRFdU1ETXRNVE11TlNBeExURXVNelUwTGpRNUxUSXVNekl6TGpRM0xUTXRMalVnTVM0ek5UUXRNUzQ1TkNBekxUSWdNeTB5ZWlJdlBqeHdZWFJvSUdROUlrMHhOU0F6TW1NeUxqVWdNaTQxSURFeUxqVWdNaTQxSURFMUlEQWdMalV0TVM0MUlEQXRNaUF3TFRJZ01DMHlMalV0TWk0MUxUUXRNaTQxTFRRZ05TNDFMVEV1TlNBMkxURXhMalV0TlMweE5TNDFMVEV4SURRdE1UQXVOU0F4TkMwMUlERTFMalVnTUNBd0xUSXVOU0F4TGpVdE1pNDFJRFFnTUNBd0xTNDFMalVnTUNBeWVpSXZQanh3WVhSb0lHUTlJazB5TlNBNFlUSXVOU0F5TGpVZ01DQXhJREV0TlNBd0lESXVOU0F5TGpVZ01DQXhJREVnTlNBd2VpSXZQand2Wno0OGNHRjBhQ0JrUFNKTk1UY3VOU0F5Tm1neE1FMHhOU0F6TUdneE5XMHROeTQxTFRFMExqVjJOVTB5TUNBeE9HZzFJaUJ6ZEhKdmEyVTlJaU5sWTJWalpXTWlJSE4wY205clpTMXNhVzVsYW05cGJqMGliV2wwWlhJaUx6NDhMMmMrUEM5emRtYysnKTtcblx0fVxuXHQuY2ctZGVmYXVsdC1zdHlsZS5jZy13cmFwIDpnbG9iYWwocGllY2Uua25pZ2h0LmJsYWNrKSB7XG5cdCAgYmFja2dyb3VuZC1pbWFnZTogdXJsKCdkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUI0Yld4dWN6MGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNakF3TUM5emRtY2lJSGRwWkhSb1BTSTBOU0lnYUdWcFoyaDBQU0kwTlNJK1BHY2dabWxzYkQwaWJtOXVaU0lnWm1sc2JDMXlkV3hsUFNKbGRtVnViMlJrSWlCemRISnZhMlU5SWlNd01EQWlJSE4wY205clpTMTNhV1IwYUQwaU1TNDFJaUJ6ZEhKdmEyVXRiR2x1WldOaGNEMGljbTkxYm1RaUlITjBjbTlyWlMxc2FXNWxhbTlwYmowaWNtOTFibVFpUGp4d1lYUm9JR1E5SWsweU1pQXhNR014TUM0MUlERWdNVFl1TlNBNElERTJJREk1U0RFMVl6QXRPU0F4TUMwMkxqVWdPQzB5TVNJZ1ptbHNiRDBpSXpBd01DSXZQanh3WVhSb0lHUTlJazB5TkNBeE9HTXVNemdnTWk0NU1TMDFMalUxSURjdU16Y3RPQ0E1TFRNZ01pMHlMamd5SURRdU16UXROU0EwTFRFdU1EUXlMUzQ1TkNBeExqUXhMVE11TURRZ01DMHpMVEVnTUNBdU1Ua2dNUzR5TXkweElESXRNU0F3TFRRdU1EQXpJREV0TkMwMElEQXRNaUEyTFRFeUlEWXRNVEp6TVM0NE9TMHhMamtnTWkwekxqVmpMUzQzTXkwdU9UazBMUzQxTFRJdExqVXRNeUF4TFRFZ015QXlMalVnTXlBeUxqVm9Nbk11TnpndE1TNDVPVElnTWk0MUxUTmpNU0F3SURFZ015QXhJRE1pSUdacGJHdzlJaU13TURBaUx6NDhjR0YwYUNCa1BTSk5PUzQxSURJMUxqVmhMalV1TlNBd0lERWdNUzB4SURBZ0xqVXVOU0F3SURFZ01TQXhJREI2YlRVdU5ETXpMVGt1TnpWaExqVWdNUzQxSURNd0lERWdNUzB1T0RZMkxTNDFMalVnTVM0MUlETXdJREVnTVNBdU9EWTJMalY2SWlCbWFXeHNQU0lqWldObFkyVmpJaUJ6ZEhKdmEyVTlJaU5sWTJWalpXTWlMejQ4Y0dGMGFDQmtQU0pOTWpRdU5UVWdNVEF1Tkd3dExqUTFJREV1TkRVdU5TNHhOV016TGpFMUlERWdOUzQyTlNBeUxqUTVJRGN1T1NBMkxqYzFVek0xTGpjMUlESTVMakEySURNMUxqSTFJRE01YkMwdU1EVXVOV2d5TGpJMWJDNHdOUzB1TldNdU5TMHhNQzR3TmkwdU9EZ3RNVFl1T0RVdE15NHlOUzB5TVM0ek5DMHlMak0zTFRRdU5Ea3ROUzQzT1MwMkxqWTBMVGt1TVRrdE55NHhObXd0TGpVeExTNHhlaUlnWm1sc2JEMGlJMlZqWldObFl5SWdjM1J5YjJ0bFBTSnViMjVsSWk4K1BDOW5Qand2YzNablBnPT0nKTtcblx0fVxuXHQuY2ctZGVmYXVsdC1zdHlsZS5jZy13cmFwIDpnbG9iYWwocGllY2Uucm9vay5ibGFjaykge1xuXHQgIGJhY2tncm91bmQtaW1hZ2U6IHVybCgnZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUhkcFpIUm9QU0kwTlNJZ2FHVnBaMmgwUFNJME5TSStQR2NnWm1sc2JDMXlkV3hsUFNKbGRtVnViMlJrSWlCemRISnZhMlU5SWlNd01EQWlJSE4wY205clpTMTNhV1IwYUQwaU1TNDFJaUJ6ZEhKdmEyVXRiR2x1WldOaGNEMGljbTkxYm1RaUlITjBjbTlyWlMxc2FXNWxhbTlwYmowaWNtOTFibVFpUGp4d1lYUm9JR1E5SWswNUlETTVhREkzZGkwelNEbDJNM3B0TXk0MUxUZHNNUzQxTFRJdU5XZ3hOMnd4TGpVZ01pNDFhQzB5TUhwdExTNDFJRFIyTFRSb01qRjJORWd4TW5vaUlITjBjbTlyWlMxc2FXNWxZMkZ3UFNKaWRYUjBJaTgrUEhCaGRHZ2daRDBpVFRFMElESTVMalYyTFRFemFERTNkakV6U0RFMGVpSWdjM1J5YjJ0bExXeHBibVZqWVhBOUltSjFkSFFpSUhOMGNtOXJaUzFzYVc1bGFtOXBiajBpYldsMFpYSWlMejQ4Y0dGMGFDQmtQU0pOTVRRZ01UWXVOVXd4TVNBeE5HZ3lNMnd0TXlBeUxqVklNVFI2VFRFeElERTBWamxvTkhZeWFEVldPV2cxZGpKb05WWTVhRFIyTlVneE1Yb2lJSE4wY205clpTMXNhVzVsWTJGd1BTSmlkWFIwSWk4K1BIQmhkR2dnWkQwaVRURXlJRE0xTGpWb01qRnRMVEl3TFRSb01UbHRMVEU0TFRKb01UZHRMVEUzTFRFemFERTNUVEV4SURFMGFESXpJaUJtYVd4c1BTSnViMjVsSWlCemRISnZhMlU5SWlObFkyVmpaV01pSUhOMGNtOXJaUzEzYVdSMGFEMGlNU0lnYzNSeWIydGxMV3hwYm1WcWIybHVQU0p0YVhSbGNpSXZQand2Wno0OEwzTjJaejQ9Jyk7XG5cdH1cblx0LmNnLWRlZmF1bHQtc3R5bGUuY2ctd3JhcCA6Z2xvYmFsKHBpZWNlLnF1ZWVuLmJsYWNrKSB7XG5cdCAgYmFja2dyb3VuZC1pbWFnZTogdXJsKCdkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUI0Yld4dWN6MGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNakF3TUM5emRtY2lJSGRwWkhSb1BTSTBOU0lnYUdWcFoyaDBQU0kwTlNJK1BHY2dabWxzYkMxeWRXeGxQU0psZG1WdWIyUmtJaUJ6ZEhKdmEyVTlJaU13TURBaUlITjBjbTlyWlMxM2FXUjBhRDBpTVM0MUlpQnpkSEp2YTJVdGJHbHVaV05oY0QwaWNtOTFibVFpSUhOMGNtOXJaUzFzYVc1bGFtOXBiajBpY205MWJtUWlQanhuSUhOMGNtOXJaVDBpYm05dVpTSStQR05wY21Oc1pTQmplRDBpTmlJZ1kzazlJakV5SWlCeVBTSXlMamMxSWk4K1BHTnBjbU5zWlNCamVEMGlNVFFpSUdONVBTSTVJaUJ5UFNJeUxqYzFJaTgrUEdOcGNtTnNaU0JqZUQwaU1qSXVOU0lnWTNrOUlqZ2lJSEk5SWpJdU56VWlMejQ4WTJseVkyeGxJR040UFNJek1TSWdZM2s5SWpraUlISTlJakl1TnpVaUx6NDhZMmx5WTJ4bElHTjRQU0l6T1NJZ1kzazlJakV5SWlCeVBTSXlMamMxSWk4K1BDOW5Qanh3WVhSb0lHUTlJazA1SURJMll6Z3VOUzB4TGpVZ01qRXRNUzQxSURJM0lEQnNNaTQxTFRFeUxqVk1NekVnTWpWc0xTNHpMVEUwTGpFdE5TNHlJREV6TGpZdE15MHhOQzQxTFRNZ01UUXVOUzAxTGpJdE1UTXVOa3d4TkNBeU5TQTJMalVnTVRNdU5TQTVJREkyZWlJZ2MzUnliMnRsTFd4cGJtVmpZWEE5SW1KMWRIUWlMejQ4Y0dGMGFDQmtQU0pOT1NBeU5tTXdJRElnTVM0MUlESWdNaTQxSURRZ01TQXhMalVnTVNBeElDNDFJRE11TlMweExqVWdNUzB4TGpVZ01pNDFMVEV1TlNBeUxqVXRNUzQxSURFdU5TNDFJREl1TlM0MUlESXVOU0EyTGpVZ01TQXhOaTQxSURFZ01qTWdNQ0F3SURBZ01TNDFMVEVnTUMweUxqVWdNQ0F3SUM0MUxURXVOUzB4TFRJdU5TMHVOUzB5TGpVdExqVXRNaUF1TlMwekxqVWdNUzB5SURJdU5TMHlJREl1TlMwMExUZ3VOUzB4TGpVdE1UZ3VOUzB4TGpVdE1qY2dNSG9pSUhOMGNtOXJaUzFzYVc1bFkyRndQU0ppZFhSMElpOCtQSEJoZEdnZ1pEMGlUVEV4SURNNExqVmhNelVnTXpVZ01TQXdJREFnTWpNZ01DSWdabWxzYkQwaWJtOXVaU0lnYzNSeWIydGxMV3hwYm1WallYQTlJbUoxZEhRaUx6NDhjR0YwYUNCa1BTSk5NVEVnTWpsaE16VWdNelVnTVNBd0lERWdNak1nTUcwdE1qRXVOU0F5TGpWb01qQnRMVEl4SUROaE16VWdNelVnTVNBd0lEQWdNaklnTUcwdE1qTWdNMkV6TlNBek5TQXhJREFnTUNBeU5DQXdJaUJtYVd4c1BTSnViMjVsSWlCemRISnZhMlU5SWlObFkyVmpaV01pTHo0OEwyYytQQzl6ZG1jKycpO1xuXHR9XG5cdC5jZy1kZWZhdWx0LXN0eWxlLmNnLXdyYXAgOmdsb2JhbChwaWVjZS5raW5nLmJsYWNrKSB7XG5cdCAgYmFja2dyb3VuZC1pbWFnZTogdXJsKCdkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUI0Yld4dWN6MGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNakF3TUM5emRtY2lJSGRwWkhSb1BTSTBOU0lnYUdWcFoyaDBQU0kwTlNJK1BHY2dabWxzYkQwaWJtOXVaU0lnWm1sc2JDMXlkV3hsUFNKbGRtVnViMlJrSWlCemRISnZhMlU5SWlNd01EQWlJSE4wY205clpTMTNhV1IwYUQwaU1TNDFJaUJ6ZEhKdmEyVXRiR2x1WldOaGNEMGljbTkxYm1RaUlITjBjbTlyWlMxc2FXNWxhbTlwYmowaWNtOTFibVFpUGp4d1lYUm9JR1E5SWsweU1pNDFJREV4TGpZelZqWWlJSE4wY205clpTMXNhVzVsYW05cGJqMGliV2wwWlhJaUx6NDhjR0YwYUNCa1BTSk5Nakl1TlNBeU5YTTBMalV0Tnk0MUlETXRNVEF1TldNd0lEQXRNUzB5TGpVdE15MHlMalZ6TFRNZ01pNDFMVE1nTWk0MVl5MHhMalVnTXlBeklERXdMalVnTXlBeE1DNDFJaUJtYVd4c1BTSWpNREF3SWlCemRISnZhMlV0YkdsdVpXTmhjRDBpWW5WMGRDSWdjM1J5YjJ0bExXeHBibVZxYjJsdVBTSnRhWFJsY2lJdlBqeHdZWFJvSUdROUlrMHhNUzQxSURNM1l6VXVOU0F6TGpVZ01UVXVOU0F6TGpVZ01qRWdNSFl0TjNNNUxUUXVOU0EyTFRFd0xqVmpMVFF0Tmk0MUxURXpMalV0TXk0MUxURTJJRFJXTWpkMkxUTXVOV010TXk0MUxUY3VOUzB4TXkweE1DNDFMVEUyTFRRdE15QTJJRFVnTVRBZ05TQXhNRll6TjNvaUlHWnBiR3c5SWlNd01EQWlMejQ4Y0dGMGFDQmtQU0pOTWpBZ09HZzFJaUJ6ZEhKdmEyVXRiR2x1WldwdmFXNDlJbTFwZEdWeUlpOCtQSEJoZEdnZ1pEMGlUVE15SURJNUxqVnpPQzQxTFRRZ05pNHdNeTA1TGpZMVF6TTBMakUxSURFMElESTFJREU0SURJeUxqVWdNalF1Tld3dU1ERWdNaTR4TFM0d01TMHlMakZETWpBZ01UZ2dPUzQ1TURZZ01UUWdOaTQ1T1RjZ01Ua3VPRFZqTFRJdU5EazNJRFV1TmpVZ05DNDROVE1nT1NBMExqZzFNeUE1SWlCemRISnZhMlU5SWlObFkyVmpaV01pTHo0OGNHRjBhQ0JrUFNKTk1URXVOU0F6TUdNMUxqVXRNeUF4TlM0MUxUTWdNakVnTUcwdE1qRWdNeTQxWXpVdU5TMHpJREUxTGpVdE15QXlNU0F3YlMweU1TQXpMalZqTlM0MUxUTWdNVFV1TlMweklESXhJREFpSUhOMGNtOXJaVDBpSTJWalpXTmxZeUl2UGp3dlp6NDhMM04yWno0PScpO1xuXHR9XG5cbjwvc3R5bGU+XG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFxV0EsQ0FBQyx1QkFBUSxDQUFDO0FBQ1YsSUFBSSxXQUFXO0FBQ2YsSUFBSSxlQUFlO0FBQ25COztBQUVBLEVBQUUsZ0NBQWdDO0FBQ2xDLElBQUksdUJBQVEsQ0FBQztBQUNiLE1BQU0saUJBQWlCO0FBQ3ZCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQSxDQUFDLGlCQUFpQix1QkFBUSxDQUFDO0FBQzNCLEdBQUcsdUJBQXVCO0FBQzFCLEdBQUcsa0JBQWtCO0FBQ3JCLEdBQUcsY0FBYztBQUNqQjs7QUFFQSxDQUFDLGdDQUFpQixDQUFTLFlBQWEsQ0FBQztBQUN6QyxHQUFHLGtCQUFrQjtBQUNyQixHQUFHLFdBQVc7QUFDZCxHQUFHLFlBQVk7QUFDZixHQUFHLGNBQWM7QUFDakIsR0FBRyxNQUFNO0FBQ1Q7O0FBRUEsQ0FBQyxnQ0FBaUIsQ0FBUyxRQUFTLENBQUM7QUFDckMsR0FBRyxrQkFBa0I7QUFDckIsR0FBRyxNQUFNO0FBQ1QsR0FBRyxPQUFPO0FBQ1YsR0FBRyxXQUFXO0FBQ2QsR0FBRyxZQUFZO0FBQ2YsR0FBRyx5QkFBeUI7QUFDNUIsR0FBRyxzQkFBc0I7QUFDekIsR0FBRyxxQkFBcUI7QUFDeEIsR0FBRyxpQkFBaUI7QUFDcEIsR0FBRyxjQUFjO0FBQ2pCLEdBQUcsc0JBQXNCO0FBQ3pCOztBQUVBLENBQUMsaUJBQWlCLFFBQVEsMkJBQVksQ0FBUyxRQUFTLENBQUM7QUFDekQsR0FBRyxlQUFlO0FBQ2xCOztBQUVBLENBQUMsZ0NBQWlCLENBQVMsZUFBZ0IsQ0FBQztBQUM1QyxHQUFHLGtCQUFrQjtBQUNyQixHQUFHLE1BQU07QUFDVCxHQUFHLE9BQU87QUFDVixHQUFHLFlBQVk7QUFDZixHQUFHLGFBQWE7QUFDaEIsR0FBRyxvQkFBb0I7QUFDdkI7O0FBRUEsQ0FBQyxnQ0FBaUIsQ0FBUyx5QkFBMEIsQ0FBQztBQUN0RCxHQUFHLG9CQUFvQjtBQUN2Qjs7QUFFQSxDQUFDLGdDQUFpQixDQUFTLHlCQUEwQixDQUFDO0FBQ3RELEdBQUcsc0JBQXNCO0FBQ3pCOztBQUVBLENBQUMsaUJBQWlCLHVCQUFRLENBQVMsS0FBTSxDQUFDO0FBQzFDLEdBQUcsa0JBQWtCO0FBQ3JCLEdBQUcsTUFBTTtBQUNULEdBQUcsT0FBTztBQUNWLEdBQUcsWUFBWTtBQUNmLEdBQUcsYUFBYTtBQUNoQixHQUFHLHNCQUFzQjtBQUN6QixHQUFHLFVBQVU7QUFDYixHQUFHLHNCQUFzQjtBQUN6QixHQUFHLG9CQUFvQjtBQUN2Qjs7QUFFQSxDQUFDLGdDQUFpQixDQUFTLHVCQUF3QixDQUFDO0FBQ3BELEdBQUcsWUFBWTtBQUNmO0FBQ0EsR0FBRyxzQkFBc0I7QUFDekI7O0FBRUEsQ0FBQyxnQ0FBaUIsQ0FBUyxVQUFXLENBQUM7QUFDdkMsR0FBRyxVQUFVO0FBQ2I7O0FBRUEsQ0FBQyxnQ0FBaUIsQ0FBUyxZQUFhLENBQUM7QUFDekMsR0FBRyxVQUFVO0FBQ2IsR0FBRyxZQUFZO0FBQ2Y7O0FBRUEsQ0FBQyxpQkFBaUIsdUJBQVEsQ0FBUyxXQUFZLENBQUM7QUFDaEQsR0FBRyxZQUFZO0FBQ2Y7O0FBRUEsQ0FBQyxpQkFBaUIsdUJBQVEsQ0FBUyxTQUFVLENBQUM7QUFDOUMsR0FBRyxnQkFBZ0I7QUFDbkIsR0FBRyxrQkFBa0I7QUFDckIsR0FBRyxRQUFRO0FBQ1gsR0FBRyxTQUFTO0FBQ1osR0FBRyxXQUFXO0FBQ2QsR0FBRyxZQUFZO0FBQ2YsR0FBRyxvQkFBb0I7QUFDdkIsR0FBRyxVQUFVO0FBQ2IsR0FBRyxZQUFZO0FBQ2Y7O0FBRUEsQ0FBQyxpQkFBaUIsdUJBQVEsQ0FBUyxjQUFlO0FBQ2xELENBQUMsaUJBQWlCLHVCQUFRLENBQVMsVUFBVztBQUM5QyxDQUFDLGlCQUFpQix1QkFBUSxDQUFTLGVBQWdCLENBQUM7QUFDcEQsR0FBRyxpQkFBaUI7QUFDcEIsR0FBRyxrQkFBa0I7QUFDckIsR0FBRyxRQUFRO0FBQ1gsR0FBRyxTQUFTO0FBQ1osR0FBRyxXQUFXO0FBQ2QsR0FBRyxZQUFZO0FBQ2YsR0FBRyxvQkFBb0I7QUFDdkI7O0FBRUEsQ0FBQyxpQkFBaUIsdUJBQVEsQ0FBUyxjQUFlLENBQUM7QUFDbkQsR0FBRyxVQUFVO0FBQ2I7O0FBRUEsQ0FBQyxpQkFBaUIsdUJBQVEsQ0FBUyxvQkFBcUIsQ0FBQztBQUN6RCxHQUFHLFlBQVk7QUFDZjs7QUFFQSxDQUFDLGlCQUFpQix1QkFBUSxDQUFTLFVBQVcsQ0FBQztBQUMvQyxHQUFHLGdCQUFnQjtBQUNuQixHQUFHLFlBQVk7QUFDZixHQUFHLFVBQVU7QUFDYjs7QUFFQSxDQUFDLGlCQUFpQix1QkFBUSxDQUFTLGVBQWdCLENBQUM7QUFDcEQ7QUFDQSxHQUFHLFVBQVU7QUFDYjs7QUFFQSxDQUFDLGlCQUFpQix1QkFBUSxDQUFTLG1CQUFvQixDQUFDO0FBQ3hELEdBQUcsaUJBQWlCO0FBQ3BCOztBQUVBLENBQUMsaUJBQWlCLHVCQUFRLENBQVMsTUFBTyxDQUFDO0FBQzNDLEdBQUcsa0JBQWtCO0FBQ3JCLEdBQUcsYUFBYTtBQUNoQixHQUFHLG9CQUFvQjtBQUN2QixHQUFHLFlBQVk7QUFDZixHQUFHLHVCQUF1QjtBQUMxQixHQUFHLGNBQWM7QUFDakI7O0FBRUEsQ0FBQyxpQkFBaUIsdUJBQVEsQ0FBUyxZQUFhLENBQUM7QUFDakQsR0FBRyxTQUFTO0FBQ1osR0FBRyxVQUFVO0FBQ2IsR0FBRyx5QkFBeUI7QUFDNUIsR0FBRyxZQUFZO0FBQ2YsR0FBRyxXQUFXO0FBQ2Q7O0FBRUEsQ0FBQyxpQkFBaUIsdUJBQVEsQ0FBUyxrQkFBbUIsQ0FBQztBQUN2RCxHQUFHLGlCQUFpQjtBQUNwQjs7QUFFQSxDQUFDLGlCQUFpQix1QkFBUSxDQUFTLGlCQUFrQixDQUFDO0FBQ3RELEdBQUcsV0FBVztBQUNkLEdBQUcscUJBQXFCO0FBQ3hCOztBQUVBLENBQUMsaUJBQWlCLHVCQUFRLENBQVMsWUFBYSxDQUFDO0FBQ2pELEdBQUcsWUFBWTtBQUNmLEdBQUcsVUFBVTtBQUNiLEdBQUcsY0FBYztBQUNqQixHQUFHLFdBQVc7QUFDZCxHQUFHLFlBQVk7QUFDZixHQUFHLHlCQUF5QjtBQUM1QixHQUFHLGtCQUFrQjtBQUNyQjs7QUFFQSxDQUFDLGlCQUFpQix1QkFBUSxDQUFTLGtCQUFtQixDQUFDO0FBQ3ZELEdBQUcsc0JBQXNCO0FBQ3pCOztBQUVBLENBQUMsaUJBQWlCLHVCQUFRLENBQVMsWUFBYSxDQUFDO0FBQ2pELEdBQUcsY0FBYztBQUNqQjs7QUFFQSxDQUFDLGlCQUFpQix1QkFBUSxDQUFTLGtCQUFtQixDQUFDO0FBQ3ZELEdBQUcsMEJBQTBCO0FBQzdCOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDLGdDQUFpQixDQUFTLFFBQVMsQ0FBQztBQUNyQyxHQUFHLHlCQUF5QjtBQUM1QixHQUFHLDI1QkFBMjVCO0FBQzk1Qjs7QUFFQTtBQUNBLENBQUMsZ0NBQWlCLENBQVMsZ0JBQWlCLENBQUM7QUFDN0MsR0FBRywyR0FBMkc7QUFDOUc7QUFDQSxDQUFDLGdDQUFpQixDQUFTLG1CQUFvQixDQUFDO0FBQ2hELEdBQUcsMkdBQTJHO0FBQzlHO0FBQ0EsQ0FBQyxnQ0FBaUIsQ0FBUyxtQkFBb0IsQ0FBQztBQUNoRCxHQUFHLHNGQUFzRjtBQUN6RjtBQUNBLENBQUMsZ0NBQWlCLENBQVMsc0JBQXVCLENBQUM7QUFDbkQsR0FBRyx1RkFBdUY7QUFDMUY7QUFDQSxDQUFDLGdDQUFpQixDQUFTLHNCQUF1QixDQUFDO0FBQ25ELEdBQUcsaUNBQWlDO0FBQ3BDO0FBQ0EsQ0FBQyxnQ0FBaUIsQ0FBUyx5QkFBMEIsQ0FBQztBQUN0RCxHQUFHLGlDQUFpQztBQUNwQztBQUNBLENBQUMsZ0NBQWlCLENBQVMsZ0JBQWlCLENBQUM7QUFDN0MsR0FBRyx5Q0FBeUM7QUFDNUM7QUFDQSxDQUFDLGdDQUFpQixDQUFTLGVBQWdCLENBQUM7QUFDNUMsR0FBRyx1Q0FBdUM7QUFDMUM7QUFDQSxDQUFDLGdDQUFpQixDQUFTLFlBQWEsQ0FBQztBQUN6QyxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLENBQUMsZ0NBQWlCLENBQVMsc0JBQXVCLENBQUM7QUFDbkQsR0FBRyx1Q0FBdUM7QUFDMUM7O0FBRUE7QUFDQSxDQUFDLGlCQUFpQixRQUFRLGlDQUFrQixDQUFTLGdDQUFpQztBQUN0RixDQUFDLGlCQUFpQixRQUFRLGlDQUFrQixDQUFTLGdDQUFpQztBQUN0RixDQUFDLGlCQUFpQixRQUFRLGlDQUFrQixDQUFTLG9DQUFxQztBQUMxRixDQUFDLGlCQUFpQixRQUFRLGlDQUFrQixDQUFTLG9DQUFxQyxDQUFDO0FBQzNGLEdBQUcsNEJBQTRCO0FBQy9COztBQUVBLENBQUMsaUJBQWlCLFFBQVEsaUNBQWtCLENBQVMsZ0NBQWlDO0FBQ3RGLENBQUMsaUJBQWlCLFFBQVEsaUNBQWtCLENBQVMsZ0NBQWlDO0FBQ3RGLENBQUMsaUJBQWlCLFFBQVEsaUNBQWtCLENBQVMsb0NBQXFDO0FBQzFGLENBQUMsaUJBQWlCLFFBQVEsaUNBQWtCLENBQVMsb0NBQXFDLENBQUM7QUFDM0YsR0FBRywrQkFBK0I7QUFDbEM7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDLGlCQUFpQix1QkFBUSxDQUFTLGdCQUFpQixDQUFDO0FBQ3JELEdBQUcsK2tCQUEra0I7QUFDbGxCO0FBQ0EsQ0FBQyxpQkFBaUIsdUJBQVEsQ0FBUyxrQkFBbUIsQ0FBQztBQUN2RCxHQUFHLG0rQkFBbStCO0FBQ3QrQjtBQUNBLENBQUMsaUJBQWlCLHVCQUFRLENBQVMsa0JBQW1CLENBQUM7QUFDdkQsR0FBRyxtMUJBQW0xQjtBQUN0MUI7QUFDQSxDQUFDLGlCQUFpQix1QkFBUSxDQUFTLGdCQUFpQixDQUFDO0FBQ3JELEdBQUcsMnJCQUEyckI7QUFDOXJCO0FBQ0EsQ0FBQyxpQkFBaUIsdUJBQVEsQ0FBUyxpQkFBa0IsQ0FBQztBQUN0RCxHQUFHLDJrQ0FBMmtDO0FBQzlrQztBQUNBLENBQUMsaUJBQWlCLHVCQUFRLENBQVMsZ0JBQWlCLENBQUM7QUFDckQsR0FBRywyMkJBQTIyQjtBQUM5MkI7QUFDQSxDQUFDLGlCQUFpQix1QkFBUSxDQUFTLGdCQUFpQixDQUFDO0FBQ3JELEdBQUcsK2pCQUErakI7QUFDbGtCO0FBQ0EsQ0FBQyxpQkFBaUIsdUJBQVEsQ0FBUyxrQkFBbUIsQ0FBQztBQUN2RCxHQUFHLHUvQkFBdS9CO0FBQzEvQjtBQUNBLENBQUMsaUJBQWlCLHVCQUFRLENBQVMsa0JBQW1CLENBQUM7QUFDdkQsR0FBRywybkNBQTJuQztBQUM5bkM7QUFDQSxDQUFDLGlCQUFpQix1QkFBUSxDQUFTLGdCQUFpQixDQUFDO0FBQ3JELEdBQUcsdXpCQUF1ekI7QUFDMXpCO0FBQ0EsQ0FBQyxpQkFBaUIsdUJBQVEsQ0FBUyxpQkFBa0IsQ0FBQztBQUN0RCxHQUFHLDJ2Q0FBMnZDO0FBQzl2QztBQUNBLENBQUMsaUJBQWlCLHVCQUFRLENBQVMsZ0JBQWlCLENBQUM7QUFDckQsR0FBRyx1bkNBQXVuQztBQUMxbkMiLCJpZ25vcmVMaXN0IjpbXX0= */"
};
function Chessground_1($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, Chessground_1);
  append_styles($$anchor, $$css);
  var $$ownership_validator = create_ownership_validator($$props);
  let className = prop($$props, "class", 8, "cg-default-style");
  let fen = prop($$props, "fen", 8, void 0);
  let orientation = prop($$props, "orientation", 8, void 0);
  let turnColor = prop($$props, "turnColor", 8, void 0);
  let check = prop($$props, "check", 8, void 0);
  let lastMove = prop($$props, "lastMove", 8, void 0);
  let selected = prop($$props, "selected", 8, void 0);
  let coordinates = prop($$props, "coordinates", 8, void 0);
  let autoCastle = prop($$props, "autoCastle", 8, void 0);
  let viewOnly = prop($$props, "viewOnly", 8, void 0);
  let disableContextMenu = prop($$props, "disableContextMenu", 8, void 0);
  let addPieceZIndex = prop($$props, "addPieceZIndex", 8, void 0);
  let addDimensionsCssVarsTo = prop($$props, "addDimensionsCssVarsTo", 8, void 0);
  let blockTouchScroll = prop($$props, "blockTouchScroll", 8, void 0);
  let config = prop($$props, "config", 28, () => ({}));
  let container = mutable_source();
  let chessground;
  onMount(async () => {
    if (strict_equals(orientation(), void 0, false)) $$ownership_validator.mutation(null, ["config", "orientation"], config(config().orientation = orientation(), true), 144, 46);
    if (strict_equals(fen(), void 0, false)) $$ownership_validator.mutation(null, ["config", "fen"], config(config().fen = fen(), true), 145, 46);
    if (strict_equals(turnColor(), void 0, false)) $$ownership_validator.mutation(null, ["config", "turnColor"], config(config().turnColor = turnColor(), true), 146, 46);
    if (strict_equals(check(), void 0, false)) $$ownership_validator.mutation(null, ["config", "check"], config(config().check = check(), true), 147, 46);
    if (strict_equals(lastMove(), void 0, false)) $$ownership_validator.mutation(null, ["config", "lastMove"], config(config().lastMove = lastMove(), true), 148, 46);
    if (strict_equals(selected(), void 0, false)) $$ownership_validator.mutation(null, ["config", "selected"], config(config().selected = selected(), true), 149, 46);
    if (strict_equals(coordinates(), void 0, false)) $$ownership_validator.mutation(null, ["config", "coordinates"], config(config().coordinates = coordinates(), true), 150, 46);
    if (strict_equals(autoCastle(), void 0, false)) $$ownership_validator.mutation(null, ["config", "autoCastle"], config(config().autoCastle = autoCastle(), true), 151, 46);
    if (strict_equals(viewOnly(), void 0, false)) $$ownership_validator.mutation(null, ["config", "viewOnly"], config(config().viewOnly = viewOnly(), true), 152, 46);
    if (strict_equals(disableContextMenu(), void 0, false)) $$ownership_validator.mutation(null, ["config", "disableContextMenu"], config(config().disableContextMenu = disableContextMenu(), true), 153, 46);
    if (strict_equals(addPieceZIndex(), void 0, false)) $$ownership_validator.mutation(null, ["config", "addPieceZIndex"], config(config().addPieceZIndex = addPieceZIndex(), true), 154, 46);
    if (strict_equals(addDimensionsCssVarsTo(), void 0, false)) $$ownership_validator.mutation(null, ["config", "addDimensionsCssVarsTo"], config(config().addDimensionsCssVarsTo = addDimensionsCssVarsTo(), true), 155, 46);
    if (strict_equals(blockTouchScroll(), void 0, false)) $$ownership_validator.mutation(null, ["config", "blockTouchScroll"], config(config().blockTouchScroll = blockTouchScroll(), true), 156, 46);
    chessground = Chessground(get(container), config());
  });
  function setConfig(config2) {
    if (chessground) {
      chessground.set(config2);
    }
  }
  function set2(config2) {
    chessground.set(config2);
  }
  function getState() {
    return chessground.state;
  }
  function getFen() {
    return chessground.getFen();
  }
  function toggleOrientation2() {
    return chessground.toggleOrientation();
  }
  function move3(orig, dest) {
    return chessground.move(orig, dest);
  }
  function setPieces2(pieces) {
    return chessground.setPieces(pieces);
  }
  function selectSquare2(key, force) {
    return chessground.selectSquare(key, force);
  }
  function newPiece(piece, key) {
    return chessground.newPiece(piece, key);
  }
  function playPremove2() {
    return chessground.playPremove();
  }
  function cancelPremove() {
    chessground.cancelPremove();
  }
  function playPredrop2(validate) {
    return chessground.playPredrop(validate);
  }
  function cancelPredrop() {
    chessground.cancelPredrop();
  }
  function cancelMove2() {
    chessground.cancelMove();
  }
  function stop2() {
    chessground.stop();
  }
  function explode(keys) {
    chessground.explode(keys);
  }
  function setShapes(shapes) {
    chessground.setShapes(shapes);
  }
  function setAutoShapes(shapes) {
    chessground.setAutoShapes(shapes);
  }
  function redrawAll() {
    return chessground.redrawAll();
  }
  function dragNewPiece2(piece, event2, force) {
    chessground.dragNewPiece(piece, event2, force);
  }
  function destroy() {
    return chessground.destroy();
  }
  legacy_pre_effect(() => deep_read_state(fen()), () => {
    setConfig({ fen: fen() });
  });
  legacy_pre_effect(() => deep_read_state(orientation()), () => {
    setConfig({ orientation: orientation() });
  });
  legacy_pre_effect(() => deep_read_state(turnColor()), () => {
    setConfig({ turnColor: turnColor() });
  });
  legacy_pre_effect(() => deep_read_state(check()), () => {
    setConfig({ check: check() });
  });
  legacy_pre_effect(() => deep_read_state(lastMove()), () => {
    setConfig({ lastMove: lastMove() });
  });
  legacy_pre_effect(() => deep_read_state(selected()), () => {
    setConfig({ selected: selected() });
  });
  legacy_pre_effect(() => deep_read_state(coordinates()), () => {
    setConfig({ coordinates: coordinates() });
  });
  legacy_pre_effect(() => deep_read_state(autoCastle()), () => {
    setConfig({ autoCastle: autoCastle() });
  });
  legacy_pre_effect(() => deep_read_state(viewOnly()), () => {
    setConfig({ viewOnly: viewOnly() });
  });
  legacy_pre_effect(() => deep_read_state(disableContextMenu()), () => {
    setConfig({ disableContextMenu: disableContextMenu() });
  });
  legacy_pre_effect(() => deep_read_state(addPieceZIndex()), () => {
    setConfig({ addPieceZIndex: addPieceZIndex() });
  });
  legacy_pre_effect(() => deep_read_state(addDimensionsCssVarsTo()), () => {
    setConfig({ addDimensionsCssVarsTo: addDimensionsCssVarsTo() });
  });
  legacy_pre_effect(() => deep_read_state(blockTouchScroll()), () => {
    setConfig({ blockTouchScroll: blockTouchScroll() });
  });
  legacy_pre_effect(() => deep_read_state(config()), () => {
    setConfig(config());
  });
  legacy_pre_effect_reset();
  var $$exports = {
    get set() {
      return set2;
    },
    get getState() {
      return getState;
    },
    get getFen() {
      return getFen;
    },
    get toggleOrientation() {
      return toggleOrientation2;
    },
    get move() {
      return move3;
    },
    get setPieces() {
      return setPieces2;
    },
    get selectSquare() {
      return selectSquare2;
    },
    get newPiece() {
      return newPiece;
    },
    get playPremove() {
      return playPremove2;
    },
    get cancelPremove() {
      return cancelPremove;
    },
    get playPredrop() {
      return playPredrop2;
    },
    get cancelPredrop() {
      return cancelPredrop;
    },
    get cancelMove() {
      return cancelMove2;
    },
    get stop() {
      return stop2;
    },
    get explode() {
      return explode;
    },
    get setShapes() {
      return setShapes;
    },
    get setAutoShapes() {
      return setAutoShapes;
    },
    get redrawAll() {
      return redrawAll;
    },
    get dragNewPiece() {
      return dragNewPiece2;
    },
    get destroy() {
      return destroy;
    },
    ...legacy_api()
  };
  init();
  var div = root();
  bind_this(div, ($$value) => set(container, $$value), () => get(container));
  template_effect(() => set_class(div, 1, `cg-wrap ${className() ?? ""}`, "s-SUgnUE_f2Lao"));
  append($$anchor, div);
  bind_prop($$props, "set", set2);
  bind_prop($$props, "getState", getState);
  bind_prop($$props, "getFen", getFen);
  bind_prop($$props, "toggleOrientation", toggleOrientation2);
  bind_prop($$props, "move", move3);
  bind_prop($$props, "setPieces", setPieces2);
  bind_prop($$props, "selectSquare", selectSquare2);
  bind_prop($$props, "newPiece", newPiece);
  bind_prop($$props, "playPremove", playPremove2);
  bind_prop($$props, "cancelPremove", cancelPremove);
  bind_prop($$props, "playPredrop", playPredrop2);
  bind_prop($$props, "cancelPredrop", cancelPredrop);
  bind_prop($$props, "cancelMove", cancelMove2);
  bind_prop($$props, "stop", stop2);
  bind_prop($$props, "explode", explode);
  bind_prop($$props, "setShapes", setShapes);
  bind_prop($$props, "setAutoShapes", setAutoShapes);
  bind_prop($$props, "redrawAll", redrawAll);
  bind_prop($$props, "dragNewPiece", dragNewPiece2);
  bind_prop($$props, "destroy", destroy);
  return pop($$exports);
}
if (import.meta.hot) {
  Chessground_1 = hmr(Chessground_1);
  import.meta.hot.accept((module) => {
    cleanup_styles("s-SUgnUE_f2Lao");
    Chessground_1[HMR].update(module.default);
  });
}
var Chessground_default = Chessground_1;

// node_modules/svelte-chessground/dist/ChessgroundUnstyled.svelte
ChessgroundUnstyled[FILENAME] = "node_modules/svelte-chessground/dist/ChessgroundUnstyled.svelte";
var root2 = add_locations(from_html(`<div></div>`), ChessgroundUnstyled[FILENAME], [[356, 0]]);
var $$css2 = {
  hash: "s-ksQhaDfsNdf3",
  code: "\n\n .cg-wrap.s-ksQhaDfsNdf3 {\n    width: 100%;\n    aspect-ratio: 1;\n  }\n\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ2hlc3Nncm91bmRVbnN0eWxlZC5zdmVsdGUiLCJzb3VyY2VzIjpbIkNoZXNzZ3JvdW5kVW5zdHlsZWQuc3ZlbHRlIl0sInNvdXJjZXNDb250ZW50IjpbIjxzY3JpcHQ+XG5cdC8vIFRoaXMgZmlsZSB3YXMgZ2VuZXJhdGVkIGJ5IGdlbmVyYXRlX3Vuc3R5bGVkLnBsXG5cdFxuXHRpbXBvcnQgeyBDaGVzc2dyb3VuZCB9IGZyb20gJ2NoZXNzZ3JvdW5kJztcblxuXHRpbXBvcnQgeyBvbk1vdW50IH0gZnJvbSAnc3ZlbHRlJztcblxuXG5cdC8qKlxuXHQgKlxuXHQgKiBFeHBvcnRlZCBwcm9wcy5cblx0ICogQWxsIGV4cG9ydGVkIHByb3BzIGFyZSByZWFjdGl2ZSBhbmQgY2FuIGJlIHNldCBkaXJlY3RseSBvciB2aWEgdGhlIGNvbmZpZyBvYmplY3QuXG5cdCAqIENhbm5vdCBiZSBib3VuZCwgdXNlIGNhbGxiYWNrIGZ1bmN0aW9ucyB2aWEgdGhlIFwiZXZlbnRzXCIgb2JqZWN0cyB0byBtb25pdG9yIHN0YXRlLlxuXHQgKlxuXHQgKiBBbGwgc2ltcGxlLXZhbHVlZCBDaGVzc2dyb3VuZCBwYXJhbWV0ZXJzIGhhdmUgdGhlaXIgb3duIHByb3BzLiBUaGUgb3RoZXJzIG11c3QgYmUgc2V0IHZpYSB0aGUgY29uZmlnIHByb3AgYW5kIGFyZTpcblx0ICogICAgIGhpZ2hsaWdodCwgYW5pbWF0aW9uLCBtb3ZhYmxlLCBwcmVtb3ZhYmxlLCBwcmVkcm9wcGFibGUsIGRyYWdnYWJsZSwgc2VsZWN0YWJsZSwgZXZlbnRzLCBkcmF3YWJsZVxuXHQgKiBcblx0ICogRGV2IG5vdGU6IFRoZXNlIHByb3BzIHdvdWxkIHByZWZlcnJhYmx5IGhhdmUgYmVlbiBpbXBsZW1lbnRlZCB3aXRoICQkcHJvcHMgb3IgYSBwcmVwcm9jZXNzb3IsIGJ1dCBkb2luZyBzbyB3b3VsZCBsb3NlIFR5cGVzY3JpcHQgY29tcGlsZS10aW1lIGNoZWNrcy5cblx0ICovXG5cblx0LyoqXG5cdCAqIENTUyBjbGFzcyBuYW1lIGFwcGxpZWQgdG8gd3JhcHBpbmcgZGl2LiBTZXQgdGhpcyB0byBhcHBseSBhbm90aGVyXG5cdCAqIHN0eWxlc2hlZXQgdGhhbiB0aGUgZGVmYXVsdC5cblx0ICogQHR5cGUge3N0cmluZ31cblx0ICovXG5cdGxldCBjbGFzc05hbWUgPSAnY2ctZGVmYXVsdC1zdHlsZSc7XG5cdGV4cG9ydCB7IGNsYXNzTmFtZSBhcyBjbGFzcyB9O1xuXG5cdC8qKiBcblx0ICogQ2hlc3MgcG9zaXRpb24gaW4gRm9yc3l0aC1FZHdhcmRzIG5vdGF0aW9uLlxuXHQgKiBAdHlwZSB7aW1wb3J0KCdjaGVzc2dyb3VuZC90eXBlcycpLkZFTiB8IHVuZGVmaW5lZH1cblx0ICovXG5cdGV4cG9ydCBsZXQgZmVuID0gdW5kZWZpbmVkO1xuXHQkOiBzZXRDb25maWcoIHsgZmVuOiBmZW4gfSApO1xuXG5cdC8qKlxuXHQgKiBCb2FyZCBvcmllbnRhdGlvbjogd2hpdGUgb3IgYmxhY2suXG5cdCAqIEB0eXBlIHtpbXBvcnQoJ2NoZXNzZ3JvdW5kL3R5cGVzJykuQ29sb3IgfCB1bmRlZmluZWR9XG5cdCAqL1xuXHRleHBvcnQgbGV0IG9yaWVudGF0aW9uID0gdW5kZWZpbmVkO1xuXHQkOiBzZXRDb25maWcoIHsgb3JpZW50YXRpb246IG9yaWVudGF0aW9uIH0gKTtcblxuXHQvKipcblx0ICogU2lkZSB0byBwbGF5OiB3aGl0ZSBvciBibGFjay5cblx0ICogQHR5cGUge2ltcG9ydCgnY2hlc3Nncm91bmQvdHlwZXMnKS5Db2xvciB8IHVuZGVmaW5lZH1cblx0ICovXG5cdGV4cG9ydCBsZXQgdHVybkNvbG9yID0gdW5kZWZpbmVkO1xuXHQkOiBzZXRDb25maWcoIHsgdHVybkNvbG9yOiB0dXJuQ29sb3IgfSApO1xuXG5cdC8qKlxuXHQgKiBDb2xvciBpbiBjaGVjaywgZm9yIGhpZ2hsaWdodGluZyB0aGUgc3F1YXJlLiBUcnVlIGZvciB0aGUgY3VycmVudFxuXHQgKiBjb2xvciwgb3IgZmFsc2UgdG8gdW5zZXQuXG5cdCAqIEB0eXBlIHtpbXBvcnQoJ2NoZXNzZ3JvdW5kL3R5cGVzJykuQ29sb3IgfCBib29sZWFuIHwgdW5kZWZpbmVkfVxuXHQgKi9cblx0ZXhwb3J0IGxldCBjaGVjayA9IHVuZGVmaW5lZDtcblx0JDogc2V0Q29uZmlnKCB7IGNoZWNrOiBjaGVjayB9ICk7XG5cblx0LyoqXG5cdCAqIFNxdWFyZXMgb2YgdGhlIGxhc3QgbW92ZSwgZm9yIGhpZ2hsaWdodGluZy5cblx0ICogQHR5cGUge2ltcG9ydCgnY2hlc3Nncm91bmQvdHlwZXMnKS5LZXlbXSB8IHVuZGVmaW5lZH1cblx0ICovXG5cdGV4cG9ydCBsZXQgbGFzdE1vdmUgPSB1bmRlZmluZWQ7XG5cdCQ6IHNldENvbmZpZyggeyBsYXN0TW92ZTogbGFzdE1vdmUgfSApO1xuXG5cdC8qKlxuXHQgKiBTcXVhcmUgY3VycmVudGx5IHNlbGVjdGVkLlxuXHQgKiBAdHlwZSB7aW1wb3J0KCdjaGVzc2dyb3VuZC90eXBlcycpLktleSB8IHVuZGVmaW5lZH1cblx0ICovXG5cdGV4cG9ydCBsZXQgc2VsZWN0ZWQgPSB1bmRlZmluZWQ7XG5cdCQ6IHNldENvbmZpZyggeyBzZWxlY3RlZDogc2VsZWN0ZWQgfSApO1xuXG5cdC8qKlxuXHQgKiBEcmF3IGJvYXJkIGNvb3JkaW5hdGVzIChhLWgsIDEtOCkuXG5cdCAqIEB0eXBlIHtib29sZWFuIHwgdW5kZWZpbmVkfVxuXHQgKi9cblx0ZXhwb3J0IGxldCBjb29yZGluYXRlcyA9IHVuZGVmaW5lZDtcblx0JDogc2V0Q29uZmlnKCB7IGNvb3JkaW5hdGVzOiBjb29yZGluYXRlcyB9ICk7XG5cblx0LyoqXG5cdCAqIEltbWVkaWF0ZWx5IGNvbXBsZXRlIGNhc3RsaW5nIGJ5IG1vdmluZyB0aGUgcm9vayBhZnRlciB0aGUga2luZyBtb3ZlLlxuXHQgKiBAdHlwZSB7Ym9vbGVhbiB8IHVuZGVmaW5lZH1cblx0ICovXG5cdGV4cG9ydCBsZXQgYXV0b0Nhc3RsZSA9IHVuZGVmaW5lZDtcblx0JDogc2V0Q29uZmlnKCB7IGF1dG9DYXN0bGU6IGF1dG9DYXN0bGUgfSApO1xuXG5cdC8qKlxuXHQgKiBEb24ndCBiaW5kIGV2ZW50czogdGhlIHVzZXIgd2lsbCBuZXZlciBiZSBhYmxlIHRvIG1vdmUgcGllY2VzIGFyb3VuZC5cblx0ICogQHR5cGUge2Jvb2xlYW4gfCB1bmRlZmluZWR9XG5cdCAqL1xuXHRleHBvcnQgbGV0IHZpZXdPbmx5ID0gdW5kZWZpbmVkO1xuXHQkOiBzZXRDb25maWcoIHsgdmlld09ubHk6IHZpZXdPbmx5IH0gKTtcblxuXHQvKipcblx0ICogRGlzYWJsZSB0aGUgcmlnaHQtY2xpY2sgY29udGV4dCBtZW51LlxuXHQgKiBAdHlwZSB7Ym9vbGVhbiB8IHVuZGVmaW5lZH1cblx0ICovXG5cdGV4cG9ydCBsZXQgZGlzYWJsZUNvbnRleHRNZW51ID0gdW5kZWZpbmVkO1xuXHQkOiBzZXRDb25maWcoIHsgZGlzYWJsZUNvbnRleHRNZW51OiBkaXNhYmxlQ29udGV4dE1lbnUgfSApO1xuXG5cdC8qKlxuXHQgKiBBZGQgei1pbmRleCB0byBwaWVjZXMgKGZvciAzRCkuXG5cdCAqIEB0eXBlIHtib29sZWFuIHwgdW5kZWZpbmVkfVxuXHQgKi9cblx0ZXhwb3J0IGxldCBhZGRQaWVjZVpJbmRleCA9IHVuZGVmaW5lZDtcblx0JDogc2V0Q29uZmlnKCB7IGFkZFBpZWNlWkluZGV4OiBhZGRQaWVjZVpJbmRleCB9ICk7XG5cblx0LyoqXG5cdCAqIEFkZCAtLWNnLXdpZHRoIGFuZCAtLWNnLWhlaWdodCBDU1MgdmFycyBjb250YWluaW5nIHRoZSBib2FyZCdzIGRpbWVuc2lvbnMgdG8gdGhpcyBlbGVtZW50LlxuXHQgKiBAdHlwZSB7SFRNTEVsZW1lbnQgfCB1bmRlZmluZWR9XG5cdCAqL1xuXHRleHBvcnQgbGV0IGFkZERpbWVuc2lvbnNDc3NWYXJzVG8gPSB1bmRlZmluZWQ7XG5cdCQ6IHNldENvbmZpZyggeyBhZGREaW1lbnNpb25zQ3NzVmFyc1RvOiBhZGREaW1lbnNpb25zQ3NzVmFyc1RvIH0gKTtcblxuXHQvKipcblx0ICogQmxvY2sgc2Nyb2xsaW5nIHZpYSB0b3VjaCBkcmFnZ2luZyBvbiB0aGUgYm9hcmQsIGUuZy4gZm9yIGNvb3JkaW5hdGUgdHJhaW5pbmdcblx0ICogQHR5cGUge2Jvb2xlYW4gfCB1bmRlZmluZWR9XG5cdCAqL1xuXHRleHBvcnQgbGV0IGJsb2NrVG91Y2hTY3JvbGwgPSB1bmRlZmluZWQ7XG5cdCQ6IHNldENvbmZpZyggeyBibG9ja1RvdWNoU2Nyb2xsOiBibG9ja1RvdWNoU2Nyb2xsIH0gKTtcblxuXHQvKipcblx0ICogQ2hlc3Nncm91bmQgY29uZmlndXJhdGlvbi4gVGhlIGNvbmZpZyBwcm9wIGNhbiBiZSB1c2VkIHRvIHNldCBhbnkgXG5cdCAqIGNvbmZpZyBrZXlzLCBhbmQgaXMgbmVlZGVkIHRvIHNldCBjb25maWcga2V5cyB0aGF0IGxhY2sgb3duXG5cdCAqIHByb3BzOiBoaWdobGlnaHQsIGFuaW1hdGlvbiwgbW92YWJsZSwgcHJlbW92YWJsZSwgcHJlZHJvcHBhYmxlLFxuXHQgKiBkcmFnZ2FibGUsIHNlbGVjdGFibGUsIGV2ZW50cyBhbmQgZHJhd2FibGUuXG5cdCAqIGh0dHBzOi8vZ2l0aHViLmNvbS9saWNoZXNzLW9yZy9jaGVzc2dyb3VuZC9ibG9iL21hc3Rlci9zcmMvYXBpLnRzXG5cdCAqIEB0eXBlIHtpbXBvcnQoJ2NoZXNzZ3JvdW5kL2NvbmZpZycpLkNvbmZpZ31cblx0ICovXG5cdGV4cG9ydCBsZXQgY29uZmlnID0ge307XG5cdCQ6IHNldENvbmZpZyggY29uZmlnICk7XG5cblxuXHQvKipcblx0ICpcblx0ICogXG5cdCAqIFxuXHQgKi9cblxuXHQvKiogQHR5cGUge0hUTUxEaXZFbGVtZW50fSAqL1xuXHRsZXQgY29udGFpbmVyO1xuXG5cdC8qKiBAdHlwZSB7aW1wb3J0KCdjaGVzc2dyb3VuZC9hcGknKS5BcGl9ICovXG5cdGxldCBjaGVzc2dyb3VuZDtcblxuXHRvbk1vdW50KGFzeW5jICgpID0+IHtcblx0XHRpZiAoIG9yaWVudGF0aW9uICAgICAgICAgICAgIT09IHVuZGVmaW5lZCApIGNvbmZpZy5vcmllbnRhdGlvbiA9IG9yaWVudGF0aW9uO1xuXHRcdGlmICggZmVuICAgICAgICAgICAgICAgICAgICAhPT0gdW5kZWZpbmVkICkgY29uZmlnLmZlbiA9IGZlbjtcblx0XHRpZiAoIHR1cm5Db2xvciAgICAgICAgICAgICAgIT09IHVuZGVmaW5lZCApIGNvbmZpZy50dXJuQ29sb3IgPSB0dXJuQ29sb3I7XG5cdFx0aWYgKCBjaGVjayAgICAgICAgICAgICAgICAgICE9PSB1bmRlZmluZWQgKSBjb25maWcuY2hlY2sgPSBjaGVjaztcblx0XHRpZiAoIGxhc3RNb3ZlICAgICAgICAgICAgICAgIT09IHVuZGVmaW5lZCApIGNvbmZpZy5sYXN0TW92ZSA9IGxhc3RNb3ZlO1xuXHRcdGlmICggc2VsZWN0ZWQgICAgICAgICAgICAgICAhPT0gdW5kZWZpbmVkICkgY29uZmlnLnNlbGVjdGVkID0gc2VsZWN0ZWQ7XG5cdFx0aWYgKCBjb29yZGluYXRlcyAgICAgICAgICAgICE9PSB1bmRlZmluZWQgKSBjb25maWcuY29vcmRpbmF0ZXMgPSBjb29yZGluYXRlcyA7XG5cdFx0aWYgKCBhdXRvQ2FzdGxlICAgICAgICAgICAgICE9PSB1bmRlZmluZWQgKSBjb25maWcuYXV0b0Nhc3RsZSA9IGF1dG9DYXN0bGU7XG5cdFx0aWYgKCB2aWV3T25seSAgICAgICAgICAgICAgICE9PSB1bmRlZmluZWQgKSBjb25maWcudmlld09ubHkgPSB2aWV3T25seTtcblx0XHRpZiAoIGRpc2FibGVDb250ZXh0TWVudSAgICAgIT09IHVuZGVmaW5lZCApIGNvbmZpZy5kaXNhYmxlQ29udGV4dE1lbnUgPSBkaXNhYmxlQ29udGV4dE1lbnU7XG5cdFx0aWYgKCBhZGRQaWVjZVpJbmRleCAgICAgICAgICE9PSB1bmRlZmluZWQgKSBjb25maWcuYWRkUGllY2VaSW5kZXggPSBhZGRQaWVjZVpJbmRleDtcblx0XHRpZiAoIGFkZERpbWVuc2lvbnNDc3NWYXJzVG8gIT09IHVuZGVmaW5lZCApIGNvbmZpZy5hZGREaW1lbnNpb25zQ3NzVmFyc1RvID0gYWRkRGltZW5zaW9uc0Nzc1ZhcnNUbztcblx0XHRpZiAoIGJsb2NrVG91Y2hTY3JvbGwgICAgICAgIT09IHVuZGVmaW5lZCApIGNvbmZpZy5ibG9ja1RvdWNoU2Nyb2xsID0gYmxvY2tUb3VjaFNjcm9sbDtcblx0XHRjaGVzc2dyb3VuZCA9IENoZXNzZ3JvdW5kKCBjb250YWluZXIsIGNvbmZpZyApO1xuXHR9KTtcblxuXHQvKipcblx0ICogU2V0IGNvbmZpZyB2YWx1ZXMgaWYgY29tcG9uZW50IGlzIG1vdW50ZWQuIFVzZWQgZm9yIHJlYWN0aXZlIHByb3BzLlxuXHQgKiBAcGFyYW0ge2ltcG9ydCgnY2hlc3Nncm91bmQvY29uZmlnJykuQ29uZmlnfSBjb25maWcgLSBvYmplY3Qgb2Yga2V5KHMpIGFuZCB2YWx1ZShzKSB0byBzZXQuXG5cdCAqIEByZXR1cm5zIHt2b2lkfVxuXHQgKi9cblx0ZnVuY3Rpb24gc2V0Q29uZmlnKCBjb25maWcgKSB7XG5cdFx0aWYgKCBjaGVzc2dyb3VuZCApIHtcblx0XHRcdGNoZXNzZ3JvdW5kLnNldCggY29uZmlnICk7XG5cdFx0fVxuXHR9XG5cblx0Lypcblx0ICpcblx0ICogTWV0aG9kcyBwYXNzZWQgdGhyb3VnaCB0byBDaGVzc2dyb3VuZFxuXHQgKlxuXHQgKi9cblxuXHQvKipcblx0ICogU2V0IGNvbmZpZyB2YWx1ZXMuIEFsdGVybmF0aXZlIHRvIHVzaW5nIHRoZSBjb25maWcgcHJvcC5cblx0ICogQHBhcmFtIHtpbXBvcnQoJ2NoZXNzZ3JvdW5kL2NvbmZpZycpLkNvbmZpZ30gY29uZmlnIC0gb2JqZWN0IG9mIGtleShzKSBhbmQgdmFsdWUocykgdG8gc2V0LlxuXHQgKiBAcmV0dXJucyB7dm9pZH1cblx0ICovXG5cdGV4cG9ydCBmdW5jdGlvbiBzZXQoY29uZmlnKSB7XG5cdFx0Y2hlc3Nncm91bmQuc2V0KGNvbmZpZyk7XG5cdH1cblxuXHQvKiogXG5cdCAqIEludGVybmFsIENoZXNzZ3JvdW5kIHN0YXRlLCBkZXNjcmliZWQgYXRcblx0ICogaHR0cHM6Ly9naXRodWIuY29tL2xpY2hlc3Mtb3JnL2NoZXNzZ3JvdW5kL2Jsb2IvbWFzdGVyL3NyYy9zdGF0ZS50c1xuXHQgKiBAcmV0dXJucyB7aW1wb3J0KCdjaGVzc2dyb3VuZC9zdGF0ZScpLlN0YXRlfSAtIENoZXNzZ3JvdW5kIHN0YXRlXG5cdCAqL1xuXHRleHBvcnQgZnVuY3Rpb24gZ2V0U3RhdGUoKSB7XG5cdFx0cmV0dXJuIGNoZXNzZ3JvdW5kLnN0YXRlO1xuXHR9XG5cblx0LyoqIFxuXHQgKiBDdXJyZW50IHBvc2l0aW9uIGFzIGEgRkVOIHN0cmluZy4gQ29udGFpbnMgb25seSBwaWVjZXMsIG5vIGZsYWdzLlxuXHQgKiBlLmcuIFwicm5icWtibnIvcHBwcHBwcHAvOC84LzgvOC9QUFBQUFBQUC9STkJRS0JOUlwiXG5cdCAqIEByZXR1cm5zIHtpbXBvcnQoJ2NoZXNzZ3JvdW5kL3R5cGVzJykuRkVOfSAtIEZFTiBzdHJpbmdcblx0ICovXG5cdGV4cG9ydCBmdW5jdGlvbiBnZXRGZW4oKSB7XG5cdFx0cmV0dXJuIGNoZXNzZ3JvdW5kLmdldEZlbigpO1xuXHR9XG5cblx0LyoqIFxuXHQgKiBUb2dnbGUgY2hlc3Nib2FyZCBvcmllbnRhdGlvbiBiZXR3ZWVuIHdoaXRlIGFuZCBibGFjay4gQ2FuIGFsc28gYmVcblx0ICogaGFuZGxlZCB2aWEgdGhlIG9yaWVudGF0aW9uIHByb3AuXG5cdCAqIEByZXR1cm5zIHt2b2lkfVxuXHQgKi9cblx0ZXhwb3J0IGZ1bmN0aW9uIHRvZ2dsZU9yaWVudGF0aW9uKCkge1xuXHRcdHJldHVybiBjaGVzc2dyb3VuZC50b2dnbGVPcmllbnRhdGlvbigpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFBlcmZvcm0gYSBtb3ZlIHByb2dyYW1tYXRpY2FsbHkuXG5cdCAqIEBwYXJhbSB7aW1wb3J0KCdjaGVzc2dyb3VuZC90eXBlcycpLktleX0gb3JpZyAtIE9yaWdpbiBzcXVhcmUuXG5cdCAqIEBwYXJhbSB7aW1wb3J0KCdjaGVzc2dyb3VuZC90eXBlcycpLktleX0gZGVzdCAtIERlc3RpbmF0aW9uIHNxdWFyZS5cblx0ICogQHJldHVybnMge3ZvaWR9XG5cdCAqL1xuXHRleHBvcnQgZnVuY3Rpb24gbW92ZSggb3JpZywgZGVzdCApIHtcblx0XHRyZXR1cm4gY2hlc3Nncm91bmQubW92ZSggb3JpZywgZGVzdCApO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFkZCBhbmQvb3IgcmVtb3ZlIGFyYml0cmFyeSBwaWVjZXMgb24gdGhlIGJvYXJkLlxuXHQgKiBAcGFyYW0ge2ltcG9ydCgnY2hlc3Nncm91bmQvdHlwZXMnKS5QaWVjZXNEaWZmfSBwaWVjZXMgLSBQaWVjZXMgdG8gYWRkL3JlbW92ZS5cblx0ICogQHJldHVybnMge3ZvaWR9XG5cdCAqL1xuXHRleHBvcnQgZnVuY3Rpb24gc2V0UGllY2VzKCBwaWVjZXMgKSB7XG5cdFx0cmV0dXJuIGNoZXNzZ3JvdW5kLnNldFBpZWNlcyggcGllY2VzICk7XG5cdH1cblxuXHQvKipcblx0ICogQ2xpY2sgYSBzcXVhcmUgcHJvZ3JhbW1hdGljYWxseS4gXG5cdCAqIEBwYXJhbSB7aW1wb3J0KCdjaGVzc2dyb3VuZC90eXBlcycpLktleSB8IG51bGwgfSBrZXkgLSBTcXVhcmUgdG8gY2xpY2suXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW2ZvcmNlXSAtIENsaWNrIGV2ZW4gaWYgdGhlIHNxdWFyZXMgYXJlIG5vdCBzZWxlY3RhYmxlIChjb25maWcuc2VsZWN0YWJsZSkuXG5cdCAqIEByZXR1cm5zIHt2b2lkfVxuXHQgKi9cblx0ZXhwb3J0IGZ1bmN0aW9uIHNlbGVjdFNxdWFyZSgga2V5LCBmb3JjZSApIHtcblx0XHRyZXR1cm4gY2hlc3Nncm91bmQuc2VsZWN0U3F1YXJlKCBrZXksIGZvcmNlICk7XG5cdH1cblxuXHQvKipcblx0ICogUHV0IGEgbmV3IHBpZWNlIG9uIHRoZSBib2FyZC5cblx0ICogQHBhcmFtIHtpbXBvcnQoJ2NoZXNzZ3JvdW5kL3R5cGVzJykuUGllY2UgfSBwaWVjZSAtIFBpZWNlIHRvIHBsYWNlLlxuXHQgKiBAcGFyYW0ge2ltcG9ydCgnY2hlc3Nncm91bmQvdHlwZXMnKS5LZXkgfSBrZXkgLSBTcXVhcmUgdG8gcGxhY2UgdGhlIHBpZWNlLlxuXHQgKiBAcmV0dXJucyB7dm9pZH1cblx0ICovXG5cdGV4cG9ydCBmdW5jdGlvbiBuZXdQaWVjZSggcGllY2UsIGtleSApIHtcblx0XHRyZXR1cm4gY2hlc3Nncm91bmQubmV3UGllY2UoIHBpZWNlLCBrZXkgKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBQbGF5IHRoZSBjdXJyZW50IHByZW1vdmUsIGlmIGFueS5cblx0ICogQHJldHVybnMge2Jvb2xlYW59IC0gVHJ1ZSBpZiBhIHByZW1vdmUgd2FzIHBsYXllZC5cblx0ICovXG5cdGV4cG9ydCBmdW5jdGlvbiBwbGF5UHJlbW92ZSgpIHtcblx0XHRyZXR1cm4gY2hlc3Nncm91bmQucGxheVByZW1vdmUoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDYW5jZWwgdGhlIGN1cnJlbnQgcHJlbW92ZSwgaWYgYW55LlxuXHQgKiBAcmV0dXJucyB7dm9pZH1cblx0ICovXG5cdGV4cG9ydCBmdW5jdGlvbiBjYW5jZWxQcmVtb3ZlKCkge1xuXHRcdGNoZXNzZ3JvdW5kLmNhbmNlbFByZW1vdmUoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBQbGF5IHRoZSBjdXJyZW50IHByZWRyb3AsIGlmIGFueS5cblx0ICogQHBhcmFtIHsoZHJvcDogaW1wb3J0KCdjaGVzc2dyb3VuZC90eXBlcycpLkRyb3ApID0+IGJvb2xlYW4gfSB2YWxpZGF0ZSAtIFByZWRpY2F0ZSB0byBkZWNpZGUgd2hldGhlciBhIGRyb3AgaXMgdmFsaWQuXG5cdCAqIEByZXR1cm5zIHtib29sZWFufSAtIFRydWUgaWYgYSBwcmVkcm9wIHdhcyBwbGF5ZWQuXG5cdCAqL1xuXHRleHBvcnQgZnVuY3Rpb24gcGxheVByZWRyb3AoIHZhbGlkYXRlICkge1xuXHRcdHJldHVybiBjaGVzc2dyb3VuZC5wbGF5UHJlZHJvcCggdmFsaWRhdGUgKTtcblx0fVxuXHRcblx0LyoqXG5cdCAqIENhbmNlbCB0aGUgY3VycmVudCBwcmVkcm9wLCBpZiBhbnkuXG5cdCAqIEByZXR1cm5zIHt2b2lkfVxuXHQgKi9cblx0ZXhwb3J0IGZ1bmN0aW9uIGNhbmNlbFByZWRyb3AoKSB7XG5cdFx0Y2hlc3Nncm91bmQuY2FuY2VsUHJlZHJvcCgpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENhbmNlbCB0aGUgY3VycmVudCBtb3ZlIGJlaW5nIG1hZGUuXG5cdCAqIEByZXR1cm5zIHt2b2lkfVxuXHQgKi9cblx0ZXhwb3J0IGZ1bmN0aW9uIGNhbmNlbE1vdmUoKSB7XG5cdFx0Y2hlc3Nncm91bmQuY2FuY2VsTW92ZSgpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENhbmNlbCB0aGUgY3VycmVudCBtb3ZlIGFuZCBwcmV2ZW50IGZ1cnRoZXIgb25lcy5cblx0ICogQHJldHVybnMge3ZvaWR9XG5cdCAqL1xuXHRleHBvcnQgZnVuY3Rpb24gc3RvcCgpIHtcblx0XHRjaGVzc2dyb3VuZC5zdG9wKCk7XG5cdH1cblxuXHQvKipcblx0ICogTWFrZSBzcXVhcmVzIGV4cGxvZGUgKGZvciBhdG9taWMgY2hlc3MpLlxuXHQgKiBAcGFyYW0ge2ltcG9ydCgnY2hlc3Nncm91bmQvdHlwZXMnKS5LZXlbXSB9IGtleXMgLSBTcXVhcmVzIHRvIGV4cGxvZGUuXG5cdCAqIEByZXR1cm5zIHt2b2lkfVxuXHQgKi9cblx0ZXhwb3J0IGZ1bmN0aW9uIGV4cGxvZGUoIGtleXMgKSB7XG5cdFx0Y2hlc3Nncm91bmQuZXhwbG9kZSgga2V5cyApO1xuXHR9XG5cblx0LyoqXG5cdCAqIFByb2dyYW1tYXRpY2FsbHkgZHJhdyB1c2VyIHNoYXBlcy5cblx0ICogQHBhcmFtIHtpbXBvcnQoJ2NoZXNzZ3JvdW5kL2RyYXcnKS5EcmF3U2hhcGVbXSB9IHNoYXBlcyAtIFNoYXBlcyB0byBkcmF3LlxuXHQgKiBAcmV0dXJucyB7dm9pZH1cblx0ICovXG5cdGV4cG9ydCBmdW5jdGlvbiBzZXRTaGFwZXMoIHNoYXBlcyApIHtcblx0XHRjaGVzc2dyb3VuZC5zZXRTaGFwZXMoIHNoYXBlcyApO1xuXHR9XG5cblx0LyoqXG5cdCAqIFByb2dyYW1tYXRpY2FsbHkgZHJhdyBhdXRvIHNoYXBlcy5cblx0ICogQHBhcmFtIHtpbXBvcnQoJ2NoZXNzZ3JvdW5kL2RyYXcnKS5EcmF3U2hhcGVbXSB9IHNoYXBlcyAtIFNoYXBlcyB0byBkcmF3LlxuXHQgKiBAcmV0dXJucyB7dm9pZH1cblx0ICovXG5cdGV4cG9ydCBmdW5jdGlvbiBzZXRBdXRvU2hhcGVzKCBzaGFwZXMgKSB7XG5cdFx0Y2hlc3Nncm91bmQuc2V0QXV0b1NoYXBlcyggc2hhcGVzICk7XG5cdH1cblxuXHQvKiogXG5cdCAqIFJlZHJhdy4gVXNlZnVsIHdoZW4gQ1NTIGNoYW5nZXMgdGhlIGJvYXJkIHdpZHRoIG9yIGhlaWdodC5cblx0ICogQHJldHVybnMge3ZvaWR9XG5cdCAqL1xuXHRleHBvcnQgZnVuY3Rpb24gcmVkcmF3QWxsKCkge1xuXHRcdHJldHVybiBjaGVzc2dyb3VuZC5yZWRyYXdBbGwoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBEcmFnIG5ldyBwaWVjZSwgZm9yIGNyYXp5aG91c2UgYW5kIGJvYXJkIGVkaXRvcnMuXG5cdCAqIEBwYXJhbSB7aW1wb3J0KCdjaGVzc2dyb3VuZC90eXBlcycpLlBpZWNlIH0gcGllY2UgLSBQaWVjZSB0byBkcm9wXG5cdCAqIEBwYXJhbSB7aW1wb3J0KCdjaGVzc2dyb3VuZC90eXBlcycpLk1vdWNoRXZlbnQgfSBldmVudCAtIFRoZSBtb3VzZS90b3VjaCBldmVudCBpZGVudGlmeWluZyBhIHRhcmdldC5cblx0ICogQHBhcmFtIHtib29sZWFufSBbZm9yY2VdIC0gVHJ1ZSBpZiB0aGUgbmV3IHBpZWNlIGNhbiByZXBsYWNlIGFuIGV4aXN0aW5nIG9uZS5cblx0ICogQHJldHVybnMge3ZvaWR9XG5cdCAqL1xuXHRleHBvcnQgZnVuY3Rpb24gZHJhZ05ld1BpZWNlKCBwaWVjZSwgZXZlbnQsIGZvcmNlICkge1xuXHRcdGNoZXNzZ3JvdW5kLmRyYWdOZXdQaWVjZSggcGllY2UsIGV2ZW50LCBmb3JjZSApO1xuXHR9XG5cblx0LyoqIEByZXR1cm5zIHt2b2lkfSAqL1xuXHRleHBvcnQgZnVuY3Rpb24gZGVzdHJveSgpIHtcblx0XHRyZXR1cm4gY2hlc3Nncm91bmQuZGVzdHJveSgpO1xuXHR9XG5cbjwvc2NyaXB0PlxuXG48ZGl2IGNsYXNzPVwiY2ctd3JhcCB7Y2xhc3NOYW1lfVwiIGJpbmQ6dGhpcz17Y29udGFpbmVyfT48L2Rpdj5cblxuPHN0eWxlPlxuXG4gLmNnLXdyYXAge1xuICAgIHdpZHRoOiAxMDAlO1xuICAgIGFzcGVjdC1yYXRpbzogMTtcbiAgfVxuPC9zdHlsZT5cbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQXVXQSxDQUFDLHVCQUFRLENBQUM7QUFDVixJQUFJLFdBQVc7QUFDZixJQUFJLGVBQWU7QUFDbkIiLCJpZ25vcmVMaXN0IjpbXX0= */"
};
function ChessgroundUnstyled($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, ChessgroundUnstyled);
  append_styles($$anchor, $$css2);
  var $$ownership_validator = create_ownership_validator($$props);
  let className = prop($$props, "class", 8, "cg-default-style");
  let fen = prop($$props, "fen", 8, void 0);
  let orientation = prop($$props, "orientation", 8, void 0);
  let turnColor = prop($$props, "turnColor", 8, void 0);
  let check = prop($$props, "check", 8, void 0);
  let lastMove = prop($$props, "lastMove", 8, void 0);
  let selected = prop($$props, "selected", 8, void 0);
  let coordinates = prop($$props, "coordinates", 8, void 0);
  let autoCastle = prop($$props, "autoCastle", 8, void 0);
  let viewOnly = prop($$props, "viewOnly", 8, void 0);
  let disableContextMenu = prop($$props, "disableContextMenu", 8, void 0);
  let addPieceZIndex = prop($$props, "addPieceZIndex", 8, void 0);
  let addDimensionsCssVarsTo = prop($$props, "addDimensionsCssVarsTo", 8, void 0);
  let blockTouchScroll = prop($$props, "blockTouchScroll", 8, void 0);
  let config = prop($$props, "config", 28, () => ({}));
  let container = mutable_source();
  let chessground;
  onMount(async () => {
    if (strict_equals(orientation(), void 0, false)) $$ownership_validator.mutation(null, ["config", "orientation"], config(config().orientation = orientation(), true), 146, 46);
    if (strict_equals(fen(), void 0, false)) $$ownership_validator.mutation(null, ["config", "fen"], config(config().fen = fen(), true), 147, 46);
    if (strict_equals(turnColor(), void 0, false)) $$ownership_validator.mutation(null, ["config", "turnColor"], config(config().turnColor = turnColor(), true), 148, 46);
    if (strict_equals(check(), void 0, false)) $$ownership_validator.mutation(null, ["config", "check"], config(config().check = check(), true), 149, 46);
    if (strict_equals(lastMove(), void 0, false)) $$ownership_validator.mutation(null, ["config", "lastMove"], config(config().lastMove = lastMove(), true), 150, 46);
    if (strict_equals(selected(), void 0, false)) $$ownership_validator.mutation(null, ["config", "selected"], config(config().selected = selected(), true), 151, 46);
    if (strict_equals(coordinates(), void 0, false)) $$ownership_validator.mutation(null, ["config", "coordinates"], config(config().coordinates = coordinates(), true), 152, 46);
    if (strict_equals(autoCastle(), void 0, false)) $$ownership_validator.mutation(null, ["config", "autoCastle"], config(config().autoCastle = autoCastle(), true), 153, 46);
    if (strict_equals(viewOnly(), void 0, false)) $$ownership_validator.mutation(null, ["config", "viewOnly"], config(config().viewOnly = viewOnly(), true), 154, 46);
    if (strict_equals(disableContextMenu(), void 0, false)) $$ownership_validator.mutation(null, ["config", "disableContextMenu"], config(config().disableContextMenu = disableContextMenu(), true), 155, 46);
    if (strict_equals(addPieceZIndex(), void 0, false)) $$ownership_validator.mutation(null, ["config", "addPieceZIndex"], config(config().addPieceZIndex = addPieceZIndex(), true), 156, 46);
    if (strict_equals(addDimensionsCssVarsTo(), void 0, false)) $$ownership_validator.mutation(null, ["config", "addDimensionsCssVarsTo"], config(config().addDimensionsCssVarsTo = addDimensionsCssVarsTo(), true), 157, 46);
    if (strict_equals(blockTouchScroll(), void 0, false)) $$ownership_validator.mutation(null, ["config", "blockTouchScroll"], config(config().blockTouchScroll = blockTouchScroll(), true), 158, 46);
    chessground = Chessground(get(container), config());
  });
  function setConfig(config2) {
    if (chessground) {
      chessground.set(config2);
    }
  }
  function set2(config2) {
    chessground.set(config2);
  }
  function getState() {
    return chessground.state;
  }
  function getFen() {
    return chessground.getFen();
  }
  function toggleOrientation2() {
    return chessground.toggleOrientation();
  }
  function move3(orig, dest) {
    return chessground.move(orig, dest);
  }
  function setPieces2(pieces) {
    return chessground.setPieces(pieces);
  }
  function selectSquare2(key, force) {
    return chessground.selectSquare(key, force);
  }
  function newPiece(piece, key) {
    return chessground.newPiece(piece, key);
  }
  function playPremove2() {
    return chessground.playPremove();
  }
  function cancelPremove() {
    chessground.cancelPremove();
  }
  function playPredrop2(validate) {
    return chessground.playPredrop(validate);
  }
  function cancelPredrop() {
    chessground.cancelPredrop();
  }
  function cancelMove2() {
    chessground.cancelMove();
  }
  function stop2() {
    chessground.stop();
  }
  function explode(keys) {
    chessground.explode(keys);
  }
  function setShapes(shapes) {
    chessground.setShapes(shapes);
  }
  function setAutoShapes(shapes) {
    chessground.setAutoShapes(shapes);
  }
  function redrawAll() {
    return chessground.redrawAll();
  }
  function dragNewPiece2(piece, event2, force) {
    chessground.dragNewPiece(piece, event2, force);
  }
  function destroy() {
    return chessground.destroy();
  }
  legacy_pre_effect(() => deep_read_state(fen()), () => {
    setConfig({ fen: fen() });
  });
  legacy_pre_effect(() => deep_read_state(orientation()), () => {
    setConfig({ orientation: orientation() });
  });
  legacy_pre_effect(() => deep_read_state(turnColor()), () => {
    setConfig({ turnColor: turnColor() });
  });
  legacy_pre_effect(() => deep_read_state(check()), () => {
    setConfig({ check: check() });
  });
  legacy_pre_effect(() => deep_read_state(lastMove()), () => {
    setConfig({ lastMove: lastMove() });
  });
  legacy_pre_effect(() => deep_read_state(selected()), () => {
    setConfig({ selected: selected() });
  });
  legacy_pre_effect(() => deep_read_state(coordinates()), () => {
    setConfig({ coordinates: coordinates() });
  });
  legacy_pre_effect(() => deep_read_state(autoCastle()), () => {
    setConfig({ autoCastle: autoCastle() });
  });
  legacy_pre_effect(() => deep_read_state(viewOnly()), () => {
    setConfig({ viewOnly: viewOnly() });
  });
  legacy_pre_effect(() => deep_read_state(disableContextMenu()), () => {
    setConfig({ disableContextMenu: disableContextMenu() });
  });
  legacy_pre_effect(() => deep_read_state(addPieceZIndex()), () => {
    setConfig({ addPieceZIndex: addPieceZIndex() });
  });
  legacy_pre_effect(() => deep_read_state(addDimensionsCssVarsTo()), () => {
    setConfig({ addDimensionsCssVarsTo: addDimensionsCssVarsTo() });
  });
  legacy_pre_effect(() => deep_read_state(blockTouchScroll()), () => {
    setConfig({ blockTouchScroll: blockTouchScroll() });
  });
  legacy_pre_effect(() => deep_read_state(config()), () => {
    setConfig(config());
  });
  legacy_pre_effect_reset();
  var $$exports = {
    get set() {
      return set2;
    },
    get getState() {
      return getState;
    },
    get getFen() {
      return getFen;
    },
    get toggleOrientation() {
      return toggleOrientation2;
    },
    get move() {
      return move3;
    },
    get setPieces() {
      return setPieces2;
    },
    get selectSquare() {
      return selectSquare2;
    },
    get newPiece() {
      return newPiece;
    },
    get playPremove() {
      return playPremove2;
    },
    get cancelPremove() {
      return cancelPremove;
    },
    get playPredrop() {
      return playPredrop2;
    },
    get cancelPredrop() {
      return cancelPredrop;
    },
    get cancelMove() {
      return cancelMove2;
    },
    get stop() {
      return stop2;
    },
    get explode() {
      return explode;
    },
    get setShapes() {
      return setShapes;
    },
    get setAutoShapes() {
      return setAutoShapes;
    },
    get redrawAll() {
      return redrawAll;
    },
    get dragNewPiece() {
      return dragNewPiece2;
    },
    get destroy() {
      return destroy;
    },
    ...legacy_api()
  };
  init();
  var div = root2();
  bind_this(div, ($$value) => set(container, $$value), () => get(container));
  template_effect(() => set_class(div, 1, `cg-wrap ${className() ?? ""}`, "s-ksQhaDfsNdf3"));
  append($$anchor, div);
  bind_prop($$props, "set", set2);
  bind_prop($$props, "getState", getState);
  bind_prop($$props, "getFen", getFen);
  bind_prop($$props, "toggleOrientation", toggleOrientation2);
  bind_prop($$props, "move", move3);
  bind_prop($$props, "setPieces", setPieces2);
  bind_prop($$props, "selectSquare", selectSquare2);
  bind_prop($$props, "newPiece", newPiece);
  bind_prop($$props, "playPremove", playPremove2);
  bind_prop($$props, "cancelPremove", cancelPremove);
  bind_prop($$props, "playPredrop", playPredrop2);
  bind_prop($$props, "cancelPredrop", cancelPredrop);
  bind_prop($$props, "cancelMove", cancelMove2);
  bind_prop($$props, "stop", stop2);
  bind_prop($$props, "explode", explode);
  bind_prop($$props, "setShapes", setShapes);
  bind_prop($$props, "setAutoShapes", setAutoShapes);
  bind_prop($$props, "redrawAll", redrawAll);
  bind_prop($$props, "dragNewPiece", dragNewPiece2);
  bind_prop($$props, "destroy", destroy);
  return pop($$exports);
}
if (import.meta.hot) {
  ChessgroundUnstyled = hmr(ChessgroundUnstyled);
  import.meta.hot.accept((module) => {
    cleanup_styles("s-ksQhaDfsNdf3");
    ChessgroundUnstyled[HMR].update(module.default);
  });
}

// node_modules/svelte-chess/dist/PromotionDialog.svelte
PromotionDialog[FILENAME] = "node_modules/svelte-chess/dist/PromotionDialog.svelte";
var root_1 = add_locations(from_html(`<div class="square s-SwSmnh7q9HVq"><div role="button" tabindex="0"></div></div>`), PromotionDialog[FILENAME], [[25, 2, [[26, 3]]]]);
var root3 = add_locations(from_html(`<div></div>`), PromotionDialog[FILENAME], [[21, 0]]);
var $$css3 = {
  hash: "s-SwSmnh7q9HVq",
  code: "\n	div.dialog.s-SwSmnh7q9HVq {\n		width:100%;\n		height:100%;\n		position: absolute;\n		top:0;\n		left:0;\n		z-index:10;\n		background: rgba(255,255,255,0.30);\n	}\n	div.square.s-SwSmnh7q9HVq {\n		position:absolute;\n		width:12.5%;\n		height:12.5%;\n		background-color:#b0b0b0;\n		border-radius:50%;\n		box-shadow:inset 0 0 25px 3px grey;\n		transition: all 150ms;\n	}\n	div.square.s-SwSmnh7q9HVq:hover {\n		border-radius:0;\n	}\n	div.square.s-SwSmnh7q9HVq div.piece:where(.s-SwSmnh7q9HVq) {\n		width:100%;\n		height:100%;\n		background-size:cover;\n		cursor:pointer;\n		transition: all 150ms;\n		transform:scale(0.8);\n	}\n	div.square.s-SwSmnh7q9HVq:hover div.piece:where(.s-SwSmnh7q9HVq) {\n		transform:scale(1);\n	}\n\n	/* Chessground default pieces */\n	.b.white.s-SwSmnh7q9HVq {\n		background-image: url('data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0NSIgaGVpZ2h0PSI0NSI+PGcgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIiBzdHJva2U9IiMwMDAiIHN0cm9rZS13aWR0aD0iMS41IiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiPjxnIGZpbGw9IiNmZmYiIHN0cm9rZS1saW5lY2FwPSJidXR0Ij48cGF0aCBkPSJNOSAzNmMzLjM5LS45NyAxMC4xMS40MyAxMy41LTIgMy4zOSAyLjQzIDEwLjExIDEuMDMgMTMuNSAyIDAgMCAxLjY1LjU0IDMgMi0uNjguOTctMS42NS45OS0zIC41LTMuMzktLjk3LTEwLjExLjQ2LTEzLjUtMS0zLjM5IDEuNDYtMTAuMTEuMDMtMTMuNSAxLTEuMzU0LjQ5LTIuMzIzLjQ3LTMtLjUgMS4zNTQtMS45NCAzLTIgMy0yeiIvPjxwYXRoIGQ9Ik0xNSAzMmMyLjUgMi41IDEyLjUgMi41IDE1IDAgLjUtMS41IDAtMiAwLTIgMC0yLjUtMi41LTQtMi41LTQgNS41LTEuNSA2LTExLjUtNS0xNS41LTExIDQtMTAuNSAxNC01IDE1LjUgMCAwLTIuNSAxLjUtMi41IDQgMCAwLS41LjUgMCAyeiIvPjxwYXRoIGQ9Ik0yNSA4YTIuNSAyLjUgMCAxIDEtNSAwIDIuNSAyLjUgMCAxIDEgNSAweiIvPjwvZz48cGF0aCBkPSJNMTcuNSAyNmgxME0xNSAzMGgxNW0tNy41LTE0LjV2NU0yMCAxOGg1IiBzdHJva2UtbGluZWpvaW49Im1pdGVyIi8+PC9nPjwvc3ZnPg==');\n	}\n	.n.white.s-SwSmnh7q9HVq {\n		background-image: url('data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0NSIgaGVpZ2h0PSI0NSI+PGcgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIiBzdHJva2U9IiMwMDAiIHN0cm9rZS13aWR0aD0iMS41IiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiPjxwYXRoIGQ9Ik0yMiAxMGMxMC41IDEgMTYuNSA4IDE2IDI5SDE1YzAtOSAxMC02LjUgOC0yMSIgZmlsbD0iI2ZmZiIvPjxwYXRoIGQ9Ik0yNCAxOGMuMzggMi45MS01LjU1IDcuMzctOCA5LTMgMi0yLjgyIDQuMzQtNSA0LTEuMDQyLS45NCAxLjQxLTMuMDQgMC0zLTEgMCAuMTkgMS4yMy0xIDItMSAwLTQuMDAzIDEtNC00IDAtMiA2LTEyIDYtMTJzMS44OS0xLjkgMi0zLjVjLS43My0uOTk0LS41LTItLjUtMyAxLTEgMyAyLjUgMyAyLjVoMnMuNzgtMS45OTIgMi41LTNjMSAwIDEgMyAxIDMiIGZpbGw9IiNmZmYiLz48cGF0aCBkPSJNOS41IDI1LjVhLjUuNSAwIDEgMS0xIDAgLjUuNSAwIDEgMSAxIDB6bTUuNDMzLTkuNzVhLjUgMS41IDMwIDEgMS0uODY2LS41LjUgMS41IDMwIDEgMSAuODY2LjV6IiBmaWxsPSIjMDAwIi8+PC9nPjwvc3ZnPg==');\n	}\n	.r.white.s-SwSmnh7q9HVq {\n		background-image: url('data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0NSIgaGVpZ2h0PSI0NSI+PGcgZmlsbD0iI2ZmZiIgZmlsbC1ydWxlPSJldmVub2RkIiBzdHJva2U9IiMwMDAiIHN0cm9rZS13aWR0aD0iMS41IiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiPjxwYXRoIGQ9Ik05IDM5aDI3di0zSDl2M3ptMy0zdi00aDIxdjRIMTJ6bS0xLTIyVjloNHYyaDVWOWg1djJoNVY5aDR2NSIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiLz48cGF0aCBkPSJNMzQgMTRsLTMgM0gxNGwtMy0zIi8+PHBhdGggZD0iTTMxIDE3djEyLjVIMTRWMTciIHN0cm9rZS1saW5lY2FwPSJidXR0IiBzdHJva2UtbGluZWpvaW49Im1pdGVyIi8+PHBhdGggZD0iTTMxIDI5LjVsMS41IDIuNWgtMjBsMS41LTIuNSIvPjxwYXRoIGQ9Ik0xMSAxNGgyMyIgZmlsbD0ibm9uZSIgc3Ryb2tlLWxpbmVqb2luPSJtaXRlciIvPjwvZz48L3N2Zz4=');\n	}\n	.q.white.s-SwSmnh7q9HVq {\n		background-image: url('data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0NSIgaGVpZ2h0PSI0NSI+PGcgZmlsbD0iI2ZmZiIgZmlsbC1ydWxlPSJldmVub2RkIiBzdHJva2U9IiMwMDAiIHN0cm9rZS13aWR0aD0iMS41IiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiPjxwYXRoIGQ9Ik04IDEyYTIgMiAwIDEgMS00IDAgMiAyIDAgMSAxIDQgMHptMTYuNS00LjVhMiAyIDAgMSAxLTQgMCAyIDIgMCAxIDEgNCAwek00MSAxMmEyIDIgMCAxIDEtNCAwIDIgMiAwIDEgMSA0IDB6TTE2IDguNWEyIDIgMCAxIDEtNCAwIDIgMiAwIDEgMSA0IDB6TTMzIDlhMiAyIDAgMSAxLTQgMCAyIDIgMCAxIDEgNCAweiIvPjxwYXRoIGQ9Ik05IDI2YzguNS0xLjUgMjEtMS41IDI3IDBsMi0xMi03IDExVjExbC01LjUgMTMuNS0zLTE1LTMgMTUtNS41LTE0VjI1TDcgMTRsMiAxMnoiIHN0cm9rZS1saW5lY2FwPSJidXR0Ii8+PHBhdGggZD0iTTkgMjZjMCAyIDEuNSAyIDIuNSA0IDEgMS41IDEgMSAuNSAzLjUtMS41IDEtMS41IDIuNS0xLjUgMi41LTEuNSAxLjUuNSAyLjUuNSAyLjUgNi41IDEgMTYuNSAxIDIzIDAgMCAwIDEuNS0xIDAtMi41IDAgMCAuNS0xLjUtMS0yLjUtLjUtMi41LS41LTIgLjUtMy41IDEtMiAyLjUtMiAyLjUtNC04LjUtMS41LTE4LjUtMS41LTI3IDB6IiBzdHJva2UtbGluZWNhcD0iYnV0dCIvPjxwYXRoIGQ9Ik0xMS41IDMwYzMuNS0xIDE4LjUtMSAyMiAwTTEyIDMzLjVjNi0xIDE1LTEgMjEgMCIgZmlsbD0ibm9uZSIvPjwvZz48L3N2Zz4=');\n	}\n	.b.black.s-SwSmnh7q9HVq {\n		background-image: url('data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0NSIgaGVpZ2h0PSI0NSI+PGcgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIiBzdHJva2U9IiMwMDAiIHN0cm9rZS13aWR0aD0iMS41IiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiPjxnIGZpbGw9IiMwMDAiIHN0cm9rZS1saW5lY2FwPSJidXR0Ij48cGF0aCBkPSJNOSAzNmMzLjM5LS45NyAxMC4xMS40MyAxMy41LTIgMy4zOSAyLjQzIDEwLjExIDEuMDMgMTMuNSAyIDAgMCAxLjY1LjU0IDMgMi0uNjguOTctMS42NS45OS0zIC41LTMuMzktLjk3LTEwLjExLjQ2LTEzLjUtMS0zLjM5IDEuNDYtMTAuMTEuMDMtMTMuNSAxLTEuMzU0LjQ5LTIuMzIzLjQ3LTMtLjUgMS4zNTQtMS45NCAzLTIgMy0yeiIvPjxwYXRoIGQ9Ik0xNSAzMmMyLjUgMi41IDEyLjUgMi41IDE1IDAgLjUtMS41IDAtMiAwLTIgMC0yLjUtMi41LTQtMi41LTQgNS41LTEuNSA2LTExLjUtNS0xNS41LTExIDQtMTAuNSAxNC01IDE1LjUgMCAwLTIuNSAxLjUtMi41IDQgMCAwLS41LjUgMCAyeiIvPjxwYXRoIGQ9Ik0yNSA4YTIuNSAyLjUgMCAxIDEtNSAwIDIuNSAyLjUgMCAxIDEgNSAweiIvPjwvZz48cGF0aCBkPSJNMTcuNSAyNmgxME0xNSAzMGgxNW0tNy41LTE0LjV2NU0yMCAxOGg1IiBzdHJva2U9IiNlY2VjZWMiIHN0cm9rZS1saW5lam9pbj0ibWl0ZXIiLz48L2c+PC9zdmc+');\n	}\n	.n.black.s-SwSmnh7q9HVq {\n		background-image: url('data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0NSIgaGVpZ2h0PSI0NSI+PGcgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIiBzdHJva2U9IiMwMDAiIHN0cm9rZS13aWR0aD0iMS41IiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiPjxwYXRoIGQ9Ik0yMiAxMGMxMC41IDEgMTYuNSA4IDE2IDI5SDE1YzAtOSAxMC02LjUgOC0yMSIgZmlsbD0iIzAwMCIvPjxwYXRoIGQ9Ik0yNCAxOGMuMzggMi45MS01LjU1IDcuMzctOCA5LTMgMi0yLjgyIDQuMzQtNSA0LTEuMDQyLS45NCAxLjQxLTMuMDQgMC0zLTEgMCAuMTkgMS4yMy0xIDItMSAwLTQuMDAzIDEtNC00IDAtMiA2LTEyIDYtMTJzMS44OS0xLjkgMi0zLjVjLS43My0uOTk0LS41LTItLjUtMyAxLTEgMyAyLjUgMyAyLjVoMnMuNzgtMS45OTIgMi41LTNjMSAwIDEgMyAxIDMiIGZpbGw9IiMwMDAiLz48cGF0aCBkPSJNOS41IDI1LjVhLjUuNSAwIDEgMS0xIDAgLjUuNSAwIDEgMSAxIDB6bTUuNDMzLTkuNzVhLjUgMS41IDMwIDEgMS0uODY2LS41LjUgMS41IDMwIDEgMSAuODY2LjV6IiBmaWxsPSIjZWNlY2VjIiBzdHJva2U9IiNlY2VjZWMiLz48cGF0aCBkPSJNMjQuNTUgMTAuNGwtLjQ1IDEuNDUuNS4xNWMzLjE1IDEgNS42NSAyLjQ5IDcuOSA2Ljc1UzM1Ljc1IDI5LjA2IDM1LjI1IDM5bC0uMDUuNWgyLjI1bC4wNS0uNWMuNS0xMC4wNi0uODgtMTYuODUtMy4yNS0yMS4zNC0yLjM3LTQuNDktNS43OS02LjY0LTkuMTktNy4xNmwtLjUxLS4xeiIgZmlsbD0iI2VjZWNlYyIgc3Ryb2tlPSJub25lIi8+PC9nPjwvc3ZnPg==');\n	}\n	.r.black.s-SwSmnh7q9HVq {\n		background-image: url('data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0NSIgaGVpZ2h0PSI0NSI+PGcgZmlsbC1ydWxlPSJldmVub2RkIiBzdHJva2U9IiMwMDAiIHN0cm9rZS13aWR0aD0iMS41IiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiPjxwYXRoIGQ9Ik05IDM5aDI3di0zSDl2M3ptMy41LTdsMS41LTIuNWgxN2wxLjUgMi41aC0yMHptLS41IDR2LTRoMjF2NEgxMnoiIHN0cm9rZS1saW5lY2FwPSJidXR0Ii8+PHBhdGggZD0iTTE0IDI5LjV2LTEzaDE3djEzSDE0eiIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiIHN0cm9rZS1saW5lam9pbj0ibWl0ZXIiLz48cGF0aCBkPSJNMTQgMTYuNUwxMSAxNGgyM2wtMyAyLjVIMTR6TTExIDE0VjloNHYyaDVWOWg1djJoNVY5aDR2NUgxMXoiIHN0cm9rZS1saW5lY2FwPSJidXR0Ii8+PHBhdGggZD0iTTEyIDM1LjVoMjFtLTIwLTRoMTltLTE4LTJoMTdtLTE3LTEzaDE3TTExIDE0aDIzIiBmaWxsPSJub25lIiBzdHJva2U9IiNlY2VjZWMiIHN0cm9rZS13aWR0aD0iMSIgc3Ryb2tlLWxpbmVqb2luPSJtaXRlciIvPjwvZz48L3N2Zz4=');\n	}\n	.q.black.s-SwSmnh7q9HVq {\n		background-image: url('data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0NSIgaGVpZ2h0PSI0NSI+PGcgZmlsbC1ydWxlPSJldmVub2RkIiBzdHJva2U9IiMwMDAiIHN0cm9rZS13aWR0aD0iMS41IiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiPjxnIHN0cm9rZT0ibm9uZSI+PGNpcmNsZSBjeD0iNiIgY3k9IjEyIiByPSIyLjc1Ii8+PGNpcmNsZSBjeD0iMTQiIGN5PSI5IiByPSIyLjc1Ii8+PGNpcmNsZSBjeD0iMjIuNSIgY3k9IjgiIHI9IjIuNzUiLz48Y2lyY2xlIGN4PSIzMSIgY3k9IjkiIHI9IjIuNzUiLz48Y2lyY2xlIGN4PSIzOSIgY3k9IjEyIiByPSIyLjc1Ii8+PC9nPjxwYXRoIGQ9Ik05IDI2YzguNS0xLjUgMjEtMS41IDI3IDBsMi41LTEyLjVMMzEgMjVsLS4zLTE0LjEtNS4yIDEzLjYtMy0xNC41LTMgMTQuNS01LjItMTMuNkwxNCAyNSA2LjUgMTMuNSA5IDI2eiIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiLz48cGF0aCBkPSJNOSAyNmMwIDIgMS41IDIgMi41IDQgMSAxLjUgMSAxIC41IDMuNS0xLjUgMS0xLjUgMi41LTEuNSAyLjUtMS41IDEuNS41IDIuNS41IDIuNSA2LjUgMSAxNi41IDEgMjMgMCAwIDAgMS41LTEgMC0yLjUgMCAwIC41LTEuNS0xLTIuNS0uNS0yLjUtLjUtMiAuNS0zLjUgMS0yIDIuNS0yIDIuNS00LTguNS0xLjUtMTguNS0xLjUtMjcgMHoiIHN0cm9rZS1saW5lY2FwPSJidXR0Ii8+PHBhdGggZD0iTTExIDM4LjVhMzUgMzUgMSAwIDAgMjMgMCIgZmlsbD0ibm9uZSIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiLz48cGF0aCBkPSJNMTEgMjlhMzUgMzUgMSAwIDEgMjMgMG0tMjEuNSAyLjVoMjBtLTIxIDNhMzUgMzUgMSAwIDAgMjIgMG0tMjMgM2EzNSAzNSAxIDAgMCAyNCAwIiBmaWxsPSJub25lIiBzdHJva2U9IiNlY2VjZWMiLz48L2c+PC9zdmc+');\n	}\n\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUHJvbW90aW9uRGlhbG9nLnN2ZWx0ZSIsInNvdXJjZXMiOlsiUHJvbW90aW9uRGlhbG9nLnN2ZWx0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyI8c2NyaXB0PmV4cG9ydCBsZXQgc3F1YXJlO1xuZXhwb3J0IGxldCBvcmllbnRhdGlvbiA9IFwid1wiO1xuZXhwb3J0IGxldCBjYWxsYmFjaztcbmxldCBjbGFzc05hbWUgPSB2b2lkIDA7XG5leHBvcnQgeyBjbGFzc05hbWUgYXMgY2xhc3MgfTtcbmNvbnN0IG1hcmdpbkxlZnQgPSAxMDAgLyA4ICogKG9yaWVudGF0aW9uID09PSBcIndcIiA/IHNxdWFyZVRvRmlsZU51bWJlcihzcXVhcmUpIDogNyAtIHNxdWFyZVRvRmlsZU51bWJlcihzcXVhcmUpKTtcbmNvbnN0IHdoaXRlID0gc3F1YXJlLmNoYXJBdCgxKSA9PT0gXCI4XCI7XG5jb25zdCBibGFjayA9ICF3aGl0ZTtcbmNvbnN0IHBpZWNlcyA9IFtcInFcIiwgXCJuXCIsIFwiclwiLCBcImJcIl07XG5jb25zdCBwaWVjZU5hbWVzID0geyBxOiBcInF1ZWVuXCIsIG46IFwia25pZ2h0XCIsIHI6IFwicm9va1wiLCBiOiBcImJpc2hvcFwiLCBwOiBcInBhd25cIiwgazogXCJraW5nXCIgfTtcbmZ1bmN0aW9uIHNxdWFyZVRvRmlsZU51bWJlcihzcXVhcmUyKSB7XG4gIHJldHVybiBzcXVhcmUyLmNoYXJDb2RlQXQoMCkgLSA5Nztcbn1cbmZ1bmN0aW9uIGtleWJvYXJkQ2FsbGJhY2soZXZlbnQsIHByb21vdGlvbikge1xuICBpZiAoZXZlbnQua2V5ID09PSBcIkVudGVyXCIgfHwgZXZlbnQua2V5ID09PSBcIiBcIikge1xuICAgIGNhbGxiYWNrKHByb21vdGlvbik7XG4gIH1cbn1cbjwvc2NyaXB0PlxuXG48ZGl2IGNsYXNzPVwiZGlhbG9nIHtjbGFzc05hbWV9XCI+XG5cdHsjZWFjaCBwaWVjZXMgYXMgcGllY2UsIGl9XG5cdFx0e0Bjb25zdCBwdXRQaWVjZXNGcm9tVG9wID0gd2hpdGUgJiYgb3JpZW50YXRpb24gPT09ICd3JyB8fCBibGFjayAmJiBvcmllbnRhdGlvbiA9PT0gJ2InfVxuXHRcdHtAY29uc3QgbWFyZ2luVG9wID0gcHV0UGllY2VzRnJvbVRvcCA/IGkgKiAxMi41IDogMTAwIC0gMTIuNSooaSsxKX1cblx0XHQ8ZGl2IGNsYXNzPVwic3F1YXJlXCIgc3R5bGU9XCJtYXJnaW4tbGVmdDp7bWFyZ2luTGVmdH0lO21hcmdpbi10b3A6e21hcmdpblRvcH0lO1wiPlxuXHRcdFx0PGRpdlxuXHRcdFx0XHRjbGFzcz1cInBpZWNlIHtwaWVjZX1cIiBjbGFzczp3aGl0ZSBjbGFzczpibGFja1xuXHRcdFx0XHRvbjpjbGljaz17KCk9PmNhbGxiYWNrKHBpZWNlKX1cblx0XHRcdFx0b246a2V5ZG93bj17KGUpPT5rZXlib2FyZENhbGxiYWNrKGUscGllY2UpfVxuXHRcdFx0XHRyb2xlPVwiYnV0dG9uXCIgdGFiaW5kZXg9XCIwXCIgYXJpYS1sYWJlbD1cIlByb21vdGUgdG8ge3BpZWNlTmFtZXNbcGllY2VdfVwiXG5cdFx0XHQ+PC9kaXY+XG5cdFx0PC9kaXY+XG5cdHsvZWFjaH1cbjwvZGl2PlxuXG48c3R5bGU+XG5cdGRpdi5kaWFsb2cge1xuXHRcdHdpZHRoOjEwMCU7XG5cdFx0aGVpZ2h0OjEwMCU7XG5cdFx0cG9zaXRpb246IGFic29sdXRlO1xuXHRcdHRvcDowO1xuXHRcdGxlZnQ6MDtcblx0XHR6LWluZGV4OjEwO1xuXHRcdGJhY2tncm91bmQ6IHJnYmEoMjU1LDI1NSwyNTUsMC4zMCk7XG5cdH1cblx0ZGl2LnNxdWFyZSB7XG5cdFx0cG9zaXRpb246YWJzb2x1dGU7XG5cdFx0d2lkdGg6MTIuNSU7XG5cdFx0aGVpZ2h0OjEyLjUlO1xuXHRcdGJhY2tncm91bmQtY29sb3I6I2IwYjBiMDtcblx0XHRib3JkZXItcmFkaXVzOjUwJTtcblx0XHRib3gtc2hhZG93Omluc2V0IDAgMCAyNXB4IDNweCBncmV5O1xuXHRcdHRyYW5zaXRpb246IGFsbCAxNTBtcztcblx0fVxuXHRkaXYuc3F1YXJlOmhvdmVyIHtcblx0XHRib3JkZXItcmFkaXVzOjA7XG5cdH1cblx0ZGl2LnNxdWFyZSBkaXYucGllY2Uge1xuXHRcdHdpZHRoOjEwMCU7XG5cdFx0aGVpZ2h0OjEwMCU7XG5cdFx0YmFja2dyb3VuZC1zaXplOmNvdmVyO1xuXHRcdGN1cnNvcjpwb2ludGVyO1xuXHRcdHRyYW5zaXRpb246IGFsbCAxNTBtcztcblx0XHR0cmFuc2Zvcm06c2NhbGUoMC44KTtcblx0fVxuXHRkaXYuc3F1YXJlOmhvdmVyIGRpdi5waWVjZSB7XG5cdFx0dHJhbnNmb3JtOnNjYWxlKDEpO1xuXHR9XG5cblx0LyogQ2hlc3Nncm91bmQgZGVmYXVsdCBwaWVjZXMgKi9cblx0LmIud2hpdGUge1xuXHRcdGJhY2tncm91bmQtaW1hZ2U6IHVybCgnZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUhkcFpIUm9QU0kwTlNJZ2FHVnBaMmgwUFNJME5TSStQR2NnWm1sc2JEMGlibTl1WlNJZ1ptbHNiQzF5ZFd4bFBTSmxkbVZ1YjJSa0lpQnpkSEp2YTJVOUlpTXdNREFpSUhOMGNtOXJaUzEzYVdSMGFEMGlNUzQxSWlCemRISnZhMlV0YkdsdVpXTmhjRDBpY205MWJtUWlJSE4wY205clpTMXNhVzVsYW05cGJqMGljbTkxYm1RaVBqeG5JR1pwYkd3OUlpTm1abVlpSUhOMGNtOXJaUzFzYVc1bFkyRndQU0ppZFhSMElqNDhjR0YwYUNCa1BTSk5PU0F6Tm1NekxqTTVMUzQ1TnlBeE1DNHhNUzQwTXlBeE15NDFMVElnTXk0ek9TQXlMalF6SURFd0xqRXhJREV1TURNZ01UTXVOU0F5SURBZ01DQXhMalkxTGpVMElETWdNaTB1TmpndU9UY3RNUzQyTlM0NU9TMHpJQzQxTFRNdU16a3RMamszTFRFd0xqRXhMalEyTFRFekxqVXRNUzB6TGpNNUlERXVORFl0TVRBdU1URXVNRE10TVRNdU5TQXhMVEV1TXpVMExqUTVMVEl1TXpJekxqUTNMVE10TGpVZ01TNHpOVFF0TVM0NU5DQXpMVElnTXkweWVpSXZQanh3WVhSb0lHUTlJazB4TlNBek1tTXlMalVnTWk0MUlERXlMalVnTWk0MUlERTFJREFnTGpVdE1TNDFJREF0TWlBd0xUSWdNQzB5TGpVdE1pNDFMVFF0TWk0MUxUUWdOUzQxTFRFdU5TQTJMVEV4TGpVdE5TMHhOUzQxTFRFeElEUXRNVEF1TlNBeE5DMDFJREUxTGpVZ01DQXdMVEl1TlNBeExqVXRNaTQxSURRZ01DQXdMUzQxTGpVZ01DQXllaUl2UGp4d1lYUm9JR1E5SWsweU5TQTRZVEl1TlNBeUxqVWdNQ0F4SURFdE5TQXdJREl1TlNBeUxqVWdNQ0F4SURFZ05TQXdlaUl2UGp3dlp6NDhjR0YwYUNCa1BTSk5NVGN1TlNBeU5tZ3hNRTB4TlNBek1HZ3hOVzB0Tnk0MUxURTBMalYyTlUweU1DQXhPR2cxSWlCemRISnZhMlV0YkdsdVpXcHZhVzQ5SW0xcGRHVnlJaTgrUEM5blBqd3ZjM1puUGc9PScpO1xuXHR9XG5cdC5uLndoaXRlIHtcblx0XHRiYWNrZ3JvdW5kLWltYWdlOiB1cmwoJ2RhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaUlIZHBaSFJvUFNJME5TSWdhR1ZwWjJoMFBTSTBOU0krUEdjZ1ptbHNiRDBpYm05dVpTSWdabWxzYkMxeWRXeGxQU0psZG1WdWIyUmtJaUJ6ZEhKdmEyVTlJaU13TURBaUlITjBjbTlyWlMxM2FXUjBhRDBpTVM0MUlpQnpkSEp2YTJVdGJHbHVaV05oY0QwaWNtOTFibVFpSUhOMGNtOXJaUzFzYVc1bGFtOXBiajBpY205MWJtUWlQanh3WVhSb0lHUTlJazB5TWlBeE1HTXhNQzQxSURFZ01UWXVOU0E0SURFMklESTVTREUxWXpBdE9TQXhNQzAyTGpVZ09DMHlNU0lnWm1sc2JEMGlJMlptWmlJdlBqeHdZWFJvSUdROUlrMHlOQ0F4T0dNdU16Z2dNaTQ1TVMwMUxqVTFJRGN1TXpjdE9DQTVMVE1nTWkweUxqZ3lJRFF1TXpRdE5TQTBMVEV1TURReUxTNDVOQ0F4TGpReExUTXVNRFFnTUMwekxURWdNQ0F1TVRrZ01TNHlNeTB4SURJdE1TQXdMVFF1TURBeklERXROQzAwSURBdE1pQTJMVEV5SURZdE1USnpNUzQ0T1MweExqa2dNaTB6TGpWakxTNDNNeTB1T1RrMExTNDFMVEl0TGpVdE15QXhMVEVnTXlBeUxqVWdNeUF5TGpWb01uTXVOemd0TVM0NU9USWdNaTQxTFROak1TQXdJREVnTXlBeElETWlJR1pwYkd3OUlpTm1abVlpTHo0OGNHRjBhQ0JrUFNKTk9TNDFJREkxTGpWaExqVXVOU0F3SURFZ01TMHhJREFnTGpVdU5TQXdJREVnTVNBeElEQjZiVFV1TkRNekxUa3VOelZoTGpVZ01TNDFJRE13SURFZ01TMHVPRFkyTFM0MUxqVWdNUzQxSURNd0lERWdNU0F1T0RZMkxqVjZJaUJtYVd4c1BTSWpNREF3SWk4K1BDOW5Qand2YzNablBnPT0nKTtcblx0fVxuXHQuci53aGl0ZSB7XG5cdFx0YmFja2dyb3VuZC1pbWFnZTogdXJsKCdkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUI0Yld4dWN6MGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNakF3TUM5emRtY2lJSGRwWkhSb1BTSTBOU0lnYUdWcFoyaDBQU0kwTlNJK1BHY2dabWxzYkQwaUkyWm1aaUlnWm1sc2JDMXlkV3hsUFNKbGRtVnViMlJrSWlCemRISnZhMlU5SWlNd01EQWlJSE4wY205clpTMTNhV1IwYUQwaU1TNDFJaUJ6ZEhKdmEyVXRiR2x1WldOaGNEMGljbTkxYm1RaUlITjBjbTlyWlMxc2FXNWxhbTlwYmowaWNtOTFibVFpUGp4d1lYUm9JR1E5SWswNUlETTVhREkzZGkwelNEbDJNM3B0TXkwemRpMDBhREl4ZGpSSU1USjZiUzB4TFRJeVZqbG9OSFl5YURWV09XZzFkakpvTlZZNWFEUjJOU0lnYzNSeWIydGxMV3hwYm1WallYQTlJbUoxZEhRaUx6NDhjR0YwYUNCa1BTSk5NelFnTVRSc0xUTWdNMGd4Tkd3dE15MHpJaTgrUEhCaGRHZ2daRDBpVFRNeElERTNkakV5TGpWSU1UUldNVGNpSUhOMGNtOXJaUzFzYVc1bFkyRndQU0ppZFhSMElpQnpkSEp2YTJVdGJHbHVaV3B2YVc0OUltMXBkR1Z5SWk4K1BIQmhkR2dnWkQwaVRUTXhJREk1TGpWc01TNDFJREl1TldndE1qQnNNUzQxTFRJdU5TSXZQanh3WVhSb0lHUTlJazB4TVNBeE5HZ3lNeUlnWm1sc2JEMGlibTl1WlNJZ2MzUnliMnRsTFd4cGJtVnFiMmx1UFNKdGFYUmxjaUl2UGp3dlp6NDhMM04yWno0PScpO1xuXHR9XG5cdC5xLndoaXRlIHtcblx0XHRiYWNrZ3JvdW5kLWltYWdlOiB1cmwoJ2RhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaUlIZHBaSFJvUFNJME5TSWdhR1ZwWjJoMFBTSTBOU0krUEdjZ1ptbHNiRDBpSTJabVppSWdabWxzYkMxeWRXeGxQU0psZG1WdWIyUmtJaUJ6ZEhKdmEyVTlJaU13TURBaUlITjBjbTlyWlMxM2FXUjBhRDBpTVM0MUlpQnpkSEp2YTJVdGJHbHVaV05oY0QwaWNtOTFibVFpSUhOMGNtOXJaUzFzYVc1bGFtOXBiajBpY205MWJtUWlQanh3WVhSb0lHUTlJazA0SURFeVlUSWdNaUF3SURFZ01TMDBJREFnTWlBeUlEQWdNU0F4SURRZ01IcHRNVFl1TlMwMExqVmhNaUF5SURBZ01TQXhMVFFnTUNBeUlESWdNQ0F4SURFZ05DQXdlazAwTVNBeE1tRXlJRElnTUNBeElERXROQ0F3SURJZ01pQXdJREVnTVNBMElEQjZUVEUySURndU5XRXlJRElnTUNBeElERXROQ0F3SURJZ01pQXdJREVnTVNBMElEQjZUVE16SURsaE1pQXlJREFnTVNBeExUUWdNQ0F5SURJZ01DQXhJREVnTkNBd2VpSXZQanh3WVhSb0lHUTlJazA1SURJMll6Z3VOUzB4TGpVZ01qRXRNUzQxSURJM0lEQnNNaTB4TWkwM0lERXhWakV4YkMwMUxqVWdNVE11TlMwekxURTFMVE1nTVRVdE5TNDFMVEUwVmpJMVREY2dNVFJzTWlBeE1ub2lJSE4wY205clpTMXNhVzVsWTJGd1BTSmlkWFIwSWk4K1BIQmhkR2dnWkQwaVRUa2dNalpqTUNBeUlERXVOU0F5SURJdU5TQTBJREVnTVM0MUlERWdNU0F1TlNBekxqVXRNUzQxSURFdE1TNDFJREl1TlMweExqVWdNaTQxTFRFdU5TQXhMalV1TlNBeUxqVXVOU0F5TGpVZ05pNDFJREVnTVRZdU5TQXhJREl6SURBZ01DQXdJREV1TlMweElEQXRNaTQxSURBZ01DQXVOUzB4TGpVdE1TMHlMalV0TGpVdE1pNDFMUzQxTFRJZ0xqVXRNeTQxSURFdE1pQXlMalV0TWlBeUxqVXROQzA0TGpVdE1TNDFMVEU0TGpVdE1TNDFMVEkzSURCNklpQnpkSEp2YTJVdGJHbHVaV05oY0QwaVluVjBkQ0l2UGp4d1lYUm9JR1E5SWsweE1TNDFJRE13WXpNdU5TMHhJREU0TGpVdE1TQXlNaUF3VFRFeUlETXpMalZqTmkweElERTFMVEVnTWpFZ01DSWdabWxzYkQwaWJtOXVaU0l2UGp3dlp6NDhMM04yWno0PScpO1xuXHR9XG5cdC5iLmJsYWNrIHtcblx0XHRiYWNrZ3JvdW5kLWltYWdlOiB1cmwoJ2RhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaUlIZHBaSFJvUFNJME5TSWdhR1ZwWjJoMFBTSTBOU0krUEdjZ1ptbHNiRDBpYm05dVpTSWdabWxzYkMxeWRXeGxQU0psZG1WdWIyUmtJaUJ6ZEhKdmEyVTlJaU13TURBaUlITjBjbTlyWlMxM2FXUjBhRDBpTVM0MUlpQnpkSEp2YTJVdGJHbHVaV05oY0QwaWNtOTFibVFpSUhOMGNtOXJaUzFzYVc1bGFtOXBiajBpY205MWJtUWlQanhuSUdacGJHdzlJaU13TURBaUlITjBjbTlyWlMxc2FXNWxZMkZ3UFNKaWRYUjBJajQ4Y0dGMGFDQmtQU0pOT1NBek5tTXpMak01TFM0NU55QXhNQzR4TVM0ME15QXhNeTQxTFRJZ015NHpPU0F5TGpReklERXdMakV4SURFdU1ETWdNVE11TlNBeUlEQWdNQ0F4TGpZMUxqVTBJRE1nTWkwdU5qZ3VPVGN0TVM0Mk5TNDVPUzB6SUM0MUxUTXVNemt0TGprM0xURXdMakV4TGpRMkxURXpMalV0TVMwekxqTTVJREV1TkRZdE1UQXVNVEV1TURNdE1UTXVOU0F4TFRFdU16VTBMalE1TFRJdU16SXpMalEzTFRNdExqVWdNUzR6TlRRdE1TNDVOQ0F6TFRJZ015MHllaUl2UGp4d1lYUm9JR1E5SWsweE5TQXpNbU15TGpVZ01pNDFJREV5TGpVZ01pNDFJREUxSURBZ0xqVXRNUzQxSURBdE1pQXdMVElnTUMweUxqVXRNaTQxTFRRdE1pNDFMVFFnTlM0MUxURXVOU0EyTFRFeExqVXROUzB4TlM0MUxURXhJRFF0TVRBdU5TQXhOQzAxSURFMUxqVWdNQ0F3TFRJdU5TQXhMalV0TWk0MUlEUWdNQ0F3TFM0MUxqVWdNQ0F5ZWlJdlBqeHdZWFJvSUdROUlrMHlOU0E0WVRJdU5TQXlMalVnTUNBeElERXROU0F3SURJdU5TQXlMalVnTUNBeElERWdOU0F3ZWlJdlBqd3ZaejQ4Y0dGMGFDQmtQU0pOTVRjdU5TQXlObWd4TUUweE5TQXpNR2d4TlcwdE55NDFMVEUwTGpWMk5VMHlNQ0F4T0dnMUlpQnpkSEp2YTJVOUlpTmxZMlZqWldNaUlITjBjbTlyWlMxc2FXNWxhbTlwYmowaWJXbDBaWElpTHo0OEwyYytQQzl6ZG1jKycpO1xuXHR9XG5cdC5uLmJsYWNrIHtcblx0XHRiYWNrZ3JvdW5kLWltYWdlOiB1cmwoJ2RhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaUlIZHBaSFJvUFNJME5TSWdhR1ZwWjJoMFBTSTBOU0krUEdjZ1ptbHNiRDBpYm05dVpTSWdabWxzYkMxeWRXeGxQU0psZG1WdWIyUmtJaUJ6ZEhKdmEyVTlJaU13TURBaUlITjBjbTlyWlMxM2FXUjBhRDBpTVM0MUlpQnpkSEp2YTJVdGJHbHVaV05oY0QwaWNtOTFibVFpSUhOMGNtOXJaUzFzYVc1bGFtOXBiajBpY205MWJtUWlQanh3WVhSb0lHUTlJazB5TWlBeE1HTXhNQzQxSURFZ01UWXVOU0E0SURFMklESTVTREUxWXpBdE9TQXhNQzAyTGpVZ09DMHlNU0lnWm1sc2JEMGlJekF3TUNJdlBqeHdZWFJvSUdROUlrMHlOQ0F4T0dNdU16Z2dNaTQ1TVMwMUxqVTFJRGN1TXpjdE9DQTVMVE1nTWkweUxqZ3lJRFF1TXpRdE5TQTBMVEV1TURReUxTNDVOQ0F4TGpReExUTXVNRFFnTUMwekxURWdNQ0F1TVRrZ01TNHlNeTB4SURJdE1TQXdMVFF1TURBeklERXROQzAwSURBdE1pQTJMVEV5SURZdE1USnpNUzQ0T1MweExqa2dNaTB6TGpWakxTNDNNeTB1T1RrMExTNDFMVEl0TGpVdE15QXhMVEVnTXlBeUxqVWdNeUF5TGpWb01uTXVOemd0TVM0NU9USWdNaTQxTFROak1TQXdJREVnTXlBeElETWlJR1pwYkd3OUlpTXdNREFpTHo0OGNHRjBhQ0JrUFNKTk9TNDFJREkxTGpWaExqVXVOU0F3SURFZ01TMHhJREFnTGpVdU5TQXdJREVnTVNBeElEQjZiVFV1TkRNekxUa3VOelZoTGpVZ01TNDFJRE13SURFZ01TMHVPRFkyTFM0MUxqVWdNUzQxSURNd0lERWdNU0F1T0RZMkxqVjZJaUJtYVd4c1BTSWpaV05sWTJWaklpQnpkSEp2YTJVOUlpTmxZMlZqWldNaUx6NDhjR0YwYUNCa1BTSk5NalF1TlRVZ01UQXVOR3d0TGpRMUlERXVORFV1TlM0eE5XTXpMakUxSURFZ05TNDJOU0F5TGpRNUlEY3VPU0EyTGpjMVV6TTFMamMxSURJNUxqQTJJRE0xTGpJMUlETTViQzB1TURVdU5XZ3lMakkxYkM0d05TMHVOV011TlMweE1DNHdOaTB1T0RndE1UWXVPRFV0TXk0eU5TMHlNUzR6TkMweUxqTTNMVFF1TkRrdE5TNDNPUzAyTGpZMExUa3VNVGt0Tnk0eE5td3RMalV4TFM0eGVpSWdabWxzYkQwaUkyVmpaV05sWXlJZ2MzUnliMnRsUFNKdWIyNWxJaTgrUEM5blBqd3ZjM1puUGc9PScpO1xuXHR9XG5cdC5yLmJsYWNrIHtcblx0XHRiYWNrZ3JvdW5kLWltYWdlOiB1cmwoJ2RhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaUlIZHBaSFJvUFNJME5TSWdhR1ZwWjJoMFBTSTBOU0krUEdjZ1ptbHNiQzF5ZFd4bFBTSmxkbVZ1YjJSa0lpQnpkSEp2YTJVOUlpTXdNREFpSUhOMGNtOXJaUzEzYVdSMGFEMGlNUzQxSWlCemRISnZhMlV0YkdsdVpXTmhjRDBpY205MWJtUWlJSE4wY205clpTMXNhVzVsYW05cGJqMGljbTkxYm1RaVBqeHdZWFJvSUdROUlrMDVJRE01YURJM2RpMHpTRGwyTTNwdE15NDFMVGRzTVM0MUxUSXVOV2d4TjJ3eExqVWdNaTQxYUMweU1IcHRMUzQxSURSMkxUUm9NakYyTkVneE1ub2lJSE4wY205clpTMXNhVzVsWTJGd1BTSmlkWFIwSWk4K1BIQmhkR2dnWkQwaVRURTBJREk1TGpWMkxURXphREUzZGpFelNERTBlaUlnYzNSeWIydGxMV3hwYm1WallYQTlJbUoxZEhRaUlITjBjbTlyWlMxc2FXNWxhbTlwYmowaWJXbDBaWElpTHo0OGNHRjBhQ0JrUFNKTk1UUWdNVFl1TlV3eE1TQXhOR2d5TTJ3dE15QXlMalZJTVRSNlRURXhJREUwVmpsb05IWXlhRFZXT1dnMWRqSm9OVlk1YURSMk5VZ3hNWG9pSUhOMGNtOXJaUzFzYVc1bFkyRndQU0ppZFhSMElpOCtQSEJoZEdnZ1pEMGlUVEV5SURNMUxqVm9NakZ0TFRJd0xUUm9NVGx0TFRFNExUSm9NVGR0TFRFM0xURXphREUzVFRFeElERTBhREl6SWlCbWFXeHNQU0p1YjI1bElpQnpkSEp2YTJVOUlpTmxZMlZqWldNaUlITjBjbTlyWlMxM2FXUjBhRDBpTVNJZ2MzUnliMnRsTFd4cGJtVnFiMmx1UFNKdGFYUmxjaUl2UGp3dlp6NDhMM04yWno0PScpO1xuXHR9XG5cdC5xLmJsYWNrIHtcblx0XHRiYWNrZ3JvdW5kLWltYWdlOiB1cmwoJ2RhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaUlIZHBaSFJvUFNJME5TSWdhR1ZwWjJoMFBTSTBOU0krUEdjZ1ptbHNiQzF5ZFd4bFBTSmxkbVZ1YjJSa0lpQnpkSEp2YTJVOUlpTXdNREFpSUhOMGNtOXJaUzEzYVdSMGFEMGlNUzQxSWlCemRISnZhMlV0YkdsdVpXTmhjRDBpY205MWJtUWlJSE4wY205clpTMXNhVzVsYW05cGJqMGljbTkxYm1RaVBqeG5JSE4wY205clpUMGlibTl1WlNJK1BHTnBjbU5zWlNCamVEMGlOaUlnWTNrOUlqRXlJaUJ5UFNJeUxqYzFJaTgrUEdOcGNtTnNaU0JqZUQwaU1UUWlJR041UFNJNUlpQnlQU0l5TGpjMUlpOCtQR05wY21Oc1pTQmplRDBpTWpJdU5TSWdZM2s5SWpnaUlISTlJakl1TnpVaUx6NDhZMmx5WTJ4bElHTjRQU0l6TVNJZ1kzazlJamtpSUhJOUlqSXVOelVpTHo0OFkybHlZMnhsSUdONFBTSXpPU0lnWTNrOUlqRXlJaUJ5UFNJeUxqYzFJaTgrUEM5blBqeHdZWFJvSUdROUlrMDVJREkyWXpndU5TMHhMalVnTWpFdE1TNDFJREkzSURCc01pNDFMVEV5TGpWTU16RWdNalZzTFM0ekxURTBMakV0TlM0eUlERXpMall0TXkweE5DNDFMVE1nTVRRdU5TMDFMakl0TVRNdU5rd3hOQ0F5TlNBMkxqVWdNVE11TlNBNUlESTJlaUlnYzNSeWIydGxMV3hwYm1WallYQTlJbUoxZEhRaUx6NDhjR0YwYUNCa1BTSk5PU0F5Tm1Nd0lESWdNUzQxSURJZ01pNDFJRFFnTVNBeExqVWdNU0F4SUM0MUlETXVOUzB4TGpVZ01TMHhMalVnTWk0MUxURXVOU0F5TGpVdE1TNDFJREV1TlM0MUlESXVOUzQxSURJdU5TQTJMalVnTVNBeE5pNDFJREVnTWpNZ01DQXdJREFnTVM0MUxURWdNQzB5TGpVZ01DQXdJQzQxTFRFdU5TMHhMVEl1TlMwdU5TMHlMalV0TGpVdE1pQXVOUzB6TGpVZ01TMHlJREl1TlMweUlESXVOUzAwTFRndU5TMHhMalV0TVRndU5TMHhMalV0TWpjZ01Ib2lJSE4wY205clpTMXNhVzVsWTJGd1BTSmlkWFIwSWk4K1BIQmhkR2dnWkQwaVRURXhJRE00TGpWaE16VWdNelVnTVNBd0lEQWdNak1nTUNJZ1ptbHNiRDBpYm05dVpTSWdjM1J5YjJ0bExXeHBibVZqWVhBOUltSjFkSFFpTHo0OGNHRjBhQ0JrUFNKTk1URWdNamxoTXpVZ016VWdNU0F3SURFZ01qTWdNRzB0TWpFdU5TQXlMalZvTWpCdExUSXhJRE5oTXpVZ016VWdNU0F3SURBZ01qSWdNRzB0TWpNZ00yRXpOU0F6TlNBeElEQWdNQ0F5TkNBd0lpQm1hV3hzUFNKdWIyNWxJaUJ6ZEhKdmEyVTlJaU5sWTJWalpXTWlMejQ4TDJjK1BDOXpkbWMrJyk7XG5cdH1cbjwvc3R5bGU+XG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQW9DQSxDQUFDLEdBQUcsc0JBQU8sQ0FBQztBQUNaLEVBQUUsVUFBVTtBQUNaLEVBQUUsV0FBVztBQUNiLEVBQUUsa0JBQWtCO0FBQ3BCLEVBQUUsS0FBSztBQUNQLEVBQUUsTUFBTTtBQUNSLEVBQUUsVUFBVTtBQUNaLEVBQUUsa0NBQWtDO0FBQ3BDO0FBQ0EsQ0FBQyxHQUFHLHNCQUFPLENBQUM7QUFDWixFQUFFLGlCQUFpQjtBQUNuQixFQUFFLFdBQVc7QUFDYixFQUFFLFlBQVk7QUFDZCxFQUFFLHdCQUF3QjtBQUMxQixFQUFFLGlCQUFpQjtBQUNuQixFQUFFLGtDQUFrQztBQUNwQyxFQUFFLHFCQUFxQjtBQUN2QjtBQUNBLENBQUMsR0FBRyxzQkFBTyxNQUFNLENBQUM7QUFDbEIsRUFBRSxlQUFlO0FBQ2pCO0FBQ0EsQ0FBQyxHQUFHLHNCQUFPLENBQUMsR0FBRyw2QkFBTSxDQUFDO0FBQ3RCLEVBQUUsVUFBVTtBQUNaLEVBQUUsV0FBVztBQUNiLEVBQUUscUJBQXFCO0FBQ3ZCLEVBQUUsY0FBYztBQUNoQixFQUFFLHFCQUFxQjtBQUN2QixFQUFFLG9CQUFvQjtBQUN0QjtBQUNBLENBQUMsR0FBRyxzQkFBTyxNQUFNLENBQUMsR0FBRyw2QkFBTSxDQUFDO0FBQzVCLEVBQUUsa0JBQWtCO0FBQ3BCOztBQUVBO0FBQ0EsQ0FBQyxFQUFFLHFCQUFNLENBQUM7QUFDVixFQUFFLG0rQkFBbStCO0FBQ3IrQjtBQUNBLENBQUMsRUFBRSxxQkFBTSxDQUFDO0FBQ1YsRUFBRSxtMUJBQW0xQjtBQUNyMUI7QUFDQSxDQUFDLEVBQUUscUJBQU0sQ0FBQztBQUNWLEVBQUUsMnJCQUEyckI7QUFDN3JCO0FBQ0EsQ0FBQyxFQUFFLHFCQUFNLENBQUM7QUFDVixFQUFFLDJrQ0FBMmtDO0FBQzdrQztBQUNBLENBQUMsRUFBRSxxQkFBTSxDQUFDO0FBQ1YsRUFBRSx1L0JBQXUvQjtBQUN6L0I7QUFDQSxDQUFDLEVBQUUscUJBQU0sQ0FBQztBQUNWLEVBQUUsMm5DQUEybkM7QUFDN25DO0FBQ0EsQ0FBQyxFQUFFLHFCQUFNLENBQUM7QUFDVixFQUFFLHV6QkFBdXpCO0FBQ3p6QjtBQUNBLENBQUMsRUFBRSxxQkFBTSxDQUFDO0FBQ1YsRUFBRSwydkNBQTJ2QztBQUM3dkMiLCJpZ25vcmVMaXN0IjpbXX0= */"
};
function PromotionDialog($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, PromotionDialog);
  append_styles($$anchor, $$css3);
  let square = prop($$props, "square", 8);
  let orientation = prop($$props, "orientation", 8, "w");
  let callback = prop($$props, "callback", 8);
  let className = prop($$props, "class", 24, () => void 0);
  const marginLeft = 100 / 8 * (strict_equals(orientation(), "w") ? squareToFileNumber(square()) : 7 - squareToFileNumber(square()));
  const white = strict_equals(square().charAt(1), "8");
  const black = !white;
  const pieces = ["q", "n", "r", "b"];
  const pieceNames = {
    q: "queen",
    n: "knight",
    r: "rook",
    b: "bishop",
    p: "pawn",
    k: "king"
  };
  function squareToFileNumber(square2) {
    return square2.charCodeAt(0) - 97;
  }
  function keyboardCallback(event2, promotion) {
    if (strict_equals(event2.key, "Enter") || strict_equals(event2.key, " ")) {
      callback()(promotion);
    }
  }
  var $$exports = { ...legacy_api() };
  init();
  var div = root3();
  add_svelte_meta(
    () => each(div, 5, () => pieces, index, ($$anchor2, piece, i) => {
      const putPiecesFromTop = tag(derived_safe_equal(() => white && strict_equals(orientation(), "w") || black && strict_equals(orientation(), "b")), "putPiecesFromTop");
      get(putPiecesFromTop);
      const marginTop = tag(derived_safe_equal(() => get(putPiecesFromTop) ? i * 12.5 : 100 - 12.5 * (i + 1)), "marginTop");
      get(marginTop);
      var div_1 = root_1();
      var div_2 = child(div_1);
      let classes;
      reset(div_1);
      template_effect(() => {
        set_style(div_1, `margin-left:${marginLeft}%;margin-top:${get(marginTop) ?? ""}%;`);
        classes = set_class(div_2, 1, `piece ${get(piece) ?? ""}`, "s-SwSmnh7q9HVq", classes, { white, black });
        set_attribute(div_2, "aria-label", `Promote to ${(get(piece), untrack(() => pieceNames[get(piece)])) ?? ""}`);
      });
      event("click", div_2, () => callback()(get(piece)));
      event("keydown", div_2, (e) => keyboardCallback(e, get(piece)));
      append($$anchor2, div_1);
    }),
    "each",
    PromotionDialog,
    22,
    1
  );
  reset(div);
  template_effect(() => set_class(div, 1, `dialog ${className() ?? ""}`, "s-SwSmnh7q9HVq"));
  append($$anchor, div);
  return pop($$exports);
}
if (import.meta.hot) {
  PromotionDialog = hmr(PromotionDialog);
  import.meta.hot.accept((module) => {
    cleanup_styles("s-SwSmnh7q9HVq");
    PromotionDialog[HMR].update(module.default);
  });
}
var PromotionDialog_default = PromotionDialog;

// node_modules/svelte-chess/dist/api.js
var Api = class _Api {
  cg;
  stateChangeCallback;
  promotionCallback;
  moveCallback;
  gameOverCallback;
  _orientation;
  engine;
  chessJS;
  gameIsOver = false;
  initialised = false;
  constructor(cg, fen = "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1", stateChangeCallback = (api) => {
  }, promotionCallback = async (sq) => "q", moveCallback = (m) => {
  }, gameOverCallback = (go) => {
  }, _orientation = "w", engine = void 0) {
    this.cg = cg;
    this.stateChangeCallback = stateChangeCallback;
    this.promotionCallback = promotionCallback;
    this.moveCallback = moveCallback;
    this.gameOverCallback = gameOverCallback;
    this._orientation = _orientation;
    this.engine = engine;
    this.cg.set({
      fen,
      orientation: _Api._colorToCgColor(_orientation),
      movable: { free: false },
      premovable: { enabled: false }
    });
    this.chessJS = new Chess(fen);
  }
  async init() {
    if (this.engine) {
      await this.engine.init();
      this.load(this.chessJS.fen());
      if (this._enginePlaysNextMove()) {
        this.playEngineMove();
      }
    } else {
      this.load(this.chessJS.fen());
    }
    this.initialised = true;
  }
  // Load FEN. Throws exception on invalid FEN.
  load(fen) {
    let engineStopSearchPromise;
    if (this.initialised && this.engine?.isSearching())
      engineStopSearchPromise = this.engine.stopSearch();
    this.chessJS.load(fen);
    this._checkForGameOver();
    this.cg.set({ animation: { enabled: false } });
    const cgColor = _Api._colorToCgColor(this.chessJS.turn());
    const enginePlaysNextMove = this._enginePlaysNextMove();
    this.cg.set({
      fen,
      turnColor: cgColor,
      check: this.chessJS.inCheck(),
      lastMove: void 0,
      selected: void 0,
      movable: {
        free: false,
        color: cgColor,
        dests: enginePlaysNextMove ? /* @__PURE__ */ new Map() : this.possibleMovesDests(),
        events: {
          after: (orig, dest) => {
            this._chessgroundMoveCallback(orig, dest);
          }
        }
      }
    });
    this.cg.set({ animation: { enabled: true } });
    if (this.initialised && enginePlaysNextMove) {
      if (engineStopSearchPromise) {
        engineStopSearchPromise.then(() => {
          this.playEngineMove();
        });
      } else {
        this.playEngineMove();
      }
    }
    this.stateChangeCallback(this);
  }
  /*
   * Making a move
   */
  // called after a move is played on Chessground
  async _chessgroundMoveCallback(orig, dest) {
    if (orig === "a0" || dest === "a0") {
      throw Error("invalid square");
    }
    if (this.engine && this.engine.isSearching())
      this.engine.stopSearch();
    let cjsMove;
    if (this._moveIsPromotion(orig, dest)) {
      const promotion = await this.promotionCallback(dest);
      cjsMove = this.chessJS.move({ from: orig, to: dest, promotion });
    } else {
      cjsMove = this.chessJS.move({ from: orig, to: dest });
    }
    const move3 = _Api._cjsMoveToMove(cjsMove);
    this._postMoveAdmin(move3);
  }
  _moveIsPromotion(orig, dest) {
    return this.chessJS.get(orig).type === "p" && (dest.charAt(1) == "1" || dest.charAt(1) == "8");
  }
  // Make a move programmatically
  // argument is either a short algebraic notation (SAN) string
  // or an object with from/to/promotion (see chess.js move())
  move(moveSanOrObj) {
    if (!this.initialised)
      throw new Error("Called move before initialisation finished.");
    if (this.gameIsOver)
      throw new Error("Invalid move: Game is over.");
    if (this.engine && this.engine.isSearching())
      this.engine.stopSearch();
    const cjsMove = this.chessJS.move(moveSanOrObj);
    const move3 = _Api._cjsMoveToMove(cjsMove);
    this.cg.move(move3.from, move3.to);
    this.cg.set({ turnColor: _Api._colorToCgColor(this.chessJS.turn()) });
    this._postMoveAdmin(move3);
  }
  // Make a move programmatically from long algebraic notation (LAN) string,
  // as returned by UCI engines.
  moveLan(moveLan) {
    const from = moveLan.slice(0, 2);
    const to = moveLan.slice(2, 4);
    const promotion = moveLan.charAt(4) || void 0;
    this.move({ from, to, promotion });
  }
  // Called after a move (chess.js or chessground) to:
  // - update chess-logic details Chessground doesn't handle
  // - dispatch events
  // - play engine move 
  _postMoveAdmin(move3) {
    const enginePlaysNextMove = this._enginePlaysNextMove();
    if (move3.flags.includes("e") || move3.flags.includes("p")) {
      this.cg.set({ fen: this.chessJS.fen() });
    }
    if (move3.check) {
      this.cg.set({ check: true });
    }
    this.moveCallback(move3);
    this._checkForGameOver();
    if (enginePlaysNextMove) {
      this.cg.set({ movable: { dests: /* @__PURE__ */ new Map() } });
    } else {
      this._updateChessgroundWithPossibleMoves();
    }
    this.stateChangeCallback(this);
    if (!this.gameIsOver && enginePlaysNextMove) {
      this.playEngineMove();
    }
  }
  async playEngineMove() {
    if (!this.engine)
      throw new Error("playEngineMove called without initialised engine");
    return this.engine.getMove(this.chessJS.fen()).then((lan) => {
      this.moveLan(lan);
    });
  }
  _enginePlaysNextMove() {
    return this.engine && (this.engine.getColor() === "both" || this.engine.getColor() === this.chessJS.turn());
  }
  _updateChessgroundWithPossibleMoves() {
    const cgColor = _Api._colorToCgColor(this.chessJS.turn());
    this.cg.set({
      turnColor: cgColor,
      movable: {
        color: cgColor,
        dests: this.possibleMovesDests()
      }
    });
  }
  _checkForGameOver() {
    if (this.chessJS.isCheckmate()) {
      const result = this.chessJS.turn() == "w" ? 0 : 1;
      this.gameOverCallback({ reason: "checkmate", result });
      this.gameIsOver = true;
    } else if (this.chessJS.isStalemate()) {
      this.gameOverCallback({ reason: "stalemate", result: 0.5 });
      this.gameIsOver = true;
    } else if (this.chessJS.isInsufficientMaterial()) {
      this.gameOverCallback({ reason: "insufficient material", result: 0.5 });
      this.gameIsOver = true;
    } else if (this.chessJS.isThreefoldRepetition()) {
      this.gameOverCallback({ reason: "repetition", result: 0.5 });
      this.gameIsOver = true;
    } else if (this.chessJS.isDraw()) {
      this.gameOverCallback({ reason: "fifty-move rule", result: 0.5 });
      this.gameIsOver = true;
    } else {
      this.gameIsOver = false;
    }
  }
  /*
   *
   */
  // Find all legal moves in chessground "dests" format
  possibleMovesDests() {
    const dests = /* @__PURE__ */ new Map();
    if (!this.gameIsOver) {
      SQUARES.forEach((s) => {
        const ms = this.chessJS.moves({ square: s, verbose: true });
        if (ms.length)
          dests.set(s, ms.map((m) => m.to));
      });
    }
    return dests;
  }
  // Reset board to the starting position
  reset() {
    this.load("rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1");
  }
  // Undo last move
  undo() {
    const cjsMove = this.chessJS.undo();
    const move3 = cjsMove ? _Api._cjsMoveToMove(cjsMove) : null;
    const turnColor = _Api._colorToCgColor(this.chessJS.turn());
    this.cg.set({
      fen: this.chessJS.fen(),
      check: this.chessJS.inCheck() ? turnColor : void 0,
      turnColor,
      lastMove: void 0
    });
    this.gameIsOver = false;
    this._updateChessgroundWithPossibleMoves();
    this.stateChangeCallback(this);
    return move3;
  }
  // Board orientation
  toggleOrientation() {
    this._orientation = this._orientation === "w" ? "b" : "w";
    this.cg.set({
      orientation: _Api._colorToCgColor(this._orientation)
    });
    this.stateChangeCallback(this);
  }
  orientation() {
    return this._orientation;
  }
  // Check if game is over (checkmate, stalemate, repetition, insufficient material, fifty-move rule)
  isGameOver() {
    return this.gameIsOver;
  }
  /*
   * Methods passed through to chess.js
   */
  fen() {
    return this.chessJS.fen();
  }
  turn() {
    return this.chessJS.turn();
  }
  moveNumber() {
    return this.chessJS.moveNumber();
  }
  inCheck() {
    return this.chessJS.inCheck();
  }
  history({ verbose = false } = {}) {
    if (verbose) {
      return this.chessJS.history({ verbose }).map(_Api._cjsMoveToMove);
    } else {
      return this.chessJS.history({ verbose });
    }
  }
  board() {
    return this.chessJS.board();
  }
  // Convert between chess.js color (w/b) and chessground color (white/black).
  // Chess.js color is always used internally.
  static _colorToCgColor(chessjsColor) {
    return chessjsColor === "w" ? "white" : "black";
  }
  static _cgColorToColor(chessgroundColor) {
    return chessgroundColor === "white" ? "w" : "b";
  }
  // Convert chess.js move (CjsMove) to svelte-chess Move.
  // Only difference is check:boolean and checkmate:boolean in the latter.
  static _cjsMoveToMove(cjsMove) {
    const lastSanChar = cjsMove.san.slice(-1);
    const checkmate = lastSanChar === "#";
    const check = lastSanChar === "+" || checkmate;
    return { ...cjsMove, check, checkmate };
  }
};

// node_modules/svelte-chess/dist/engine.js
var State;
(function(State2) {
  State2["Uninitialised"] = "uninitialised";
  State2["Initialising"] = "initialising";
  State2["Waiting"] = "waiting";
  State2["Searching"] = "searching";
})(State || (State = {}));

// node_modules/svelte-chess/dist/Chess.svelte
Chess2[FILENAME] = "node_modules/svelte-chess/dist/Chess.svelte";
var root4 = add_locations(from_html(`<div style="position:relative;"><!></div>`), Chess2[FILENAME], [[102, 0]]);
function Chess2($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, Chess2);
  const dispatch = createEventDispatcher();
  let chessground = mutable_source();
  let container = mutable_source();
  let moveNumber = prop($$props, "moveNumber", 12, 0);
  let turn = prop($$props, "turn", 12, "w");
  let inCheck = prop($$props, "inCheck", 12, false);
  let history = prop($$props, "history", 28, () => []);
  let isGameOver = prop($$props, "isGameOver", 12, false);
  let fen = prop($$props, "fen", 12, "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1");
  let orientation = prop($$props, "orientation", 12, "w");
  let engine = prop($$props, "engine", 24, () => void 0);
  let className = prop($$props, "class", 24, () => void 0);
  let api = void 0;
  function load(newFen) {
    if (!api) throw new Error("component not mounted yet");
    api.load(newFen);
  }
  function move3(moveSan) {
    if (!api) throw new Error("component not mounted yet");
    api.move(moveSan);
  }
  function getHistory({ verbose = false } = {}) {
    if (!api) throw new Error("component not mounted yet");
    return api.history({ verbose });
  }
  function getBoard() {
    if (!api) throw new Error("component not mounted yet");
    return api.board();
  }
  function undo() {
    if (!api) throw new Error("component not mounted yet");
    return api.undo();
  }
  function reset2() {
    if (!api) throw new Error("component not mounted yet");
    api.reset();
  }
  function toggleOrientation2() {
    if (!api) throw new Error("component not mounted yet");
    api.toggleOrientation();
  }
  async function playEngineMove() {
    if (!api) throw new Error("component not mounted yet");
    return api.playEngineMove();
  }
  function stateChangeCallback(api2) {
    fen(api2.fen());
    orientation(api2.orientation());
    moveNumber(api2.moveNumber());
    turn(api2.turn());
    inCheck(api2.inCheck());
    history(api2.history());
    isGameOver(api2.isGameOver());
  }
  function promotionCallback(square) {
    return new Promise((resolve) => {
      const element = new PromotionDialog_default({
        target: get(container),
        props: {
          square,
          orientation: orientation(),
          callback: (piece) => {
            element.$destroy();
            resolve(piece);
          }
        }
      });
    });
  }
  function moveCallback(move22) {
    dispatch("move", move22);
  }
  function gameOverCallback(gameOver) {
    dispatch("gameOver", gameOver);
  }
  onMount(async () => {
    if (engine()) {
      engine().setUciCallback((message) => dispatch("uci", message));
    }
    api = new Api(get(chessground), fen(), stateChangeCallback, promotionCallback, moveCallback, gameOverCallback, orientation(), engine());
    api.init().then(() => {
      dispatch("ready");
    });
  });
  var $$exports = {
    get load() {
      return load;
    },
    get move() {
      return move3;
    },
    get getHistory() {
      return getHistory;
    },
    get getBoard() {
      return getBoard;
    },
    get undo() {
      return undo;
    },
    get reset() {
      return reset2;
    },
    get toggleOrientation() {
      return toggleOrientation2;
    },
    get playEngineMove() {
      return playEngineMove;
    },
    ...legacy_api()
  };
  init();
  var div = root4();
  var node = child(div);
  add_svelte_meta(
    () => bind_this(
      Chessground_default(node, {
        get class() {
          return className();
        },
        $$legacy: true
      }),
      ($$value) => set(chessground, $$value),
      () => get(chessground)
    ),
    "component",
    Chess2,
    103,
    1,
    { componentTag: "Chessground" }
  );
  reset(div);
  bind_this(div, ($$value) => set(container, $$value), () => get(container));
  append($$anchor, div);
  bind_prop($$props, "load", load);
  bind_prop($$props, "move", move3);
  bind_prop($$props, "getHistory", getHistory);
  bind_prop($$props, "getBoard", getBoard);
  bind_prop($$props, "undo", undo);
  bind_prop($$props, "reset", reset2);
  bind_prop($$props, "toggleOrientation", toggleOrientation2);
  bind_prop($$props, "playEngineMove", playEngineMove);
  return pop($$exports);
}
if (import.meta.hot) {
  Chess2 = hmr(Chess2);
  import.meta.hot.accept((module) => {
    Chess2[HMR].update(module.default);
  });
}
var Chess_default = Chess2;
export {
  Chess_default as Chess
};
//# sourceMappingURL=svelte-chess.js.map
